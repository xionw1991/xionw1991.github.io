<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[通用链接debug]]></title>
      <url>%2F2016%2F12%2F07%2Fdemonayu%2Fblog%2F44.%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5debug%2F</url>
      <content type="text"><![CDATA[原文地址：http://building.usebutton.com/debugging/ios/deep-linking/links/universal-links/2016/03/31/debugging-universal-links/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在iOS10接入https的坑]]></title>
      <url>%2F2016%2F09%2F04%2Fdemonayu%2Fblog%2F43.%E5%9C%A8iOS10%E4%B8%8B%E6%8E%A5%E5%85%A5https%E7%9A%84%E5%9D%91%2F</url>
      <content type="text"><![CDATA[从2017年1月1日开始，苹果将要求所有上传的应用必须使用https接口进行数据访问，这里面有些坑让我们来研究一下； 新https政策 一句话概括：从2017年的元旦起，苹果将继续收紧应用对http的访问权限，要求开发者统一使用https进行数据访问，iOS8及更早的版本不受影响。 新规下，作为服务器的API是肯定是要使用https的，访问网页则有点特殊，因为ATS影响到NSURLSession和UIWebView，所以理论上使用webview访问的网页也必须是https，但这样显然不现实，所以苹果在iOS10添加了新keyNSAllowsArbitraryLoadsInWebContent来容许访问未加密的网页。但是这个key在iOS9下并不起作用，这样尴尬了：上传的应用不容许使用NSAllowsArbitraryLoads来绕过ATS，而在应用中又需要访问http网页，怎么办？ App Transport Security我们先来看看ATS的要求： The server certificate must meet at least one of the following trust requirements: Issued by a certificate authority (CA) whose root certificate is incorporated into the operating system Issued by a trusted root CA and installed by the user or a system administrator The negotiated Transport Layer Security version must be TLS 1.2 The negotiated TLS connection cipher suite must support forward secrecy (FS) and be one of the following: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA The leaf server certificate must be signed with one of the following types of keys: Rivest-Shamir-Adleman (RSA) key with a length of at least 2048 bits Elliptic-Curve Cryptography (ECC) key with a size of at least 256 bits In addition, the leaf server certificate hashing algorithm must be Secure Hash Algorithm 2 (SHA-2) with a digest length of at least 256 (that is, SHA-256 or greater). 大白话的就是： 服务器证书必须至少满足以下条件中的一个 颁发给服务器证书的证书机构（CA）的根证书必须是内置于操作系统的受信任根证书； 受用户或者系统管理员信任并安装到操作系统上的； 服务器TLS版本至少是1.2版本； 连接加密方式必须支持下列正向加密的一种； 证书必须使用SHA256或者更好的哈希算法进行签名，要么是2048位或者更长的RSA密钥，要么就是256位或更长的ECC密钥； 其实在这一层客户端所做的事情不多，当https服务器满足ATS默认的条件，而且SSL证书是通过权威的CA机构认证过的，客户端直接接入就可以了正常通信了（后台的兄弟们辛苦了）。搭建完成后可以使用命令行来测试是否满足ATS要求：nscurl --ats-diagnostics --verbose https://google.com。 ATS设定 NSAllowsArbitraryLoads 在Xcode7中这个key值默认为NO，我们将它设置为YES来访问任意接口，但是苹果新规出来后将限制这个key的使用，设置这个key值需要在应用审核的时候说明原因，能不能过还要看审核员的脸色； NSAllowsArbitraryLoadsInWebContent 这是iOS10在ATS中新增加的key，目的是方便使用webview框架的应用在应用内访问http网页，这个key仅在iOS10起作用； NSExceptionDomains 这个key值可以让开发者更加灵活的配置让哪些接口遵不遵守ATS的要求，具体设置方法可以参考：NSExceptionDomains； 在iOS10下同时设置NSAllowsArbitraryLoads和NSAllowsArbitraryLoadsInWebContent，前者会失效，所以在iOS10下使用NSAllowsArbitraryLoadsInWebContent就意味着除了网页浏览，其他所有的连接都必须是https的； 在iOS9下仅设置NSAllowsArbitraryLoads有效，如果设置为YES则在审核时需要说明原因，如果为NO，则表示所有的连接必须是符合ATS的要求的，包括网页浏览；如果app内部使用webview访问的页面都是固定的域名，可以通过设置NSExceptionDomains白名单在不禁用ATS的情况下进行访问； 以下是整理出来的表格： 解决方案回到第一个问题：怎么在不禁用ATS的情况下使用webview访问http网页？答：在iOS10使用NSAllowsArbitraryLoadsInWebContent来对网页内容禁用ATS，在iOS9使用NSExceptionDomains白名单形式让特定的域名绕过ATS规则，注意如果白名单的网页使用了其他的资源，比如一些图床，则需要将相关的域名也要添加进白名单。目前还不得知苹果对NSExceptionDomains的审核标准，猜测如果在上传应用时说明是webview访问一些第三方的http资源应该会比较容易过审。 参考：苹果官方文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[处理URL的几种思路]]></title>
      <url>%2F2016%2F08%2F06%2Fdemonayu%2Fblog%2F42.%E5%A4%84%E7%90%86URL%E6%8B%BC%E6%8E%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[在日常开发中，总会碰到需要在客户端对 URL 进行一些处理。这里就列举了三个处理 URL 的方式，灵活度逐渐提高。 直接对 URL 字符串进行修改第一种是马上能够想到的方法，直接将得到的 URL 转成 string 来进行操作，比如添加参数，直接将参数名和参数值写死成 key=value 的形式拼接到原有的 URL 上，这里有两点要注意： 注意格式，需要判断原有的 URL 是否已经带了参数，来决定使用哪个分隔符号 ? 还是 &amp;； // 判断url是否已经有参数 if ([newUrlStr isMatchedByRegex:@"[\\s\\S]+?[\?][\\s\\S]+?"]) &#123; newUrlStr = [NSString stringWithFormat:@"%@&amp;%@", newUrlStr, param];&#125; else &#123; newUrlStr = [NSString stringWithFormat:@"%@?%@", newUrlStr, param];&#125; 需要判断带拼接的参数是否已经在 URL 中存在，如果存在则需要忽略掉； if ([url rangeOfString:paramName].location != NSNotFound)&#123; return;&#125; 同样也有两点不方便： 当遇到相同的参数时需要更新参数值就有些麻烦了，要在字符串中找出目标参数所在的范围然后将其替换； 直接操作字符串容易手抖写错，而且写错不好排查； 将 URL 解析成 dictionary 进行修改将 URL 的参数部分提取出来打散拆分成键值对存进字典中，然后把待拼接的参数也以字典的形式与原有的参数进行比对。最后组成一个新的字典，把里面的键值重组排列成参数字符串拼接到 URL 的 path 后面。这种方法需要注意的是，防止字典写空值，和注意拼接格式。// 1.将原始 query 转化为字典保存NSMutableDictionary *paramsDict = [NSMutableDictionary dictionary];NSArray *paramsString = [url.query componentsSeparatedByString:@"&amp;"];for (NSString *paramStr in paramsString) &#123; NSArray *tempArray = [paramStr componentsSeparatedByString:@"="]; NSString *key = tempArray.firstObject; NSString *value = tempArray.lastObject; [paramsDict setObject:value forKey:key];&#125;// 2.拼接新参数，如果相同参数则更新值，没有相同参数则添加for (NSString *key in newParamsDict.allKeys)&#123; id value = [newParamsDict objectForKey:key]; [paramsDict setObject:key forKey:value];&#125;// 3.将参数字典重组为新的 query __block NSString *newQuery = @"";[paramsDict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; NSString *param = @""; if (newQuery.length == 0) // 第一个参数 &#123; param = [NSString stringWithFormat:@"?%@=%@", [key description], [obj description]]; &#125; else &#123; param = [NSString stringWithFormat:@"&amp;%@=%@", [key description], [obj description]]; &#125; newQuery = [newQuery stringByAppendingString:param];&#125;]; 这种方式比第一种要更加灵活的处理参数的变化，其实系统已经给了我们一种解决方案，简化了上述方式的转化工作，看下一种解决方案。 使用 NSURLComponents 类来组合参数NSURLComponents 是系统用来分解 URL 的一个类，它可以将原始的 URL 参数部分分解成一个参数数组。 NSURLQueryItem 就是这个数组中存储的对象，这个对象的 name 和 value 属性，对应着每个参数的键和值，我们可以通过遍历这个数组来添加和删除参数，最后将修改过后的参数数组重新赋值给 NSURLComponents 生成新的 URL。// 利用URL初始化NSURLComponents *urlComponent = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:NO];// 新的query数组NSMutableArray *newQureyItems = [urlComponent.queryItems mutableCopy];// newParams是待拼接的参数数组for (NSURLQueryItem *itemNew in newParams)&#123; // 是否存在相同参数的标识位 BOOL hasParam = NO; for (NSURLQueryItem *itemOld in urlComponent.queryItems) &#123; if ([itemOld.name isEqualToString:itemNew.name]) &#123; // 如果存在相同的参数则更新 [newQureyItems replaceObjectAtIndex:[newQureyItems indexOfObject:itemOld] withObject:itemNew]; hasParam = YES; break; &#125; &#125; if (!hasParam) &#123; [newQureyItems addObject:itemNew]; &#125;&#125;// 获取到新的queryurlComponent.queryItems = newQureyItems; 这种方式最大的好处就是不用我们自己来解析 URL 和拼参了，系统已经做好了这些繁琐的事情，剩下的只需要我们来修改这些值就可以了。 以上就是三种拼接 URL 参数的方法，在经过性能测试也没有发现很大差距，最大的区别就在与灵活性和易用性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github, Gitcafe和 Coding的Pages服务对比]]></title>
      <url>%2F2015%2F12%2F14%2Fdemonayu%2Fblog%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%9B%BD%E5%86%85%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E7%BD%91%E7%AB%99%2F</url>
      <content type="text"><![CDATA[GitHub/GitCafe/Coding的Pages服务 因为之前博客放在github上, 有时候网络不稳定访问很慢,并且push的时候要等很久,甚至直接push失败, 借昨天放假休息正好可以认真搞一搞博客的部署. 把线路迁移到国内有几个比较流行的代码托管网站,比如gitcafe和coding. gitcafe可以自定义域名,但最近好像不太稳定,在我部署的当天就宕机了,而且到今天数据还不能更新;coding速度很快,一键部署非常方便(运行环境要选择html),但是这个网站默认不支持自定义域名,当然成为付费用户可以选择香港线路来自定义域名,还有在代码上传后需要手动点击一键部署来更新文档, 也可以参照官方的帮助文档设定自动更新Coding 云端演示平台静态网站部署指南. 说说心得: github: 稳定,除了网络抽风push的时候有点慢和国内的搜索引擎可能爬不到,其他完美仍然是首选. gitcafe: 据说服务器在香港,相比github访问速度要快一些,但是最近很不稳定,比如昨天就宕机了很久,导致博客打不开,之后push上去的新内容不能及时更新.不知道是不是我昨天运气不好,等稳定了再说. coding: 速度快,而且界面友好,但是不支持免费自定义域名,需要花钱办会员,对于没有绑定域名需求的朋友还是很推荐的. 最后: 我还是推荐把github作为主站,然后把gitcafe作为镜像用于国内的搜索引擎去收入(使用dnspods把gitcafe.io解析为搜索引擎线路).coding作为备份网站,当前面两个网站打不开的时候救急. 最后的最后, 生命止于折腾.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[升级Xcode后插件失效的解决办法]]></title>
      <url>%2F2015%2F12%2F10%2Fdemonayu%2Fblog%2FXcode%E6%8F%92%E4%BB%B6%E5%A4%B1%E6%95%88%E5%90%8E%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[1.打开终端，输入以下代码获取到DVTPlugInCompatibilityUUID: defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID 2.然后输入如下命令(最后一项是获取到的DVTPlugInCompatibilityUUID): find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add F41BD31E-2683-44B8-AE7F-5F09E919790E]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片折叠小demo]]></title>
      <url>%2F2015%2F12%2F04%2Fdemonayu%2Fblog%2F41.%E5%9B%BE%E7%89%87%E6%8A%98%E5%8F%A0%E5%B0%8Fdemo%2F</url>
      <content type="text"><![CDATA[利用图层特性实现图片折叠的效果#import "ViewController.h"#define imageWH 200.0@interface ViewController ()@property (nonatomic, weak) UIImageView *imageTop;@property (nonatomic, weak) UIImageView *imageBottom;@property (nonatomic, weak) CAGradientLayer *gradient;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor lightGrayColor]; // 初始化图片 [self setupImageView];&#125;/** 初始化图片 */- (void)setupImageView&#123; /* 创建一个透明的蒙版作为手势的接受者 */ UIView *cover = [[UIView alloc] init]; cover.frame = CGRectMake(0, 0, imageWH, imageWH); cover.center = self.view.center; cover.backgroundColor = [UIColor clearColor]; // 添加pan手势 UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)]; [cover addGestureRecognizer:pan]; [self.view addSubview:cover]; /* 添加图片 - 原图片添加两次,分别显示上下部分 */ // 上半部图片 UIImageView *imageTop = [[UIImageView alloc] init]; imageTop.frame = CGRectMake(0, 50, imageWH, imageWH * 0.5); imageTop.image = [UIImage imageNamed:@"知道错了"]; // 修改layer的contentsRect只显示显示图片的上半部 imageTop.layer.contentsRect = CGRectMake(0, 0, 1, 0.5); // 修改锚点Y值为图片的高度 imageTop.layer.anchorPoint = CGPointMake(0.5, 1); _imageTop = imageTop; // 下半部图片 UIImageView *imageBottom = [[UIImageView alloc] init]; imageBottom.frame = CGRectMake(0, 50, imageWH, imageWH * 0.5); imageBottom.image = [UIImage imageNamed:@"知道错了"]; // 修改layer的contentsRect只显示显示图片的下半部 imageBottom.layer.contentsRect = CGRectMake(0, 0.5, 1, 0.5); // 修改锚点Y值为0 imageBottom.layer.anchorPoint = CGPointMake(0.5, 0); _imageBottom = imageBottom; /* 给下半部图片添加阴影效果 */ // 创建一个渐变层用来显示阴影效果 CAGradientLayer *gradient = [CAGradientLayer layer]; _gradient = gradient; // 设置图层的位置 gradient.frame = imageBottom.bounds; // 设置渐变颜色 gradient.colors = @[(id)[UIColor clearColor].CGColor, (id)[UIColor blackColor].CGColor]; // 设置不透明度 gradient.opacity = 0; // 给下半部图片添加图层 [imageBottom.layer addSublayer:gradient]; [cover addSubview:imageBottom]; [cover addSubview:imageTop];&#125;/** 监听pan手势 */- (void)pan:(UIPanGestureRecognizer *)pan&#123; // 获得手指偏移量的Y值 CGFloat offsetY = [pan translationInView:self.view].y; // 将偏移量转成旋转弧度 CGFloat angle = offsetY * M_PI / imageWH; if (angle &gt; M_PI) &#123; angle = M_PI; &#125; // 设置透视效果 - 除数值越大透视效果越不明显(可以理解成眼睛看到物体的距离) CATransform3D transform = CATransform3DIdentity; transform.m34 = -1 / 400.0; // 根据偏移量沿x轴旋转上半部图片 self.imageTop.layer.transform = CATransform3DRotate(transform, -angle, 1, 0, 0); // 给下半部图片添加阴影效果 self.gradient.opacity = offsetY * 1 / imageWH; // 当手指松开的时候将位置返回 if (pan.state == UIGestureRecognizerStateEnded) &#123; // 设置反弹动画 // Duration:动画的执行时长 // delay:延时执行时长 // Damping:弹性系数(越小,弹性越大) // SpringVelocity:初始的弹性系数 [UIView animateWithDuration:1.25 delay:0 usingSpringWithDamping:0.1 initialSpringVelocity:0 options:0 animations:^&#123; // 清空transform self.imageTop.layer.transform = CATransform3DIdentity; // 还原不透明度 self.gradient.opacity = 0; &#125; completion:^(BOOL finished) &#123; &#125;]; &#125;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[调用系统相册的两种方法]]></title>
      <url>%2F2015%2F10%2F08%2Fdemonayu%2Fblog%2F40.%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%86%8C%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[调用系统相册 调用系统相册需要先实例化一个照片选择控制器 // 1. 创建照片选择器UIImagePickerController *picker = [[UIImagePickerController alloc] init];// 2. 设置数据源类型(是相册还是照相机)picker.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum;// 3. 将调用改控制的对象设置为代理 - 这里必须要实现系统要求的两个协议picker.delegate = self;// 4. modal出照片选择控制器[self presentViewController:picker animated:YES completion:nil]; 调用代理方法拿到照片 // info这个字典参数是选中照片的一些信息,根据里面的key可以拿到选择的照片- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info&#123; // 拿到图片 UIImage *image = info[UIImagePickerControllerOriginalImage]; // 将照片选取器隐藏 [self dismissViewControllerAnimated:YES completion:nil];&#125; 往相册里存入照片 调用写入方法 // 将图片保存到用户相册里面// image: 将要保存的图片// target: 方法监听者// SEL: 保存图片完成时调用的方法(系统规定写法,用来监听保存状态)// contextInfo: 上下文信息UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), nil); 实现监听方法 // 保存相册后回调的监听方法- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo&#123; if (error) &#123; NSLog(@"保存失败"); &#125; else &#123; NSLog(@"保存成功"); &#125;&#125; 待续…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS面试题]]></title>
      <url>%2F2015%2F10%2F05%2Fdemonayu%2Fblog%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
      <content type="text"><![CDATA[这是从简书上拷贝下来题目,没事自己做做. 初级 关于单方面技术 ARC / MRC 简单叙述一下ARC和MRC的意思分别是自动引用计数和手动引用计数，它是iOS中内存管理的一种机制。当一个对象被创建和引用时那么它的引用计数器就会+1，当没有这个对象的引用计数为0时这个对象就会被销毁。MRC中有3个关键字来控制引用计数分别是retain/release/autorelease，retain表示计数器+1，release和autorelease表示计数器-1。ARC与MRC对内存管理的原理是一样的，只是具体实现不一样，ARC它是一种编译器特性，在ARC环境下我们不用手动编写retain和release，编译器会自动在适当的地方插入这些方法。ARC它是通过判断有没有强引用来判断对象是否该销毁，它也有3个关键字来控制对象的生命，strong/weak/assign，strong表示强引用，只要有一个强引用引用者该对象，那么这个对象就不会被销毁。 封装过什么控件, 简单叙述一下封装过一些HUD和自定义tabbar， hud就是自定义一个UIView，然后重写view的drewRect: 方法使用cg和ca框架来画出需要的图形。自定义一个tabbar来替换系统自带的tabbar，还有就是自己写一个tabbarViewcontroller来实现完全的自定义。 属性readwrite，readonly，assign，retain，copy，nonatomic各是什么作用以上关键字是用来修饰成员属性的，readwrite表示该成员属性可读可写，意味着编译器会默认生成带下划线的成员变量名和与之对应的setter和getter方法；readonly则表示只读，意味着只会生成带下划线的成员变量和对应的getter方法；assign一般用来修饰基本数据类型；retain一般在MRC环境下使用，它修饰的成员属性在被调用的时候，引用计数器会+1；copy一般用来修饰集合类型，因为集合类型分为可变和不可变类型，如果直接使用retain或strong修饰的话，外界就有可能会改这个集合中的值，导致数据污染，通常做法就是当外界使用这个集合的时候都会进行一次拷贝操作，以保证原始数据的完整性；nonatomic表示非原子性，表示非线程安全的，当有多个线程同时访问和修改一个成员变量时，会出现抢夺资源的情况，导致访问成员变量值出错，而atomic就是给这个成员变量配一把锁，当有一个线程访问这个成员变量时就会得到这把锁，其他线程就不能访问，只有这个线程把这个锁释放后其他线程才能访问，保证数据的安全性。 Get Set方法get 和 set 方法是为了保证对象的封装性而存在的。一般在程序设计时，如果把一个成员变量暴露在外供外界随意调用是一件很危险的事情。所以这时需要对成员变量进行一次封装，让这个成员变量只能在类的内部调用，对外则提供一些特定的接口让外界访问，这用就能有效的过滤外界对成员变量的行为，保证数据的安全性。 id 是什么id可以理解为一个万能指针，它能指向任意一个对象。它是oc多态特征的表现，1.只有当程序运行的时候对象的真实类型才能被确定；2.可以用父类指针指向子类。 代理, Block, 循环引用代理实际上是一种设计模式，一个类有一些方法需要外界来实现的时候就可以使用代理模式，比如tableView的数据源，tableView的代理方法。它的存在主要是为了让类之间解耦，以达到模块化的目的；block其实就是一段代码块，用来保存一段代码，然后让这段代码在合适的时候进行调用。block的本质其实就是一个指向结构体的指针，block保存的代码块则最终会被转成一个函数，然后block指向的结构体会生成一个指向该函数的指针型成员变量，当block被调用的时候实际上就是调用的这段函数；循环引用的意思就是，当两个对象互相强引用着对方时，谁也不能被销毁。代理模式和block都会产生循环引用的问题，所以当一个类声明一个代理属性的时候，需要将那个类修饰为弱引用来防止出现循环引用。在block中也是，当block的调用者在block的回调函数中被引用时就会产生循环引用，解决办法就是，新定义一个弱引用的变量来指向block调用者，在block的回调函数中使用这个弱引用来指代这个调用者。 通知的使用通知的流程就是当一个事件产生时拿到通知中心单例对象，通过这个单例对象post一个事件，这个事件中包含这个通知的标识，通知发送者和一个字典类型的参数，接下来如果有对象要接收这个通知则先需要add一个监听者来监听这个通知的发送在做一些响应操作，最后当通知的监听对象被销毁的时候记得使用remove来移除监听。通知的使用场景一般是，结构层次很深，或互不相干的两个对象需要进行一个事件监听和数据处理。 关于项目方面 参与过什么项目, 负责什么 项目中你参与的模块遇到过什么大的问题, 怎么解决的, 详细叙述 Git/SVN一个是集中式源代码管理工具，一个分布式源代码管理工具，这个没什么好说的。 中级 在基础技术问题的基础上 本地通知和远程通知感觉没什么好说的，本地通知，用来提示本地信息。远程通知是当客户端不在活跃状态时由服务器发送消息给苹果的APNS服务器，然后再根据deviceToken推送给各个设备 简单讲述SDWebImage实现原理直接上代码 - (void)downloadImageWithUrlStr:(NSString *)urlStr placeholder:(NSString *)placeholder completeHandle:(void (^)(UIImage *image))block&#123; // 1&gt; 先从内存缓存中取 // 根据url取出图片 UIImage *memoryImage = self.images[urlStr]; if (memoryImage) &#123; // 当内存中有图片时 block(memoryImage); &#125; else &#123; // 当内存中没有图片时 // 2&gt; 再从沙盒中取 - 每一张图片都是一个文件 文件名为url名 UIImage *diskImage = [UIImage imageWithContentsOfFile:cachePath(urlStr)]; if (diskImage) &#123; // 沙盒中有图片时 block(diskImage); &#125; else &#123; // 当沙盒中没有对应的图片时 // 设置占位图片 block([UIImage imageNamed:placeholder]); // 3&gt; 从网络上下载 /* 为了保证一张图片只下载一次,需要判断当前url是否有下载任务,如果没有才需要创建下载任务 */ /* 如何才能判断当前的url是否有下载任务呢?利用字典一对一绑定来判断 */ // 取出字典中url对应的下载任务 NSBlockOperation *operation = self.operations[urlStr]; // 如果当前url有下载任务 - 就不创建任务 if (!operation) &#123; __weak typeof (self) weakself = self; // 创建异步任务 - 将下载图片的操作放入到子线程中 - 解决异步下载的问题 operation = [NSBlockOperation blockOperationWithBlock:^&#123; // 将字符串转成url NSURL *url = [NSURL URLWithString:urlStr]; // 从url获取数据 NSData *imageData = [NSData dataWithContentsOfURL:url]; // 将二进制数据转成图片 UIImage *image = [UIImage imageWithData:imageData]; // 返回主线程刷新数据 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; // 如果下载成功将图片存入字典 - 字典不能存空 if (image) &#123; block(image); // 1)将下载好的图片添加进图片字典中 url为key [weakself.images setObject:image forKey:urlStr]; // 2)将image写入沙盒 // 将图片转成二进制数据 NSData *data = UIImagePNGRepresentation(image); // 写入沙盒 [data writeToFile:cachePath(urlStr) atomically:YES]; &#125; // 下载完毕后将任务从字典中移除 - 如果下载失败将任务移除后还有机会下载,如果不移除,这个key就会一直存在永远也不能再次下载了 // 在主线程中移除是为了保证下载操作已经执行完毕 [self.operations removeObjectForKey:urlStr]; &#125;]; &#125;]; &#125; // 将任务添加到队列 - 如果当前队列有相同任务则不添加 if (![self.queue.operations containsObject:operation]) &#123; [self.queue addOperation:operation]; &#125; // 将下载任务写入到字典里(解决重复下载问题) [self.operations setObject:operation forKey:urlStr]; &#125; &#125;&#125; 数据库语句列举几个常用的数据库语句： // 创表CREATE TABLE IF NOT EXISTS t_cmpt (id INTEGER PRIMARY KEY, name TEXT, price REAL)// 插入数据INSERT INTO t_cmpt (name, price) VALUES (abc, 998)// 删除数据DELETE FROM t_cmpt// 查询数据SELECT * FROM t_cmpt CoreData常用使用一般用sqlite，没用过CoreData 优化UITableView的方式, 方法 - 对于复杂的视图，使用纯代码来实现布局（storyboard对资源的消耗要大于纯代码）- 使用SDWebImage来异步加载图片, 管理下载队列, 缓存数据- 使用估算高度,来防止tableView一显示就计算所有cell的高度(延迟调用heightForRow)- 在不等高cell中,使用字典来保存已经计算高度的cell,在下次滑动到这个cell的时候优先调用字典里的cellHeight, 最好的办法是在数据返回的时候就根据数据来计算出cell的高度并缓存起来- 调用scrollView的代理方法,在滑动tableView的时候就停止所有的网络请求(比如图片下载)- 在cell已经离开显示区域后从内存中清除cell,特别是带大量图片的复杂的cell, 防止内存占用过多导致程序崩溃- 在cell中使用高清大图时尽量使用fileFormPath来加载图片而不是使用imageName: 前者是一次性显示,当从可显示区域移除后就会自动从内存中销毁, 而后者只有内存警告的时候才会被回收- 在对象销毁的时候将所有的代理清空- 尽量让所有的view不透明(opaque), 因为透明会额外消耗性能- 尽量不要动态给cell添加子控件(意思就是不要在cellForRow中添加子控件)- 不需要交互的内容不使用系统封装好的控件来显示，而是调用独立功能的API来在图层上绘制，比如cell中的图片只需要显示，而不需要交互，则可以考虑自定义图层来绘制出这个图片，还有文字使用更底层的CoreText来绘制文字而不是使用label- 根据滑动的位置异步按需加载内容(比如提前加载当前显示cell附近cell的内容)- 使用第三方框架的tableView(异步渲染UI)，比如AsyncDisplayKit框架 深浅拷贝 浅复制（浅拷贝，指针拷贝，shallow copy）- 源对象和副本对象是同一个对象- 源对象（副本对象）引用计数器+1,相当于做一次retain操作- 本质是：没有产生新的对象- 原对象引用计数器+1- 必须对原对象进行释放深复制（深拷贝，内容拷贝，deep copy）- 源对象和副本对象是不同的两个对象- 源对象引用计数器不变,副本对象计数器为1（因为是新产生的）- 本质是：产生了新的对象- 必须释放新对象 运行时你知道多少（是什么？有哪些用处？）运行时是一套纯c语言的函数库，它是支撑整个OC动态特性的幕后工作者，在OC环境下所编写的代码在编译的时候都会先转换成纯c的运行时代码然后在再编译成二进制的机器语言。使用运行时可以办到一些OC办不到的事情，比如获取类中的私有成员变量，动态添加方法，动态添加成员属性，动态添加一个类（KVO），Method Swizzle，实现消息转发等。 封装过什么封装过一些工具类，视图类，模型缓存类等 关于项目方面 熟练的使用Git 如果让你设计一个缓存模块, 你会怎么设计,需要考虑到什么 每次获取数据优先从内存中获取，如果没有再查找本地数据库和文件，如果没有则发送网络请求，从服务区加载数据，然后将获得的数据进行本地缓存。数据库缓存方面注意点：1.首先考虑到的是线程安全，因为在iOS中sqlite不支持多线程并发访问，会引起数据库锁定，所以在访问数据库的时候都是以同步串行的方式进行访问的；2.添加文件校验，将文件名和文件数据进行关联，防止文件多次下载；3.防止文件名冲突，比如像SDWebImage对下载下来的文件名进行MD5加密，防止文件被覆盖； 说说MVC MVVM MVPMVP是MVC的衍生版，真正做到了模型与视图的隔离，每次视图需要获取数据必须要通过Presenter，当然这又产生一个问题，就是Presenter的体积会越来越庞大，不便于后期的维护。MVVM则更像MVC的改良版，它将控制器中对数据的处理全部抽到了一个视图模型中，减小了控制器的体积，同时也办到了视图与模型的隔离。 做过最失败的项目是什么, 为什么 你觉得怎么划分模块会好一点我觉得按功能划分最好啦~ 高级 基于前两个 多线程详细说一下, 怎么封装一个适合自己项目的线程池,怎么处理会好一点。 多线程CoreData, 这个基本所有的面试都会提到一下吧 使用过什么开源的动画库, 这就是随便问问 比如pop, canvas等 有自己的开源项目么？ 有全面的对网络库进行二次开发封装么, 怎么干的。 讲一下运行时调换系统方法swizzle的原理 自己尝试着模拟系统Block的实现 怎么理解界面模板, 有做过相关开发么 IM的东西随便问问，如果公司需要 内存优化怎么搞一下见tableView的优化思路 自己写个tableView玩玩？ 项目方面 参与过什么项目, 做过什么大型的项目, 负责哪些模块 框架的设计有没有参与, 如果有的话, 参与了框架中哪一部分的工作, 怎么考虑你这部分未来的可扩展性的。 在项目中严格按照产品,UIUE的思维去做,还是会把自己的想法提出来。 怎么为一个项目写一套完整的网络库, 缓存库, 界面库。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIAlertView在iOS9中的使用]]></title>
      <url>%2F2015%2F09%2F20%2Fdemonayu%2Fblog%2F39.UIAlertView%E5%9C%A8IOS9%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[iOS9中改变了UIAlertView的使用方式, 并且与UIActionSheet融合进了一个类里面,统一进行管理. // 注销- (void)loginOut&#123; // 1.创建一个alertController来管理警示窗口, 并指定样式 UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"确定注销吗?" message:nil preferredStyle:UIAlertControllerStyleActionSheet]; // 2.创建点击行为, 在block中实现事件 UIAlertAction *action = [UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDestructive handler:^(UIAlertAction * _Nonnull action) &#123; [self.navigationController popViewControllerAnimated:YES]; NSLog(@"已注销"); &#125;]; UIAlertAction *cancel = [UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; NSLog(@"取消注销"); &#125;]; // 3.为alertController添加点击行为 [alertController addAction:action]; [alertController addAction:cancel]; // 4.弹出警示窗口 [self presentViewController:alertController animated:YES completion:nil];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Runtime黑魔法]]></title>
      <url>%2F2015%2F09%2F18%2Fdemonayu%2Fblog%2F38.Runtime%E9%BB%91%E9%AD%94%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Runtime消息机制之前写过一篇短文: 利用运行时特性获取系统类的私有成员属性.通过运行时特性获得私有的成员变量target, 然后为target重新指定手势方法来达到全屏都能接收到滑动返回的事件. 如果要搞清楚为什么能这样做首先得明白OC的运行时机制,看下面代码: UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)]; 这行代码的意思就是:使用UIPanGestureRecognizer类来实例化了一个名为pan的实例对象,并为这个对象指定了手势的监听对象(假设是控制器)和监听方法. 其实这只是我们看到的表面,实际上OC所有的方法调用本质上还是函数的调用. 大概了解一下什么是runtime: Runtime顾名思义就是运行时的意思.在运行的时候才会调用需要实现的函数. OC是一门动态的语言,相对于C语言来讲,OC方法的调用是在程序运行的时候才决定的.也就是说只有方法的声明没有方法的实现照样也能编译通过.这样就需要一个运行时系统 (runtime system) 来执行编译后的代码. 运行时中的消息机制: 每一个方法的调用实际上就是向对象发送了一条消息让其执行SEL指向的方法实现(IMP); 上面的代码可以使用runtime函数改写: 导入头文件,在项目设置中将enable strict checking of objcmsgsend calls改成NO #import &lt;objc/message.h&gt; 改写方法为消息函数 UIPanGestureRecognizer *pan = objc_msgSend(objc_msgSend (objc_getClass("UIPanGestureRecognizer"), sel_registerName("alloc")), sel_registerName("initWithTarget:action:"), self, sel_registerName("pan:")); 解释: objc_msgSend就是消息函数.objc_getClass将字符串转化成类名, sel_registerName 将字符串注册成一个方法标识.后面的self和sel_registerName(&quot;pan:&quot;)则相当于消息的参数. 这句话翻译过来就是,系统向UIPanGestureRecognizer这个类对象发送了一条消息,让它去执行参数alloc所指向的方法实现,返回一个实例对象, 再发送一条消息让返回的实例对象去执行initWithTarget:action:这个方法,并且同时传入了两个参数. 分析消息函数:objc_msgSend(id self, SEL op, ...); 每一个消息函数都需要至少传入两个参数, 一个是消息的接收者(target), 一个方法代号(SEL). 这个两个参数被称为隐式参数.如果你用过NSInvocation那么你就会明白为什么调用[invocation setArgument:&amp;param1 atIndex:2];传入参数的时候索引要从2开始. 系统在向一个对象发送消息并不意味着会被马上执行.如果消息的接收者能够找到对应的selector,那么就相当于直接执行了接收者这个对象的特定方法;否则,消息被转发,或是临时向接收者动态添加这个selector对应的实现内容(动态方法解析),如果都没有则程序崩溃. 消息发送的步骤: 检测这个selector是不是要忽略的; 检测这个target是不是nil对象; 如果上面两关都过了则开始查找类中的cache中的IMP, 如果能找到这执行函数,如果不能在去映射表中查找; 如果当前类中映射表中查不到,则向上沿着父类的映射表查找,一直找到根类; 如果仍然没有找到则开始动态方法解析和消息转发. Class 在OC中类本身也是一个对象,为了处理类和对象的关系,runtime库创建了一种叫做元类 (Meta Class) 的东西,类对象所属类型就叫做元类,它用来表述类对象本身所具备的元数据.类方法就定义于此处,因为这些方法可以理解成类对象的实例方法.每个类仅有一个类对象,而每个类对象仅有一个与之相关的元类.当发出一个类似[NSObject alloc]的消息时,事实上是把这个消息发给了一个类对象 (Class Object),这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class)的实例.所有的元类最终都指向根元类为其超类.所有的元类的方法列表都有能够响应消息的类方法.所以当[NSObject alloc]这条消息发给类对象的时候,objc_msgSend()会去它的元类里面去查找能够响应消息的方法,如果找到了,然后对这个类对象执行方法调用. SEL 方法的selector用于表示运行时方法的名字.OC在编译时,会依据每一个方法的名字,参数序列,生成一个唯一的整型标识(Int类型的地址),这个标识就是SEL; SEL类型代表着方法的签名,在类对象的方法列表中存储着该签名与方法代码的对应关系; 每一个方法都对应着一个SEL.所以在同一个类(及类的继承体系)中,不能存在2个同名的方法,即使参数类型不同也不行.相同的方法只能对应一个SEL。 本质上,SEL只是一个指向方法的指针(准确的说,只是一个根据方法名hash化了的KEY值,能唯一代表一个方法),它的存在只是为了加快方法的查询速度,最终指向方法的实现. 运行时有三种方式获得SEL sel_registerName函数 编译器提供的@selector() NSSelectorFromString()方法 IMP IMP实际上是一个函数指针,指向方法实现的首地址.可以理解成它就是实现方法的一个入口,连接着代码区的方法实现代码.取得IMP后我们就可以像调用普通的C语言函数一样来使用这个函数指针了. 通过取得IMP,我们可以跳过Runtime的消息传递机制,直接执行IMP指向的函数实现,这样省去了Runtime消息传递过程中所做的一系列查找操作,会比直接向对象发送消息高效一些. 直接获取方法地址: methodForSelector:. Method Method的定义 typedef struct objc_method *Method;struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; // 方法名 char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE; // 方法实现&#125; 我们可以看到该结构体中包含一个SEL和IMP,实际上相当于在SEL和IMP之间作了一个映射.有了SEL,我们便可以找到对应的IMP,从而调用方法的实现代码. Cache Cache为方法调用的性能进行优化,通俗地讲,每当实例对象接收到一个消息时,它不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法,因为这样效率太低了,而是优先在Cache中查找.Runtime系统会把被调用的方法存到Cache中(理论上讲一个方法如果被调用，那么它有可能今后还会被调用),下次查找的时候效率更高. Runtime几个常见的用法获取成员和方法列表 在Runtime面前没有私有变量,使用私有变量调用自定义方法. // 用来记录成员变量个数unsigned int ivarCount = 0;// 取出所有的成员变量Ivar *ivars = class_copyIvarList([UIPageControl class], &amp;ivarCount);// 遍历所有的成员变量for (int i = 0; i &lt; ivarCount; i++) &#123; // 打印变量名 NSLog(@"%s", ivar_getName(ivars[i]));&#125;NSLog(@"----------分割线-----------");// 记录成员属性个数unsigned int propertyCount = 0;// 取出所有的成员属性objc_property_t *propertise = class_copyPropertyList([UIPageControl class], &amp;propertyCount);// 遍历成员属性列表for (int i = 0; i &lt; propertyCount; i++) &#123; // 打印属性名 NSLog(@"%s", property_getName(propertise[i]));&#125; 获取方法列表:调用私有方法成为可能 // 取出方法列表unsigned int outcount = 0;Method *methods = class_copyMethodList([UIPageControl class], &amp;outcount);// 遍历方法列表for (int i = 0; i &lt; outcount; i++) &#123; SEL action = method_getName(methods[i]); // 打印所有方法(包括私有) NSLog(@"%@", NSStringFromSelector(action));&#125;// 调用私有方法, UIPageControl默认是不能设置图片的, 通过调用这个私有方法可以设置指示器图片[[UIPageControl new] performSelector:@selector(_pageIndicatorImageForPage:) withObject:[UIImage imageNamed:@"image"]]; 三种方式调用私有方法 performSelector: – 优点:方便; 缺点:最多只能传2个参数 [[XVPerson new] performSelector:@selector(eat:drink:play:) withObject:@"hamburger" withObject:@"coke"]; ps: 让selector调用的方法接受的参数类型为Dictionary类型可以间接实现多参数传递. NSInvocation – 优点:可以传多个参数; 缺点:调用麻烦,代码较多 // 初始化一个方法签名SEL myMethod = @selector(eat:drink:play:);NSMethodSignature *signature = [[XVPerson class] instanceMethodSignatureForSelector:myMethod];// 初始化一个NSInvocation对象NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];// 要执行的方法[invocation setSelector:myMethod];// 注: 这里的index为什么要从2开始? 因为每一个OC方法的本质就是一个至少带有两个参数(self,_cmd)的普通C函数// 这两个参数在这里所对应的就是Target和Selector, 这两个参数已经将0 和 1 的位置给占了.所以其他参数要从 2 开始.NSString *param1 = @"hamburger";NSString *param2 = @"coke";NSString *param3 = @"hockey";[invocation setArgument:&amp;param1 atIndex:2];[invocation setArgument:&amp;param2 atIndex:3];[invocation setArgument:&amp;param3 atIndex:4];// 调用方法 并指定调用谁的方法[invocation invokeWithTarget:[XVPerson new]]; Runtime – 优点:代码简单,能传多参数 缺点:要导入头文件 objc_msgSend([XVPerson new], sel_registerName("eat:drink:play:"), @"hamburger", @"coke", @"hockey"); 交换方法 目标: 当系统找不到方法的时候会调用doesNotRecognizeSelector:来抛出崩溃详情. 要求通过添加分类来实现改写这个系统方法.本质上就是一种消息转发机制. 思路: 利用Runtime在程序抛出错误时添加一行打印, 通过交换方法可以在不影响错误打印的同时在程序退出时做一些事情. 为NSObject添加一个分类,并导入头文件 NSObject (Extension)#import &lt;objc/message.h&gt; 定义一个自定义方法 - (void)xv_doesNotRecognizeSelector:(SEL)aSelector&#123; NSLog(@"因为找不到%@方法,程序即将崩溃!", NSStringFromSelector(aSelector)); NSLog(@"====================================="); // 这个时候实现这个方法并不会死循环, 因为实际上执行的是doesNotRecognizeSelector: [self xv_doesNotRecognizeSelector:aSelector];&#125; 与系统方法进行交换 // 在类加载的时候就进行交换 + (void)load&#123; // 获取当前类中的对象方法 Method method1 = class_getInstanceMethod(self, @selector(doesNotRecognizeSelector:)); Method method2 = class_getInstanceMethod(self, @selector(xv_doesNotRecognizeSelector:)); // 交换方法 method_exchangeImplementations(method1, method2);&#125; 动态方法解析 使用场景: 用到该方法时再加载该方法; 思路: 当对象调用一个未实现的方法时, 系统就会调用下面这个方法,本质上就消息转发 // 系统调用这个方法的意思就是,给个机会让类添加这个未实现的方法 + (BOOL)resolveInstanceMethod:(SEL)sel; 假如person这个对象要调用未实现的方法eat:drink:play:, 具体步骤: 当前类重写resolveInstanceMethod: + (BOOL)resolveInstanceMethod:(SEL)sel&#123; // 当传进来的sel是未实现的sel时 if (sel == NSSelectorFromString(@"eat:drink:play:")) &#123; // 参数1: 需要添加方法的类 // 参数2: 传进来的方法名称 // 参数3: 需要添加的方法实现 // 参数4: "v@:@@@" 这个方法的参数描述 -- v表示空值, @表示对象, :表示方法(SEL) // 对应函数 void myMethodIMP(id self, SEL _cmd, NSString *eat, NSString *drink, NSString *play) 的5个参数类型 // 给类动态添加一个方法来救命 class_addMethod(self, sel, (IMP)myMethodIMP, "v@:@@@"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125; 添加的方法实现 // 每一个OC方法的本质其实就是一个至少带有两个参数（self,_cmd）的普通C函数void myMethodIMP(id self, SEL _cmd, NSString *eat, NSString *drink, NSString *play) &#123; NSLog(@"eat: %@, drink: %@, play:%@", eat, drink, play); NSLog(@"%@--%@", self, NSStringFromSelector(_cmd));&#125; 动态添加成员属性 需求: 为根类NSObject添加属性,不准使用继承; 思路: 如果要扩展某个系统类,不使用继承就只有使用分类了,但是在分类中使用property只会生成setter和getter方法并不会生成成员变量. 实现步骤: 在分类的.h文件中添加属性接口 // 因为只会生成setter和getter方法,写上修饰属性的关键字没有意义(nonatomic, strong)@property NSString *myProperty; 在分类的.m文件中实现setter和getter方法 // setter方法 - (void)setMyProperty:(NSString *)myProperty&#123; // 添加成员属性 // 参数1: 给那个对象添加成员属性 // 参数2: 添加的成员属性名 // 参数3: 添加的成员属性值 // 参数4: 属性策略 - RETAIN_NONATOMIC ==&gt; (nonatomic, strong) objc_setAssociatedObject(self, "property", myProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;// getter方法 - (NSString *)myProperty&#123; // 返回成员属性 return objc_getAssociatedObject(self, "property");&#125; MJExtension框架中字典转模型的原理 一句话概括: 利用运行时获取对象中所有成员变量, 然后将成员变量名与字典中的key名进行比对,将比对成功的成员变量进行赋值. 思路: 为基类添加一个分类, 让所有的类都能调用这个方法. 要注意的细节: 如果字典中嵌套字典; 如果字典中嵌套字典数组; 具体实现的代码: // 默认返回nil, 有数组字典需要转成模型时需要在外部重写这个方法+ (NSDictionary *)arrayContentModelClass&#123; return nil;&#125;// 传入一个字典将其转成模型+ (instancetype)objectWithDict:(NSDictionary *)dict&#123; // 创建一个id对象 id objc = [[self alloc] init]; // 遍历类中所有的成员变量 unsigned int ivarCount = 0; Ivar *ivarList = class_copyIvarList(self, &amp;ivarCount); for (int i = 0; i &lt; ivarCount; i++) &#123; // 取出成员变量 Ivar ivar = ivarList[i]; // 取出成员的类型名称字符串 @"@\"classname\"" NSString *classname = @(ivar_getTypeEncoding(ivar)); // 截取出类型名字 classname = [classname stringByReplacingOccurrencesOfString:@"\"" withString:@""]; classname = [classname stringByReplacingOccurrencesOfString:@"@" withString:@""]; // 截取出所有成员变量的名称 NSString *ivarName = [@(ivar_getName(ivar)) substringFromIndex:1]; // 拿到属性名与字典的key名一样的值, 如果字典中找不到跟key名一样的属性名那么value为nil id value = dict[ivarName]; /* 二级转换 - 当value为字典时 */ // 当值的类型是字典并且是自定义类型的时候, 取出类名, 再转一次 if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![classname hasPrefix:@"NS"]) &#123; value = [NSClassFromString(classname) objectWithDict:value]; &#125; /* 三级转换 - 当value为字典数组时 */ // 问题: 将数组中的字典转成哪个类? if ([value isKindOfClass:[NSArray class]]) &#123; // 当一个数组字典想要转成一个模型时,必须要实现这个方法: arrayContentModelClass // 如果不做判断, 那么在数据源中有数组的而没有实现这个方法的话就会报找不到方法的错 if ([self arrayContentModelClass] != nil) &#123; // key:数组名 ; value:模型类名 NSDictionary *classDict = [self arrayContentModelClass]; NSArray *array = value; NSMutableArray *arrM = [NSMutableArray array]; // 遍历数组 for (NSDictionary *dict in array) &#123; // 根据当前成员变量名取出来的值就是类名字符串, 再将字符串转成类 id tempValue = [NSClassFromString(classDict[ivarName]) objectWithDict:dict]; // 当类名写错时 对象会没有值, 数组中不能添加nil, 所以要做这个容错处理 if (tempValue == nil) &#123; arrM = value; NSLog(@"创建模型失败, 找不到类..."); continue; &#125; else &#123; [arrM addObject:tempValue]; &#125; &#125; value = [NSArray arrayWithArray:arrM]; &#125; &#125; // 当value有值时才进行赋值 if (value) &#123; // 利用kvc赋值 [objc setValue:value forKey:ivarName]; &#125; &#125; return objc;&#125; 有数组字典时,在模型类中重写 // 说明将要把数组里面的字典转成哪个模型+ (NSDictionary *)arrayContentModelClass&#123; // 将哪个数组中的字典元素转成哪个类 return @&#123; @"pic_urls" : @"XVPicURL" &#125;;&#125; 利用消息转发给程序三次起死回生的机会 在程序运行时如果找不到实现方法,系统会给程序几次机会来使能够程序正常运行,实在没出路了才会抛出异常. 三次补救机会 动态方法解析,resolveInstanceMethod 给类一个动态添加方法的机会,前面已经提及. 快速消息转发,forwardingTargetForSelector:将SEL转给其他对象实现的机会; 标准消息转发,methodSignatureForSelector:(函数符号制造器)让重载方有机会抛出一个函数的签名,再由forwardInvocation:(函数执行器)去执行这个函数. 具体流程参考: Objective-C 的“多继承” self与super 看过一个题目是这样的: 问打印结果是什么? @implementation Son : Father- (id)init&#123; self = [super init]; if (self) &#123; NSLog(@"%@", NSStringFromClass([self class])); NSLog(@"%@", NSStringFromClass([super class])); &#125; return self;&#125;@end 答案: 都输出 Son. 本质上super是一个编译指示器, 它并不是一个指针, 它仅仅是表示调用父类的方法,但是调用者仍然是当前对象,跟父类没有关系.也就是说上面的例子不管调用[self class]还是[super class],接受消息的对象都是当前Son这个对象. 当使用self调用方法时,会从当前类的方法列表中开始找,如果没有,就从父类中再找;而当使用super时,则从父类的方法列表中开始找.然后调用父类的这个方法. [super superClass]等价于[self superClass]表示获取当前方法调用者的父类. 参考: Objective-C Runtime Programming Guide 理解 Objective-C Runtime Objective-C Runtime 拓展阅读: 刨根问底Objective－C Runtime 深入理解Objective-C：Category]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RunLoop基础知识]]></title>
      <url>%2F2015%2F09%2F13%2Fdemonayu%2Fblog%2F37.RunLoop%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[什么是RunLoop RunLoop: 运行循环, 顾名思义就是跑圈, 兜圈子的意思. 一个应用程序能够一直运行而不会退出就是基于这种机制. 基本作用: 保持程序持续运行, 相当于一个死循环; 处理应用程序中的各种事件, 比如触摸事件, 定时器事件等; 它的作用机制是有就做事, 没事就待命休息, 节省资源; 主RunLoop: 当程序一启动系统就会在main函数中调用UIApplicationMain()这个函数, 该函数会在程序的主线程中开启一个RunLoop一直保持程序的运行. 自动释放池什么时候创建和释放? 第一次创建,是在RunLoop进入的时候创建,对应的状态 = kCRunLoopEntry 最后一释放,是在RunLoop时候,对应的状态 = kCFRuRunLoopExit 它创建和释放,每次睡觉的时候都会释放前自动释放池,然后再建一个新的. RunLoop对象 在iOS开发中有两套api访问RunLoop Foundation框架NSRunLoop Core Foundation框架CFRunLoopRef 这个两个框架中所代表RunLoop是等价的. NSRunLoop基于CFRunLoopRef的一层OC封装. RunLoop与线程 每一个线程都有一个与之对应的RunLoop对象. RunLoop生命周期与子线程息息相关,当子线程被销毁时,与之对应的RunLoop也会被销毁. 子线程的RunLoop要程序员手动开启. 获取RunLoop对象: // 1. 获当前的RunLoop对象// NSRunLoopNSRunLoop *runLoop1 = [NSRunLoop currentRunLoop];// CFRunLoopRefCFRunLoopRef runLoop2 = CFRunLoopGetCurrent();// 2. 拿到当前应用程序的主RunLoop(主线程RunLoop)NSRunLoop *mainRunLoop = [NSRunLoop mainRunLoop];CFRunLoopRef mainRunLoop = CFRunLoopGetMain(); 在子线程中如果不主动获取RunLoop的话,那么在子线程内部是不会主动创建RunLoop的. 在子线程中创建一个RunLoop对象不是通过alloc init方法创建,而是直接调用currentRunLoop方法,而且这个方法本身就是一个懒加载,所以在该线程中RunLoop对象只会被创建一次. RunLoop对象是利用字典以当前的线程作为key来进行储存的. RunLoop相关类 RunLoop的运行原理 Core Foundation关于RunLoop的五个类 CFRunLoopRef (RunLoop抽象类) CFRunLoopModeRef (RunLoop的运行模式) CFRunLoopSourceRef (RunLoop要处理的事件源) CFRunLoopTimerRef (Timer事件) CFRunLoopObserverRef (RunLoop的观察者/监听者) RunLoop和相关类之间的关系图 RunLoop的运行模式 每一个RunLoop运行必须要指定一个模式,而且必须要有source和timer,如果子线程的NSRunLoop没有设置source和timer,那么子线程的RunLoop会立刻关闭. 一个RunLoop可以有多个模式,一个模式可以有多个source\observer\timer. 如果需要切换mode,只能先退出当前RunLoop,再重新指定一个模式. 系统默认提供了5个模式: kCFRunLoopDefaultMode: App的默认Mode,通常主线程是在这个Mode下运行,与NSDefaultRunLoopMode等价; UITrackingRunLoopMode: 界面跟踪Mode, 用于ScrollView追踪触摸滑动, 保证界面滑动时不受其他Mode影响; UIInitializationRunLoopMode: 在刚启动App时第进入的第一个Mode, 启动完成后就不再使用; GSEventReceiveRunLoopMode: 接受系统事件的内部Mode, 通常用不到; kCFRunLoopCommonModes: 这是一个占位用的Mode,不是一种真正的Mode. CFRunLoopTimerRef 时间源 CFRunLoopTimerRef: 它是基于时间的触发器约等于NSTimer, 说直白点那就是时间到了就触发一个事件, 执行一个操作. 一个mode里面可以添加多个NSTimer,也就是说以后创建NSTimer的时候,可以指定它是在什么模式下运行,从侧面说明了 NSTimer就是CFRunLoopTimerRef. 在主线程中使用定时器 // 1.创建定时器NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(task) userInfo:nil repeats:YES];// 2.1 把定时器添加到runLoop,选择默认运行模式(只有当runLoop处于默认模式时,定时器才工作)[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];// 2.2 把定时器添加到runLoop,选择界面跟踪模式(只有当runLoop处于界面跟踪模式时,定时器才工作)[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];// 2.3 把定时器添加被标记的RunLoop(意味着当前的定时器会被添加到所有被标记为Common Modes的运行模式下面)[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 在子线程中使用定时器 //1.创建子线程RunLoopNSRunLoop *currentRunLoop = [NSRunLoop currentRunLoop];//2.创建定时器对象,会把当前的定时器对象自动添加到runLoop,并设定为默认模式NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(task) userInfo:nil repeats:YES];//3.子线程对应的runLoop需要手动开启[currentRunLoop run]; GCD中的定时器(注：GCD的定时器跟runloop没有什么关系，它们是两套系统) // 1.创建GCD定时器对象 // 第一个参数:source的类型DISPATCH_SOURCE_TYPE_TIMER 定时器 // 第二个参数:描述信息 传递0 // 第三个参数:详细的描述 传递0 // 第四个参数:队列,决定定时器调用的方法在哪个线程执行 dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue()); // 2.设定时器(开始时间|间隔时间|精准度) // 第一个参数:imer 定时器对象 // 第二个参数:开始计时的时间:DISPATCH_TIME_NOW --从现在开始 // 第三个参数:间隔时间 2.0 // 第四个参数:精准度 如果要求对准确的话,传0(误差) // GCD时间单位:纳秒 dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC, 0 * NSEC_PER_SEC); // 3.定时器要执行的操作dispatch_source_set_event_handler(timer, ^&#123; NSLog(@"download ----%@",[NSThread currentThread]); &#125;); // 4.恢复 (启动执行) dispatch_resume(timer); // GCD定时器补充 - source的类型 // DISPATCH_SOURCE_TYPE_TIMER 定时响应（定时器事件） // DIPATCH_SOURCE_TYPE_SIGNAL 接收到UNIX信号时响应 // DISPATCH_SOURE_TYPE_READ IO操作，如对文件的操作、socket操作的读响应 // DISPATCH_SOURCE_TYPE_WRITE IO操作，如对文件的操作、socket操作的写响应 // DISPATCH_SOURCE_TYPE_VNODE 文件状态监听，文件被删除、移动、重命名 // DISPATCH_SOURCE_TYPE_PROC 进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号 // 下面两个都属于Mach相关事件响应 // DISPATCH_SOURCE_TYPE_MACH_SEND // DISPATCH_SOURCE_TYPE_MACH_RECV // 下面两个都属于自定义的事件，并且也是有自己来触发 // DISPATCH_SOURCE_TYPE_DATA_ADD // DISPATCH_SOURCE_TYPE_DATA_OR CFRunLoopSourceRef 事件源 事件源也就是输入源,可能包括用户输入设备(如点击button),网络链接(socket收到数据),定期或时间延迟事件(NSTimer),还有异步回调(NSURLConnection的异步请求). 有两种分类模式: 一种是按照苹果官方文档进行划分 Port-Based Sources Custom Input Sources Cocoa Perform Selector Sources 一种是基于函数的调用栈来进行划分(source0和source1) Source1: 基于端口(port)的输入源(系统内部调用, 比如线程间通信). 它只包含了一个回调(函数指针), 并不能主动触发事件. 使用时你需要先调用CFRunLoopSourceSignal(source), 将这个Source标记为待处理, 然后手动调用CFRunLoopWakeUp(runloop) 来唤醒RunLoop, 让其处理这个事件. Source0: 基于非端口的输入源 (主动触发, 比如用户的交互). 包含了一个mach_port和一个回调(函数指针), 被用于通过内核和其他线程相互发送消息. 这种Source能主动唤醒RunLoop的线程. 添加输入源[performSelector:OnThread]. Cocoa提供了可以在任一线程执行函数[perform selector]的输入源, 和基于端口的源不同的是, [perform selector]执行完后会自动清除出RunLoop. // 发送消息给主线程并且是否等待任务执行完成(下面一个方法是指定RunLoop模式)performSelectorOnMainThread:withObject:waitUntilDone: performSelectorOnMainThread:withObject:waitUntilDone:modes:// 发送消息给指定的线程并且是否等待任务执行完成performSelector:onThread:withObject:waitUntilDone: performSelector:onThread:withObject:waitUntilDone:modes:// 发送消息给主线程延迟调用方法performSelector:withObject:afterDelay:performSelector:withObject:afterDelay:inModes:// 取消当前线程的消息发送cancelPreviousPerformRequestsWithTarget: cancelPreviousPerformRequestsWithTarget:selector:object: 当调用NSObject的performSelecter:afterDelay:后, 实际上其内部会创建一个Timer并添加到当前线程的RunLoop中. 所以如果当前线程没有开启RunLoop, 这个方法则会失效. 当调用performSelector:onThread:时, 实际上其会创建一个Timer加到对应的线程去, 同样的如果对应线程没有开启RunLoop该方法也会失效. CFRunLoopObserverRef 观察者 CFRunLoopObserverRef是观察者,能够监听RunLoop的状态改变 如何监听 // 1.创建观察者// 第一个参数:分配空间// 第二个参数:要监听的状态// 第三个参数:YES 持续监听// 第四个参数:和优先级相关 总是传递0// 第五个参数:当发现runLoop状态改变的时候就会调用该blockCFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; switch (activity) &#123; case kCFRunLoopEntry: NSLog(@"启动runLoop"); break; case kCFRunLoopBeforeTimers: NSLog(@"即将处理定时器事件"); break; case kCFRunLoopBeforeSources: NSLog(@"即将处理source事件"); break; case kCFRunLoopBeforeWaiting: NSLog(@"即将休眠"); break; case kCFRunLoopAfterWaiting: NSLog(@"刚从休眠中唤醒"); break; case kCFRunLoopExit: NSLog(@"runLoop退出"); break; default: break; &#125;&#125;);// 2.给runLoop添加观察者// 第一个参数:runLoop对象// 第二个参数:观察者对象// 第三个参数:运行模式(要监听那种模式下状态的改变)CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);// 3.开启定时器[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(demo) userInfo:nil repeats:YES]; RunLoop运行逻辑详情 补充 从上图可以看出: 如果是事件到达,消息会被传递给相应的处理程序来处理,runLoop处理完当次事件后,runLoop会退出,而不管之前预定的时间到了没有.你可以重新启动runLoop来等待下一事件. 如果线程中有需要处理的源,但是响应的事件没有到来的时候,线程就会休眠等待相应事件的发生.这就是为什么runLoop可以做到让线程有工作的时候忙于工作,而没工作的时候处于休眠状态. 什么时候使用runLoop: 仅当在为你的程序创建辅助线程的时候,你才需要显式运行一个run loop.RunLoop是程序主线程基础设施的关键部分.所以,Cocoa和Carbon程序提供了代码运行主程序的循环并自动启动runLoop.iOS程序中UIApplication的run方法作为程序启动步骤的一部分,它在程序正常启动的时候就会启动程序的主循环.类似的,RunApplicationEventLoop函数为Carbon程序启动主循环.如果你使用xcode提供的模板创建你的程序,那你永远不需要自己去显式的调用这些例程. 对于辅助线程,你需要判断一个runLoop是否是必须的.如果是必须的,那么你要自己配置并启动它.你不需要在任何情况下都去启动一个线程的runLoop.比如.你使用线程来处理一个预先定义的长时间运行的任务时,你应该避免启动runLoop.RunLoop在你要和线程有更多的交互时才需要,比如以下情况: 使用端口或自定义输入源来和其他线程通信 使用线程的定时器 Cocoa中使用任何performSelector…的方法 使线程周期性工作. AFNetWorking 这个框架就是这么干的, 当第一次创建一个manager单例时, 它就会开辟一个子线程同时开启一个runloop, 然后手动维护这个runloop, 来持续监听事件的接收. 参考: 深入理解RunLoop]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[封装NavigationController基类]]></title>
      <url>%2F2015%2F08%2F06%2Fdemonayu%2Fblog%2F36.%E5%B0%81%E8%A3%85NavigationController%E5%9F%BA%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[目前绝大多数应用的各个子控制器的NavigationBar都是是统一风格的,封装Nav一劳永逸. 第一步 // 在第一次使用这个类的时候初始化成员属性+ (void)initialize&#123; // 1. 获取所有导航控制器的bar实例 UINavigationBar *navbar = [UINavigationBar appearance]; // 1.1 设置导航条字体 NSMutableDictionary *dict = [NSMutableDictionary dictionary]; dict[NSFontAttributeName] = [UIFont boldSystemFontOfSize:17]; [navbar setTitleTextAttributes:dict]; // 1.2 设置导航条背景图片 [navbar setBackgroundImage:[UIImage imageNamed:@"navigationbar_background_landscape"] forBarMetrics:UIBarMetricsDefault]; // 1.3 设置导航栏分割线为透明 [navbar setShadowImage:[[UIImage alloc] init]]; // 2. 获取所有导航控制器的item实例 UIBarButtonItem *barBtn = [UIBarButtonItem appearance]; // 2.1 设置barButton的文字普通状态下的属性 NSMutableDictionary *barBtnAttributesN = [NSMutableDictionary dictionary]; barBtnAttributesN[NSForegroundColorAttributeName] = [UIColor orangeColor]; barBtnAttributesN[NSFontAttributeName] = [UIFont systemFontOfSize:15]; // 设置普通状态 [barBtn setTitleTextAttributes:barBtnAttributesN forState:UIControlStateNormal]; // 2.2 设置barButton的文字不可用状态下的属性 NSMutableDictionary *barBtnAttributesS = [NSMutableDictionary dictionary]; barBtnAttributesS[NSForegroundColorAttributeName] = [UIColor lightGrayColor]; barBtnAttributesS[NSFontAttributeName] = [UIFont systemFontOfSize:15]; // 设置不可用状态 [barBtn setTitleTextAttributes:barBtnAttributesS forState:UIControlStateDisabled];&#125; 第二步 - (void)viewDidLoad &#123; [super viewDidLoad]; // 添加一个边缘滑动手势 UIScreenEdgePanGestureRecognizer *edgePan = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(edgePan:)]; edgePan.delegate = self; // 方向为左划 edgePan.edges = UIRectEdgeLeft; [self.view addGestureRecognizer:edgePan];&#125;#pragma mark - 监听手势方法- (void)edgePan:(UIScreenEdgePanGestureRecognizer *)edgePan&#123; [self popViewControllerAnimated:YES];&#125; 第三步 // 重写push方法- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated&#123; // 当不是根控制器时 if (self.viewControllers.count &gt; 0) &#123; // 隐藏tabBar viewController.hidesBottomBarWhenPushed = YES; // 自定义导航栏左边按钮 UIButton *leftBtn = [UIButton buttonWithType:UIButtonTypeCustom]; [leftBtn setImage:[UIImage imageNamed:@"navigationbar_back"] forState:UIControlStateNormal]; [leftBtn setImage:[UIImage imageNamed:@"navigationbar_back_highlighted"] forState:UIControlStateHighlighted]; [leftBtn addTarget:self action:@selector(backPress) forControlEvents:UIControlEventTouchUpInside]; [leftBtn sizeToFit]; viewController.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:leftBtn]; &#125; // 设置完毕后调用父类的push方法 [super pushViewController:viewController animated:animated];&#125;- (void)backPress&#123; [self popViewControllerAnimated:YES];&#125; 第四步 #pragma mark - UIGestureRecognizerDelegate- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer&#123; // 不允许在根控制器使用返回手势 return self.childViewControllers.count &gt; 1;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单例设计模式]]></title>
      <url>%2F2015%2F08%2F03%2Fdemonayu%2Fblog%2F35.Singleton%2F</url>
      <content type="text"><![CDATA[单例模式概念 什么是单例模式:(Singleton) 单例模式的意图是让类的对象成为系统中唯一的实例,􏰀供一个访问点,供客户类共享资源。 什么情况下使用单例? 1、类只能有一个实例,而且必须从一个为人熟知的访问点对其进行访问,比如工厂方法。 2、这个唯一的实例只能通过子类化进行扩展,而且扩展的对象不会破坏客户端代码。 单例设计模式的要点: 1) 某个类只能有一个实例; 2) 他必须自行创建这个对象; 3) 必须自行向整个系统􏰀供这个实例; 4) 为了保证实例的唯一性,我们必须将; 5) 这个方法必须是一个静态类; 单例模式宏,预处理ARC和MRC #define interfaceSingleton(name) +(instancetype)share##name#if __has_feature(objc_arc)// ARC#define implementationSingleton(name) \+ (instancetype)share##name \&#123; \name *instance = [[self alloc] init]; \return instance; \&#125; \static name *_instance = nil; \+ (instancetype)allocWithZone:(struct _NSZone *)zone \&#123; \static dispatch_once_t onceToken; \dispatch_once(&amp;onceToken, ^&#123; \_instance = [[super allocWithZone:zone] init]; \&#125;); \return _instance; \&#125; \- (id)copyWithZone:(NSZone *)zone&#123; \return _instance; \&#125; \- (id)mutableCopyWithZone:(NSZone *)zone \&#123; \return _instance; \&#125;#else// MRC#define implementationSingleton(name) \+ (instancetype)share##name \&#123; \name *instance = [[self alloc] init]; \return instance; \&#125; \static name *_instance = nil; \+ (instancetype)allocWithZone:(struct _NSZone *)zone \&#123; \static dispatch_once_t onceToken; \dispatch_once(&amp;onceToken, ^&#123; \_instance = [[super allocWithZone:zone] init]; \&#125;); \return _instance; \&#125; \- (id)copyWithZone:(NSZone *)zone&#123; \return _instance; \&#125; \- (id)mutableCopyWithZone:(NSZone *)zone \&#123; \return _instance; \&#125; \- (oneway void)release \&#123; \&#125; \- (instancetype)retain \&#123; \return _instance; \&#125; \- (NSUInteger)retainCount \&#123; \return MAXFLOAT; \&#125;#endif]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIButton调换文字与图片位置的两种方法]]></title>
      <url>%2F2015%2F08%2F02%2Fdemonayu%2Fblog%2F34.UIButton%E8%B0%83%E6%8D%A2%E6%96%87%E5%AD%97%E4%B8%8E%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[假设自定义一个UIButton控件, 然后在button里面初始化了一个title和一个image:- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; // 设置button文字 [self setTitle:@"title" forState:UIControlStateNormal]; // 设置button图片 [self setImage:[UIImage imageNamed:@"image"] forState:UIControlStateNormal]; // 设置文字大小 self.titleLabel.font = [UIFont systemFontOfSize:17]; // 设置图片居中 self.imageView.contentMode = UIViewContentModeCenter; &#125; return self;&#125; 第一种 - 重写layoutSubviews方法来实现 重写layoutSubviews方法 - (void)layoutSubviews&#123; [super layoutSubviews]; // 修改titleButton里面子控件的位置 if (self.imageView.frame.origin.x &lt; self.titleLabel.frame.origin.x) &#123; // 1. 取出title和image的frame CGRect titleFrame = self.titleLabel.frame; CGRect imageFrame = self.imageView.frame; // 2. 调整title和imageView的x值 titleFrame.origin.x = imageFrame.origin.x; imageFrame.origin.x = CGRectGetMaxX(titleFrame) + 5; // 3. 重新赋值 self.titleLabel.frame = titleFrame; self.imageView.frame = imageFrame; &#125;&#125; 重写setImage: forState:和setTitle: forState:方法 // 重写父类setImage方法- (void)setImage:(UIImage *)image forState:(UIControlState)state&#123; [super setImage:image forState:state]; // 自动计算尺寸 [self sizeToFit];&#125; // 重写父类setTitle方法- (void)setTitle:(NSString *)title forState:(UIControlState)state&#123; [super setTitle:title forState:state]; // 自动计算尺寸 [self sizeToFit];&#125; 第二种 - 重写titleRectForContentRect:和imageRectForContentRect:方法来实现 重写titleRectForContentRect:方法 // 返回文字的位置- (CGRect)titleRectForContentRect:(CGRect)contentRect&#123; CGFloat titleX = 0; CGFloat titleY = 0; CGFloat titleW = [self.currentTitle boundingRectWithSize:CGSizeMake(MAXFLOAT, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName : [UIFont systemFontOfSize:17]&#125; context:nil].size.width; CGFloat titleH = contentRect.size.height; return CGRectMake(titleX, titleY, titleW, titleH);&#125; 重写imageRectForContentRect:方法 // 返回图片位置- (CGRect)imageRectForContentRect:(CGRect)contentRect&#123; CGFloat imageW = 16; CGFloat imageH = contentRect.size.height; CGFloat imageX = contentRect.size.width - imageW; CGFloat imageY = 0; return CGRectMake(imageX, imageY, imageW, imageH);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GCD的一些总结]]></title>
      <url>%2F2015%2F07%2F21%2Fdemonayu%2Fblog%2F33.GCD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[队列与任务 同步: 同步任务,不开新线程,会阻塞当前线程. 异步: 异步任务,开新线程,不会阻塞当前线程. 串行: 串行队列,串行是按顺序排队执行任务,不会出现资源抢夺的问题,所以它默认是线程安全的. 并行: 并行队列,多条线程同时执行任务,可能会导致多条线程抢夺同一块资源.所以它默认是线程不安全的,所以在一条线程访问一块资源时需要进行加锁处理; 主队列 主队列 // 主队列dispatch_queue_t main_queue= dispatch_get_main_queue(); 所有与UI界面相关的操作都在主队列中执行. 主队列只有一条主线程,所以它默认是串行的. 在主队列中执行异步函数并不会开新的线程,所有任务默认都是在主线程执行. 不要在主队列中执行同步函数,这样会产生死锁的问题.因为主队列默认只有一条主线程,如果在主队列添加一个同步任务,会马上执行这个同步任务.而主队列当前要执行的任务并没有结束,不肯放手.两个的优先级都很高,最终导致死锁. // 在主线程执行一个同步函数 - 会发生死锁dispatch_sync(main_queue, ^&#123; // 这句代码永远不会执行 NSLog(@"%@", [NSThread currentThread]);&#125;);// 这句代码永远不会执行NSLog(@"方法执行完毕"); 如果在主队列执行异步函数,那么异步函数要执行的任务会被排到队列的后面,只有当目前这个方法执行完毕后才会过来执行这个任务,如果有多个异步函数,那么任务会依次添加进队列并按顺序执行. // 在主线程执行异步函数dispatch_async(main_queue, ^&#123; // 再执行这一句 NSLog(@"%@", [NSThread currentThread]);&#125;);// 先执行这一句NSLog(@"方法执行完毕"); 非主队列 非主队列 创建串行非主队列 (默认) dispatch_queue_t serial_queue = dispatch_queue_create("my_queue", DISPATCH_QUEUE_SERIAL); 创建并行非主队列 dispatch_queue_t concurrent_queue = dispatch_queue_create("my_queue", DISPATCH_QUEUE_CONCURRENT); 陷阱1 // 在非主队列串行执行一个异步函数dispatch_async(serial_queue, ^&#123; NSLog(@"任务开始: %@", [NSThread currentThread]); // 执行异步函数 dispatch_async(serial_queue, ^&#123; /* 这句永远不会执行 */ NSLog(@"任务1: %@", [NSThread currentThread]); &#125;); // 执行同步函数 dispatch_sync(serial_queue, ^&#123; /* 这句永远不会执行 */ NSLog(@"任务2: %@", [NSThread currentThread]); &#125;); /* 这句永远不会执行 */ NSLog(@"任务执行完毕");&#125;);NSLog(@"方法执行完毕"); 结果: 最后的这个线程会发生死锁.分析: 非主队列串行执行异步函数, 这个队列只会开启一条新线程执行任务.任务1是一个异步任务,不会阻塞当前线程,执行打它时,它会被挂起,等当前队列所有的同步任务执行完毕后再过来执行它.任务2是一个同步任务,同步任务优先级很高,需要马上执行.但是外层的函数并没有执行完毕,不肯放手,所以导致了死锁. 陷阱2 // 在非主队列并行执行一个异步函数dispatch_async(concurrent_queue, ^&#123; NSLog(@"任务开始: %@", [NSThread currentThread]); // 执行异步函数 dispatch_async(concurrent_queue, ^&#123; NSLog(@"任务1: %@", [NSThread currentThread]); &#125;); // 执行同步函数 dispatch_sync(concurrent_queue, ^&#123; // 当前任务睡2秒 sleep(2.0); NSLog(@"任务2: %@", [NSThread currentThread]); &#125;); // 执行异步函数 dispatch_async(concurrent_queue, ^&#123; NSLog(@"任务3: %@", [NSThread currentThread]); &#125;); NSLog(@"任务执行完毕");&#125;);NSLog(@"方法执行完毕"); 最后的执行顺序是: 任务2 -&gt; 任务1 -&gt; 任务3 -&gt; 打印”任务执行完毕”. 任务1 -&gt; 任务2 -&gt; 打印”任务执行完毕” -&gt; 任务3. 分析: 非主队列并发执行异步函数, 可能会开多条线程执行任务. 任务1和任务2的运行优先级是一样的,只是任务1会开启一个新的线程来执行,而任务2是同步函数只会在当前线程执行,并且会阻塞当前线程. 任务3是一个异步函数,它排在任务2之后,而任务2是一个同步函数阻塞了当前线程,所以必须要等任务2执行完毕后才能执行. 思考: 为什么在并发队列中执行同步函数不会死锁? 在并发队列中执行同步函数是不是就能起到跟栅栏函数一样的作用? 在并发队列中,当前线程起着两个作用,一个是执行任务,另一个是分配线程执行任务. 全局并发队列 全局并发队列 默认全局来管理并发,类似于自己创建并发队列,可以设置线程调度的优先级,但是一般情况下不建议这么做.因为可能会引发优先级反转. GCD的一些常用函数 通过GCD, 开发者不用再直接跟线程打交道了, 只需要向队列中添加代码块即可, GCD 在后端管理着一个线程池. GCD不仅决定着你的代码块将在哪个线程被执行, 它还根据可用的系统资源对这些线程进行管理. 这样可以将开发者从线程管理的工作中解放出来, 通过集中的管理线程, 来缓解大量线程被创建的问题. GCD 带来的另一个重要改变是, 作为开发者可以将工作考虑为一个队列, 而不是一堆线程, 这种并行的抽象模型更容易掌握和使用. dispatch_after延迟函数 利用dispatch_after函数延时执行任务 // 在主队列延迟2秒后提交任务(这里的时间单位是纳秒)dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@"在主队列延迟2秒执行");&#125;); 利用performSelector: withObject: afterDelay:延时执行任务 [self performSelector:@selector(run:) withObject:@"延时两秒运行中..." afterDelay:2.0]; 利用NSTimer延时执行任务 [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run:) userInfo:@"延时两秒运行中..." repeats:NO]; dispatch_once一次性函数 一次性代码 // dispatch_once 保证代码在程序中只执行一次static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; NSLog(@"我只会执行一次");&#125;); 使用GCD实现单例 // 防止外部文件引用变量static id musicRadio;// 单例模式的核心就是 重写alloc+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123; // GCD实现单例 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; musicRadio = [super allocWithZone:zone]; &#125;); return musicRadio;&#125; 使用懒加载和同步锁实现单例 static id musicRadio;+ (instancetype)allocWithZone:(struct _NSZone *)zone&#123; // 添加同步锁防止资源抢夺 @synchronized(self) &#123; if (musicRadio == nil) &#123; musicRadio = [super allocWithZone:zone]; &#125; &#125; return musicRadio;&#125;// 工厂方法+ (instancetype)shareMusicRadio&#123; // 防止多次加锁 if (musicRadio == nil) &#123; @synchronized (self) &#123; if (musicRadio == nil) &#123; // 防止多次init musicRadio = [[self alloc] init]; &#125; &#125; &#125; return musicRadio;&#125; 参考: 单例模式宏 dispatch_barrier栅栏函数 栅栏函数作用: 在并发队列中实现阻塞. 要想执行完前面所有的任务再执行barrier必须满足两个条件: 所有任务都是在同一个队列中. 队列不能是全局并行队列, 必须是自己创建的队列. 在串行队列中执行同步栅栏函数会发生死锁 dispatch_async(serial_queue, ^&#123; dispatch_barrier_sync(serial_queue, ^&#123; NSLog(@"会死锁!"); &#125;);&#125;); 下面示例代码中, 只有等任务3完成后任务4和任务5才能执行. // 创建一个并发的队列dispatch_queue_t concurrent_queue = dispatch_queue_create("my_queue", DISPATCH_QUEUE_CONCURRENT);// 执行异步函数dispatch_async(concurrent_queue, ^&#123; NSLog(@"任务开始: %@", [NSThread currentThread]); dispatch_async(concurrent_queue, ^&#123; NSLog(@"任务1: %@", [NSThread currentThread]); &#125;); dispatch_async(concurrent_queue, ^&#123; NSLog(@"任务2: %@", [NSThread currentThread]); &#125;); // 执行栅栏函数 dispatch_barrier_async(concurrent_queue, ^&#123; sleep(2.0); NSLog(@"任务3: %@", [NSThread currentThread]); &#125;); dispatch_async(concurrent_queue, ^&#123; NSLog(@"任务4: %@", [NSThread currentThread]); &#125;); dispatch_async(concurrent_queue, ^&#123; NSLog(@"任务5: %@", [NSThread currentThread]); &#125;); NSLog(@"任务完毕");&#125;); dispatch_apply迭代函数 因为GCD的快速迭代是多线程并发的, 所以速度要快于普通的循环结构. // 参数1: 迭代次数// 参数2: 执行的队列// 参数3: 当前迭代的索引dispatch_apply(20, dispatch_get_global_queue(0, 0), ^(size_t index) &#123; //...需要迭代的代码, 迭代顺序并不确定&#125;); 注意: 应该避免在串行队列中嵌套使用dispatch_apply, 会引发死锁.下面示例代码打印会永远停留在第一层循环 - 0 dispatch_queue_t serial_queue = dispatch_queue_create("my_queue", DISPATCH_QUEUE_SERIAL);dispatch_apply(5, serial_queue, ^(size_t i) &#123; NSLog(@"第一层循环 - %ld", i); dispatch_apply(5, serial_queue, ^(size_t j) &#123; NSLog(@"第二层循环 - %ld", j); &#125;); NSLog(@"执行完毕 - %ld", i);&#125;); dispatch_group队列组函数 很多时候我们需要等待一系列任务执行完成后, 再做一些收尾的工作. 在串行队列中很容易办到, 如果在并行队列中使用组函数也可以达到这样的效果. 组函数简单使用 // 创建一个队列组函数dispatch_group_t group = dispatch_group_create();// 获得当前全局队列dispatch_queue_t queue = dispatch_get_global_queue(0, 0);// 执行组函数dispatch_group_async(group, queue, ^&#123; NSLog(@"任务1: %@", [NSThread currentThread]);&#125;);dispatch_group_async(group, queue, ^&#123; NSLog(@"任务2: %@", [NSThread currentThread]);&#125;);// 当所有组函数执行完毕后执行dispatch_group_notifydispatch_group_notify(group, queue, ^&#123; NSLog(@"当任务1和任务2执行完毕后通知执行任务3: %@", [NSThread currentThread]);&#125;); 暂停和恢复队列 暂停(挂起)队列 dispatch_suspend(concurrent_queue); 恢复队列 dispatch_resume(concurrent_queue); 注意: dispatch_suspend并不会立即暂停正在运行的block, 而是在当前block执行完成后, 暂停后续的block执行. 参考: 并发编程：API 及挑战 GCD高级用法 GCD使用经验与技巧浅谈]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSURLConnection和NSURLSession]]></title>
      <url>%2F2015%2F07%2F19%2Fdemonayu%2Fblog%2F32.NSURLConnection%E5%92%8CNSURLSession%E6%80%9D%E8%80%83%2F</url>
      <content type="text"><![CDATA[NSURLConnection基本使用 有两种请求方式: 使用block回调: // 直接使用类方法发送一个异步请求,然后用block回调[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; //... 处理返回结果&#125;]; 使用代理方法监听: 发送一个请求并指定代理 /* 使用代理监听有两种发送请求的方式 */// 1. 发送请求指定代理,并且立即发送请求self.connection = [NSURLConnection connectionWithRequest:request delegate:self];// 2. 当startImmediately为NO时,请求不会立即执行,而是要等待start方法self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO];// 开始发送请求[self.connection start]; 使用代理方法来监听请求返回的结果 - (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123; NSLog(@"收到响应");&#125; - (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123; NSLog(@"收到数据");&#125; - (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123; NSLog(@"下载完成");&#125; trap1 在主队列中执行请求 [NSURLConnection connectionWithRequest:request delegate:self] 分析: 上面这段代码分别执行了几个步骤: 在当前队列(主队列)建立一个请求任务; 将请求任务放入当前队列线程的runloop,并且指定运行模式为默认模式; 开始发送一个异步下载请求. 测试: 在主队列中发送请求,如果此时拖拽界面的控件,下载任务会暂停,停止拖拽后下载任务会自动恢复. 如果指定代理方法在主队列调用或者设定任务在runloop中的调度方式那么会产生不一样的结果. // 指定代理方法在主队列[self.connection setDelegateQueue:[NSOperationQueue mainQueue]];// 或者: 指定调度模式为 forMode:NSRunLoopCommonModes[self.connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; 此时如果拖拽界面并不会阻塞下载任务的执行. 猜测: 在主队列中发送connection请求是异步的,而且始终只有一条线程就是主线程在执行这个任务. 最后: 在本地使用NSURLConnection下载一个288M的视频文件大概耗时3s左右.如果在子线程进行下载大概耗时1s左右. trap2 在非主队列中执行发送请求和下载操作 // 在全局队列中发送一个异步请求dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // 直接开始发送请求 self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self]; // 在子线程中调用代理方法 [self.connection setDelegateQueue:[[NSOperationQueue alloc] init]];&#125;); 分析: 在上面的代码中, connection的代理方法不会被调用, 因为下载操作是一个持续性的操作, 需要保证执行任务的线程不会被释放,如果指定代理方法在子线程中调用,那么需要在该线程中开启一个runloop才能保证持续接收到返回的数据(原理与在主队列发送请求一样). 改进 // 在全局队列中发送一个异步请求dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // 发送一个请求并不马上执行 self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO]; // 在子线程中调用代理方法 [self.connection setDelegateQueue:[[NSOperationQueue alloc] init]]; // 开始发送请求 - 注:如果是在子线程发送一个请求那么这个方法会默认在子线程开启一个runloop. [self.connection start];&#125;); 分析: start方法会在子线程中开启一个runloop来持续接收事件源的输入.调用start方法时要保证至少有一个事件源来驱动runloop的运行. 大文件下载 + 断点续传 在使用NSURLConnection进行大文件下载时,如果不进行手动处理的话会消耗大量内存直至程序崩溃. 要进行内存优化必须要使用代理方法来监听下载进度. 核心思想:边下载边存沙盒,拿到当前文件的信息然后拼接. 核心步骤: 初始化一个可变的请求对象并设置请求头信息 NSURL *url = [NSURL URLWithString:@"http://abc.com/videos/video_01"];NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];// 使用一个全局变量 currentLength 来记录已经下载的字节数// 设置请求头, 根据数据进度拼接请求, 来判断断点下载的开始范围 ** 断点续传核心代码NSString *range = [NSString stringWithFormat:@"bytes=%lld-", self.currentLength];[request setValue:range forHTTPHeaderField:@"Range"]; 在代理方法didReceiveResponse:新建沙盒文件 - (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123; // 防止文件重复写入, 当已经有数据就不再创建新文件 if (self.currentLength) return; // 新建一个空的缓存文件 NSString *cache = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; NSString *filePath = [cache stringByAppendingPathComponent:response.suggestedFilename]; [[NSFileManager defaultManager] createFileAtPath:filePath contents:nil attributes:nil]; // 定义一个句柄成员变量来记录已经下载文件的信息 self.handle = [NSFileHandle fileHandleForWritingAtPath:filePath]; // 根据响应头获得文件总大小 self.totalLength = response.expectedContentLength;&#125; 在代理方法didReceiveData:拼接文件 - (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data&#123; // 将写入位置移到文件末尾 [self.handle seekToEndOfFile]; // 写入数据 [self.handle writeData:data]; // 记录已经下载文件大小 self.currentLength += data.length;&#125; 下载完成后需要处理的事情 - (void)connectionDidFinishLoading:(NSURLConnection *)connection&#123; self.currentLength = 0; self.totalLength = 0; // 文件下载完毕后释放文件句柄 [self.handle closeFile]; self.handle = nil;&#125; 注意: 断点续传暂停时要清空当前的下载操作 - (void)suspend &#123; [self.connection cancel]; self.connection = nil;&#125; NSURLSession基本使用 NSURLSession的几种任务模式 // 抽象类-不具备执行任务功能NSURLSessionTask// 执行普通的GET/POST请求任务NSURLSessionDataTask// 执行下载请求任务NSURLSessionDownloadTask// 执行上传请求任务NSURLSessionUploadTask NSURLSession工作模式 一般模式(default): 工作模式类似于原来的NSURLConnection,可以使用缓存的Cache,Cookie,鉴权. 及时模式(ephemeral): 不使用缓存的Cache,Cookie,鉴权. 后台模式(background): 在后台完成上传下载,创建Configuration对象的时候需要给一个NSString的ID用于追踪完成工作的Session是哪一个. 两种请求方式 使用block回调: // 1. 初始一个会话对象(session)NSURLSession *session = [NSURLSession sharedSession];// 2. 初始化一个data任务NSURLSessionDataTask *dataTask = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; //... 处理返回结果&#125;];// 3. 开始任务[dataTask resume]; 使用代理方法监听: 发送一个请求并指定代理 // 1. 初始化session的工作模式NSURLSessionConfiguration *cgr = [NSURLSessionConfiguration defaultSessionConfiguration];// 2. 初始化session并指定代理, 指定调用代理方法的线程NSURLSession *session = [NSURLSession sessionWithConfiguration:cgr delegate:self delegateQueue:[NSOperationQueue mainQueue]];// 3. 初始化一个data任务NSURLSessionDataTask *datatask = [session dataTaskWithURL:url];// 4. 开始任务[dataTask resume]; 使用代理方法来监听请求返回的结果 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)responsecompletionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123; NSLog(@"收到响应");&#125; - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveData:(NSData *)data &#123; NSLog(@"收到数据");&#125; 大文件下载 + 断点续传 NSURLSession已经默认实现大文件下载和断点续传.其原理也是沙盒缓存原理. 也就是说执行下面的操作并不会暴涨内存,系统已经在内部优化好了. [self.session downloadTaskWithURL:url]; 在执行下载操作时系统默认会把下载的文件存放到沙盒的temp文件夹,如果不进行处理会马上将文件删掉. 核心步骤: 暂停任务 - (void)suspend&#123; __weak typeof(self) weakself = self; // resumeData包含了继续下载的开始位置和下载的url等信息 [self.task cancelByProducingResumeData:^(NSData *resumeData) &#123; NSLog(@"%zd", resumeData.length); weakself.resumeData = resumeData; // 将task清空释放内存 weakself.task = nil; &#125;];&#125; 恢复任务 - (void)resume&#123; // 传入上次暂停下载返回的数据，恢复下载 从resumeData接着下载 self.task = [self.session downloadTaskWithResumeData:self.resumeData]; [self.task resume]; // 将恢复信息释放 self.resumeData = nil;&#125; 在代理方法didFinishDownloadingToURL:转移文件 // 目标文件储存路径NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];NSString *filePath = [caches stringByAppendingPathComponent:downloadTask.response.suggestedFilename];// 将下载好的文件移到目标路径 - 下载完成后的文件默认在tmp文件夹（location.path），需要转移到其他位置才能查看NSFileManager *mgr = [NSFileManager defaultManager];[mgr moveItemAtPath:location.path toPath:filePath error:nil]; 细节 配置代理方法的执行队列 // 初始化session并指定代理, 指定调用代理方法的队列为主队列NSURLSession *session = [NSURLSession sessionWithConfiguration:cgr delegate:self delegateQueue:[NSOperationQueue mainQueue]]; 如果 delegateQueue 为 nil 则等同于 [[NSOperationQueue alloc] init] 则不会把获得的数据返回给主线程 (无线程通信) 如果 delegateQueue 为 [NSOperationQueue mainQueue] 则会把获得的数据传给主线程 (有线程通信) 在代理方法totalBytesExpectedToWrite:监听下载进度,打印当前的线程为主线程,与NSURLConnection一致.如果此时拖拽屏幕上的控件却并不会阻塞下载操作.为什么打印都在主线程,但是一个下载受影响一个不受影响? 猜测: session的下载任务是开辟子线程异步执行的, 然后再将结果返回给主线程.并不是只有一条线程在处理这个操作,这里与connection有很大不同.并且测试出默认情况下用session下载同一个文件要比connection快,同时下载的时间却与connection开子线程异步下载的时间差不多.故有此猜测(仅仅是猜测). 补充还有很多不完善的地方以后慢慢添砖.以上的结论有很多仅仅只是猜测,欢迎来打脸. 参考: 苹果官方文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSCache的介绍]]></title>
      <url>%2F2015%2F07%2F14%2Fdemonayu%2Fblog%2F31.NSCache%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[这篇文章介绍了如何使用NSCache来替代NSDictionary进行数据缓存. NSCache介绍 借此说一下SDWebImage这个框架中cleanDisk与clearDisk的区别://clean:删除过期缓存(缓存周期为1周),计算当前缓存文件的总大小,比较设置的最大缓存,如果超出的话,那么就继续删除(按照缓存文件创建的顺序),直到小于最大缓存为止[[SDWebImageManager sharedManager].imageCache cleanDisk];//clear:简单粗暴,直接删除然后重新创建[[SDWebImageManager sharedManager].imageCache clearDisk];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新特性界面的两种搭建方法]]></title>
      <url>%2F2015%2F06%2F04%2Fdemonayu%2Fblog%2F30.%E6%96%B0%E7%89%B9%E6%80%A7%E7%95%8C%E9%9D%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[使用UIScrollView搭建#import "NewFeaturesViewController.h"#import "TabBarViewController.h"#define kImageCount 4@interface NewFeaturesViewController() &lt;UIScrollViewDelegate&gt;@property(nonatomic, weak) UIScrollView *scrollView;@property(nonatomic, weak) UIPageControl *pageControl;@end@implementation NewFeaturesViewController// 懒加载scrollView- (UIScrollView *)scrollView&#123; if (_scrollView == nil) &#123; UIScrollView *scrollView = [[UIScrollView alloc] init]; _scrollView = scrollView; scrollView.frame = [UIScreen mainScreen].bounds; // 取消回弹 scrollView.bounces = NO; // 允许翻页 scrollView.pagingEnabled = YES; // 隐藏水平滚动条 scrollView.showsHorizontalScrollIndicator = NO; // 设置滚动范围 scrollView.contentSize = CGSizeMake(kImageCount * self.scrollView.bounds.size.width, 0); // 设置控制器为代理 scrollView.delegate = self; // 控制器View添加scrollView [self.view addSubview:scrollView]; &#125; return _scrollView;&#125;// 懒加载pageControl- (UIPageControl *)pageControl&#123; if (_pageControl == nil) &#123; UIPageControl *pageControl = [[UIPageControl alloc] init]; _pageControl = pageControl; // pageControl小圆点数量 pageControl.numberOfPages = kImageCount; /* pageControl比较特殊，可以不用设置宽高也能显示，因为小圆点为它的子控件, 但是不设置宽高就不能交互 */ // 设置pageControl的位置 pageControl.centerX = self.view.center.x; pageControl.centerY = self.view.center.y + 250; // 小圆点默认颜色 pageControl.pageIndicatorTintColor = [UIColor lightGrayColor]; // 小圆点选中颜色 pageControl.currentPageIndicatorTintColor = [UIColor orangeColor]; // 控制器View添加pageControl [self.view addSubview:pageControl]; &#125; return _pageControl;&#125;- (void)viewDidLoad&#123; [super viewDidLoad]; for (int i = 0; i &lt; kImageCount; i++) &#123; UIImageView *imageView = [[UIImageView alloc] initWithFrame:self.scrollView.bounds]; NSString *imageName = [NSString stringWithFormat:@"new_feature_%d", i + 1]; UIImage *image = [UIImage imageNamed:imageName]; imageView.image = image; // 设置性特性说明的x值 imageView.x = self.scrollView.bounds.size.width * i; // 添加新特性说明 [self.scrollView addSubview:imageView]; // 当滑到最后一页时 if (i == kImageCount - 1) &#123; // 设置最后一页的内容 [self setupLastImageView:imageView]; &#125; &#125; // pageControl默认选中第一个原点 self.pageControl.currentPage = 0;&#125;/** * 设置最后一张图片 * * @param imageView 轮播器最后一张图片 */- (void)setupLastImageView:(UIImageView *)imageView&#123; // 创建分享按钮 UIButton *buttonShare = [[UIButton alloc] init]; [buttonShare setImage:[UIImage imageNamed:@"new_feature_share_false"] forState:UIControlStateNormal]; [buttonShare setImage:[UIImage imageNamed:@"new_feature_share_true"] forState:UIControlStateSelected]; [buttonShare setTitle:@"分享给大家" forState:UIControlStateNormal]; [buttonShare setTitleColor:[UIColor grayColor] forState:UIControlStateNormal]; buttonShare.titleLabel.font = [UIFont systemFontOfSize:15]; // 设置内边距 EdgeInsets理解为自切 buttonShare.titleEdgeInsets = UIEdgeInsetsMake(0, 5, 0, 0); buttonShare.imageEdgeInsets = UIEdgeInsetsMake(0, 0, 0, 5); buttonShare.size = CGSizeMake(150, 30); buttonShare.centerX = self.view.centerX; buttonShare.centerY = self.view.centerY * 1.35; [buttonShare addTarget:self action:@selector(clickShare:) forControlEvents:UIControlEventTouchUpInside]; // 创建开启按钮 UIButton *buttonOpen = [[UIButton alloc] init]; [buttonOpen setBackgroundImage:[UIImage imageNamed:@"new_feature_finish_button"] forState:UIControlStateNormal]; [buttonOpen setBackgroundImage:[UIImage imageNamed:@"new_feature_finish_button_highlighted"] forState:UIControlStateHighlighted]; [buttonOpen setTitle:@"立即体验" forState:UIControlStateNormal]; buttonOpen.size = buttonOpen.currentBackgroundImage.size; buttonOpen.centerX = self.view.centerX; buttonOpen.centerY = self.view.centerY * 1.5; [buttonOpen addTarget:self action:@selector(clickOpen) forControlEvents:UIControlEventTouchUpInside]; // 设置imageView可交互 imageView.userInteractionEnabled = YES; [imageView addSubview:buttonOpen]; [imageView addSubview:buttonShare];&#125;- (void)clickOpen&#123; TabBarViewController *tabBarVC = [[TabBarViewController alloc] init]; // 将跟控制器改为tabBarController，并销毁当前控制器 [UIApplication sharedApplication].keyWindow.rootViewController = tabBarVC;&#125;- (void)clickShare:(UIButton *)button&#123; // 状态取反 button.selected = !button.isSelected;&#125;#pragma mark - 代理方法- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; // 当scrollView改变的时候，改变pageControl的currentPage double page = scrollView.contentOffset.x / scrollView.bounds.size.width; // (int)(page + 0.5)四舍五入法 准确定位page的圆点 self.pageControl.currentPage = (int)(page + 0.5);&#125;@end 使用UICollectionView搭建第一步:设置控制器的内容#import "XVNewFeaturesController.h"#import "XVCollectionViewCell.h"#define kImagesCount 5@interface XVNewFeaturesController () &lt;UICollectionViewDataSource&gt;// 图片数组@property (nonatomic, strong) NSArray *images;@end@implementation XVNewFeaturesController// 懒加载图片数组- (NSArray *)images&#123; if (_images == nil) &#123; // 将图片存入数组 NSMutableArray *arrayM = [NSMutableArray array]; for (int i = 1; i &lt; kImagesCount; i++) &#123; NSString *imageName = [NSString stringWithFormat:@"newFeatureImage%d", i]; UIImage *image = [UIImage imageNamed:imageName]; [arrayM addObject:image]; &#125; _images = arrayM; &#125; return _images;&#125;// 重写构造方法在创建控制器的同时就设定好布局方式- (instancetype)init&#123; // 1.设置collectionView的布局 - 布局设置是必须的 UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc] init]; // 2.设置布局的最小行间距 - 注意:默认是有间距的,需要手动设置为0 layout.minimumLineSpacing = 0; // 3.设置cell的大小 layout.itemSize = [UIScreen mainScreen].bounds.size; // 4.滚动方向 layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; // 5.完成初始化后调用父类方法 return [super initWithCollectionViewLayout:layout];&#125;- (void)viewDidLoad&#123; [super viewDidLoad]; /* 初始化CollectionView设置 */ // collectionView默认的背景色是黑色 self.collectionView.backgroundColor = [UIColor whiteColor]; // 设置分页 self.collectionView.pagingEnabled = YES; // 取消滑块 self.collectionView.showsHorizontalScrollIndicator = NO; // 禁用反弹 self.collectionView.bounces = NO;&#125;#pragma mark - UICollectionViewDataSource 数据源方法- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return self.images.count;&#125;- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; // 调用自定义cell XVCollectionViewCell *cell = [XVCollectionViewCell cellWithCollectionView:collectionView forIndexPath:indexPath]; cell.image = self.images[indexPath.row]; // 将当前的index和images总数传到cell中来判断是否是最后一页 [cell getIndexPath:indexPath andImagesCount:self.images.count]; return cell;&#125; 第二步:自定义cell#import "XVCollectionViewCell.h"#import "XVTabBarController.h"@interface XVCollectionViewCell ()@property (nonatomic, weak) UIImageView *imageV;@property (nonatomic, weak) UIButton *button;@end@implementation XVCollectionViewCell// 实例化进入应用主界面的button- (UIButton *)button&#123; if (_button == nil) &#123; UIButton *button = [[UIButton alloc] init]; [button setBackgroundImage:[UIImage imageNamed:@"startApp"] forState:UIControlStateNormal]; [button sizeToFit]; button.centerX = [UIScreen mainScreen].bounds.size.width * 0.5; button.centerY = [UIScreen mainScreen].bounds.size.height * 0.9; [button addTarget:self action:@selector(enterApp:) forControlEvents:UIControlEventTouchUpInside]; [self addSubview:button]; _button = button; &#125; return _button;&#125;// 重写构造方法在初始化cell的时候就创建一个imageView用来显示新特性- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; // 创建显示新特新图片的imageView UIImageView *imageV = [[UIImageView alloc] initWithFrame:self.bounds]; [self addSubview:imageV]; _imageV = imageV; &#125; return self;&#125;// 重写image的setter给imageV设置图片- (void)setImage:(UIImage *)image&#123; _image = image; self.imageV.image = image;&#125;// 获取索引来判断是否为最后一页- (void)getIndexPath:(NSIndexPath *)indexPath andImagesCount:(NSInteger)imagesCount&#123; // 当滑动到最后一页时 if (indexPath.row == imagesCount - 1) &#123; self.button.hidden = NO; // 显示button &#125; else &#123; self.button.hidden = YES; // 隐藏button - 防止循环利用bug &#125;&#125;// 工厂方法快速创建cellstatic NSString *ID = @"cell";+ (instancetype)cellWithCollectionView:(UICollectionView *)collectionView forIndexPath:(NSIndexPath *)indexPath&#123; [collectionView registerClass:self forCellWithReuseIdentifier:ID]; XVCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:ID forIndexPath:indexPath]; return cell;&#125;#pragma mark - 监听方法// 进入应用- (void)enterApp:(UIButton *)button&#123; // 变更rootController XVTabBarController *vc = [[XVTabBarController alloc] init]; [UIApplication sharedApplication].keyWindow.rootViewController = vc;&#125;@end 创建一个UIWindow的分类来控制是否显示新特性#import "UIWindow+Extension.h"#import "TabBarViewController.h"#import "NewFeaturesViewController.h"@implementation UIWindow (Extension)- (void)switchRootViewController&#123; // 1.获得用户的偏好设置 NSUserDefaults *user = [NSUserDefaults standardUserDefaults]; NSString *keyVersion = @"CFBundleVersion"; // 2.获得上一次打开的版本（存在沙盒内） NSString *lastVersion = [user valueForKeyPath:keyVersion]; // 3.取出当前的版本号 NSDictionary *info = [NSBundle mainBundle].infoDictionary; NSString *currentVersion = info[keyVersion]; // 4.当前版本号等于存于沙盒的版本号（上次打开时的版本）时则直接进入软件，否则显示新特性 if ([currentVersion isEqualToString:lastVersion]) &#123; TabBarViewController *tabBar = [[TabBarViewController alloc] init]; self.rootViewController = tabBar; &#125; else &#123; NewFeaturesViewController *new = [[NewFeaturesViewController alloc] init]; self.rootViewController = new; // 同步版本号 [user setValue:currentVersion forKeyPath:keyVersion]; [user synchronize]; &#125;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用运行时特性获取系统类的私有成员属性]]></title>
      <url>%2F2015%2F05%2F08%2Fdemonayu%2Fblog%2F29.%E5%88%A9%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%89%B9%E6%80%A7%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%2F</url>
      <content type="text"><![CDATA[在iOS7以后苹果添加了一个边缘滑动返回的手势操作,我们通过修改这个手势操作来说明如何利用系统的私有成员属性来达到在项目中的要求. interactivePopGestureRecognizer这个api功能就是在NavigationController堆栈内的UIViewController可以支持右滑手势,轻轻在屏幕左边一滑,屏幕就会返回.但是, 1.这个功能在自定义返回按钮后会失效; 2.它的作用范围在手机屏幕左侧边缘,如果要求全屏接受这个事件就需要自定义这个功能了. 通过打印interactivePopGestureRecognizer得知这个功能是通过UIScreenEdgePanGestureRecognizer这个手势来实现的.如果是手势就一定有target和action这两个成员属性,我们只要拿到target的真实类型.然后通过KVC就能”借用”系统实现方式来达到以上两个要求. 利用运行时获取所有的成员变量 导入运行时头文件 #import &lt;objc/runtime.h&gt; 调用runtime函数获取获取类中的所有成员属性 // 用来接收数组元素个数unsigned int outcount = 0;// UIGestureRecognizer是interactivePopGestureRecognizer的类型Ivar *ivars = class_copyIvarList([UIGestureRecognizer class], &amp;outcount);// Ivar：成员属性的意思;// 第一个参数:表示获取哪个类中的成员属性;// 第二个参数:表示这个类有多少成员属性,传入一个Int变量地址,会自动给这个变量赋值;// 返回值Ivar*:指的是一个ivar数组,会把所有成员属性放在一个数组中,通过返回的数组就能全部获取到; 获取所有的成员属性名 // 遍历ivars获取目标类中每一个成员属性名for (int i = 0; i &lt; outcount; i++) &#123; // 打印所有的成员属性名 NSLog(@"%@", @(ivar_getName(ivars[i])));&#125; 打印结果: 第一个就是我们要拿到的成员属性. _targets_delayedTouches_delayedPresses... 通过KVC拿到其关键作用的target // 拿到打印结果,通过KVC拿到那个targetNSArray *targets = [self.interactivePopGestureRecognizer valueForKeyPath:@"_targets"];NSLog(@"%@", targets);id target = [targets[0] valueForKeyPath:@"target"]; 创建一个pan手势 // handleNavigationTransition:这个方法是通过打印结果得知系统内部会调用的方法,不用我们去实现.UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)];pan.delegate = self;[self.view addGestureRecognizer:pan]; 在根控制器禁用pan手势 - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer&#123; return self.childViewControllers.count &gt; 1;&#125; 至此我们就已经修改完成了,是不是很暴力很直接!当然我本人是不支持这种方法的:1.它破坏了苹果的封装性.2它仍然有局限性,因为是利用系统的方法,如果有其他自定义要求不便于修改.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSFileManager和NSFileHandle的常用方法]]></title>
      <url>%2F2015%2F04%2F30%2Fdemonayu%2Fblog%2F28.NSFileManager%E5%92%8CNSFileHandle%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[NSFileManager 创建一个文件管理者对象 NSFileManager *mgr = [NSFileManager defaultManager]; 文件与目录的操作 createFileAtPath: // 创建文件copyItemAtPath: // 复制文件moveItemAtPath: // 移动文件removeItemFileAtPath: // 删除文件attributesOfItemAtPath: // 获取文件的属性setAttributes: // 更改属性currentDirectoryPath: // 获取当前的目录changeCurrentDirectoryPath: // 更改目录createDirectoryAtPath: // 创建目录 获取文件和目录信息 contentsAtPath: // 获取文件中的信息enumeratorAtPath: // 枚举目录contentsOfDirectoryAtPath: // 列举目录 判断文件 fileExistsAtPath: // 判断文件是否存在isReadableFile: // 判断是否能进行读取操作isWritableFileAtPath: // 判断是否能进行写入操作isDeletableFileAtPath: // 判断是否可删除isExecutableFileAtPath: // 判断是否可以执行contentsEqualAtPath: // 判断是否相等 目录工具函数 NSUserName() // 函数:返回登录名NSFullUserName() // 函数:返回完整用户名NSHomeDirectory() // 函数:返回路径NSHomeDirectoryForUser() // 函数:返回用户的主目录NSTemporaryDirectory() // 函数:返回临时文件的路径目录[fileList pathsMatchingExtensions:[NSArrayarrayWithObject:@"jpg"]]; // 过滤数组中的文件类型 常用路径工具方法 - (NSString *)pathWithComponents:components // 根据components中元素构造有效路径- (NSArray *)pathComponents // 析构路径,获取路径的各个部分- (NSString *)lastPathComponent // 提取路径的最后一个组成部分- (NSString *)pathExtension // 路径扩展名- (NSString *)stringByAppendingPathComponent:path // 将path添加到现有路径末尾- (NSString *)stringByAppendingPathExtension:ext // 将拓展名添加的路径最后一个组成部分- (NSString *)stringByDeletingPathComponent // 删除路径的最后一个部分- (NSString *)stringByDeletingPathExtension // 删除路径的最后一个部分 的扩展名- (NSString *)stringByExpandingTildeInPath // 将路径中的代字符扩展成用户主目录(~)或指定用户主目录(~user)- (NSString *)stringByResolvingSymlinksInPath // 尝试解析路径中的符号链接- (NSString *)stringByStandardizingPath // 通过尝试解析~、..、.、和符号链接来标准化路径 NSFileHandle 文件读取 init: // 初始化文件读写对象fileHandleForReadingAtPath: // 读取时打开文件fileHandleForWritingAtPath: // 写入时打开文件fileHandleForUpdatingAtPath: // 更新时打开文件writeData: // 数据写入文件readDataToEndOfFile: // 读取数据readDataOfLength: // 读取固定大小的内容offsetInFile: // 获取当前偏移量seekToFileOffset: // 设置当前的偏移量seekToEndOfFile: // 将偏移量定位到文件尾truncateFileAtOffset: // 设置字节availableData: // 返回可用数据closeFile: // 关闭文件 NSProcessInfo类:设置或检索正在运行的应用程序的各种类型信息- (NSProcessInfo *)processInfo // 返回当前进程的信息- (NSArray*)arguments // 以NSString对象数字的形式返回当前进程的参数- (NSDictionary *)environment // 返回变量/值对词典。描述当前的环境变量- (int)processIdentity // 返回进程标识- (NSString *)processName // 返回进程名称- (NSString *)globallyUniqueString // 每次调用该方法都会返回不同的单值字符串，可以用这个字符串生成单值临时文件名- (NSString *)hostname // 返回主机系统的名称- (unsigned int)operatingSystem // 返回表示操作系统的数字- (NSString *)operatingSystemName // 返回操作系统名称- (NSString *)operatingSystemVersionString // 返回操作系统当前版本- (void)setProcessName:(NSString *)name // 将当前进程名称设置为name]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TableVIew单元格多图下载]]></title>
      <url>%2F2015%2F04%2F02%2Fdemonayu%2Fblog%2F27.TableVIew%E5%8D%95%E5%85%83%E6%A0%BC%E5%A4%9A%E5%9B%BE%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[考虑因素 单元格的多图下载要考虑到: 必须要在子线程进行下载 防止重复下载 数据缓存 实现思路 实现方法 将cache路径写成宏 #define cachePath(url) [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).lastObject stringByAppendingPathComponent:[url lastPathComponent]] 在cellForRowAtIndexPath:方法中判断图片是否存在 // 取出对应的模型XVModel *item = self.items[indexPath.row];cell.textLabel.text = item.title;cell.detailTextLabel.text = item.subTitle;// 1&gt; 先从内存缓存中取// 根据url取出图片UIImage *memoryImage = self.images[item.icon];if (memoryImage) &#123; // 当内存中有图片时 cell.imageView.image = memoryImage;&#125; else &#123; // 当内存中没有图片时 // 2&gt; 再从沙盒中取 - 每一张图片都是一个文件 文件名为url名 UIImage *diskImage = [UIImage imageWithContentsOfFile:cachePath(item.icon)]; if (diskImage) &#123; // 沙盒中有图片时 cell.imageView.image = diskImage; &#125; else &#123; // 当沙盒中没有对应的图片时 // 设置占位图片 cell.imageView.image = [UIImage imageNamed:@"placeholder3"]; // 3&gt; 从网络上下载 [self downloadImageWithUrlStr:item.icon indexPath:indexPath]; &#125;&#125; 实现异步下载 为了保证一张图片只下载一次,需要判断当前url是否有下载任务,如果没有才需要创建下载任务. 如何才能判断当前的url是否有下载任务呢?利用字典把url作为key绑定下载操作来判断. - (void)downloadImageWithUrlStr:(NSString *)urlStr indexPath:(NSIndexPath *)indexPath&#123; // 取出字典中url对应的下载任务 NSBlockOperation *operation = self.operations[urlStr]; // 如果当前url有下载任务 - 就不创建任务 if (!operation) &#123; // 没有下载任务 __weak typeof(self) weakself = self; // 创建异步任务 - 将下载图片的操作放入到子线程中 - (解决异步下载的问题) operation = [NSBlockOperation blockOperationWithBlock:^&#123; // 将字符串转成url NSURL *url = [NSURL URLWithString:urlStr]; // 从url获取数据 NSData *imageData = [NSData dataWithContentsOfURL:url]; // 将二进制数据转成图片 UIImage *image = [UIImage imageWithData:imageData]; // 返回主线程刷新数据 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; // 如果下载成功将图片存入字典 - 字典不能存空 if (image) &#123; // 1)将下载好的图片添加进图片字典中 url为key [weakself.images setObject:image forKey:urlStr]; // 刷新表格 [weakself.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; // 2)将image写入沙盒 // 将图片转成二进制数据 NSData *data = UIImagePNGRepresentation(image); // 写入沙盒 [data writeToFile:cachePath(urlStr) atomically:YES]; &#125; // 下载完毕后将任务从字典中移除 - 如果下载失败将任务移除后还有机会下载,如果不移除,这个key就会一直存在永远也不能再次下载了 // 在主线程中移除是为了保证下载操作已经执行完毕 [weakself.operations removeObjectForKey:urlStr]; &#125;]; &#125;]; &#125; // 将任务添加到队列 [self.queue addOperation:operation]; // 将下载任务写入到字典里(解决重复下载问题) [self.operations setObject:operation forKey:urlStr];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[渐变图层,复制图层和形状图层的简单用法]]></title>
      <url>%2F2015%2F03%2F14%2Fdemonayu%2Fblog%2F26.%E6%B8%90%E5%8F%98%E5%9B%BE%E5%B1%82%2C%E5%A4%8D%E5%88%B6%E5%9B%BE%E5%B1%82%E5%92%8C%E5%BD%A2%E7%8A%B6%E5%9B%BE%E5%B1%82%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[渐变图层- (void)viewDidLoad &#123; [super viewDidLoad]; /* 创建一个imageView控件 */ UIImageView *imageV = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"image"]]; imageV.frame = CGRectMake(0, 0, 200, 200); imageV.center = self.view.center; [self.view addSubview:imageV]; [self addGradientLayerToView:imageV];&#125;/** 添加渐变图层 */- (void)addGradientLayerToView:(UIView *)view&#123; /* 创建一个渐变图层 */ CAGradientLayer *gradient = [CAGradientLayer layer]; // 设置图层frame gradient.frame = view.bounds; // 渐变颜色(用(id)强转成OC对象) gradient.colors = @[(id)[UIColor redColor].CGColor, (id)[UIColor blueColor].CGColor]; // 渐变范围(取值范围是0~1, 差值越大表示渐变范围越大) gradient.locations = @[@0, @1]; // 渐变方向(下面代码表示左上角到右下角的渐变) gradient.startPoint = CGPointMake(0, 0); gradient.endPoint = CGPointMake(1, 1); // 不透明度 gradient.opacity = 0.5; // 给控件添加渐变图层 [view.layer addSublayer:gradient];&#125; 复制图层/** 添加复制图层 */- (void)addReplicatorLayerToView:(UIView *)view&#123; /* 创建一个复制层 */ CAReplicatorLayer *replicator = [CAReplicatorLayer layer]; // 设置图层frame replicator.frame = CGRectMake(0, 20, 100, 100); // 设置背景颜色 replicator.backgroundColor = [UIColor blueColor].CGColor; // 添加图层 [self.view.layer addSublayer:replicator]; // 创建子层1 CALayer *sublayer1 = [CALayer layer]; sublayer1.frame = CGRectMake(0, 0, 30, 30); sublayer1.backgroundColor = [UIColor redColor].CGColor; [replicator addSublayer:sublayer1]; // 创建子层2 CALayer *sublayer2 = [CALayer layer]; sublayer2.frame = CGRectMake(0, 70, 30, 30); sublayer2.backgroundColor = [UIColor greenColor].CGColor; [replicator addSublayer:sublayer2]; // 复制层是复制里面的子层,而不是复制层本身 // 设置要复制图层中子层的个数(数量包括自己本身的) replicator.instanceCount = 3; // 子层形变(基于上一次子层的形变) replicator.instanceTransform = CATransform3DMakeTranslation(100, 0, 0);&#125; 形状图层/* 添加形状图层 */- (void)addShapeLayerToView:(UIView *)view&#123; /* 绘制一个圆形路径 */ UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 100, 100)]; /* 创建一个形状图层 */ CAShapeLayer *shape = [CAShapeLayer layer]; // 设置路径(将路径装换成形状图层) shape.path = path.CGPath; // 设置填充色 shape.fillColor = [UIColor redColor].CGColor; // 设置描边色 shape.strokeColor = [UIColor blackColor].CGColor; // 设置线宽 shape.lineWidth = 5; // 描边起始点 (取值范围是0~1) shape.strokeStart = 0; // 描边结束点 (取值范围是0~1) shape.strokeEnd = 0.75; // 添加图层 [view.layer addSublayer:shape];&#125; 自定义view时重写父类类方法来修改view的初始层//返回当前View当中layer的类型+ (Class)layerClass&#123; // 将初始层修改为复制层 return [CAReplicatorLayer class];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[核心动画与UIView动画的对比]]></title>
      <url>%2F2015%2F02%2F18%2Fdemonayu%2Fblog%2F25.%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E4%B8%8E%E6%98%BE%E7%A4%BA%E5%8A%A8%E7%94%BB%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[CALayer CALayer简介 CALayer我们又称它叫做层. 在每个UIView内部都有一个layer这样一个属性. UIView之所以能够显示,就是因为它里面有这个一个层,才具有显示的功能. 我们通过操作CALayer对象,可以很方便地调整UIView的一些外观属性.比如给UIView设置阴影,圆角,边框等等… 所进行的核心动画在层里完成 设置CALayer属性 - (void)addCALayer&#123; // 自定义一个图层 CALayer *layer = [CALayer layer]; // 设置图层的宽高 layer.bounds = CGRectMake(0, 0, 100, 100); // 图层位置 layer.position = CGPointMake(100, 100); // 图层的锚点(它决定CALayer身上哪一个点会在position属性所指的位置,默认为(0.5, 0.5) layer.anchorPoint = CGPointMake(0, 0); // 图层的背景颜色 layer.backgroundColor = [UIColor redColor].CGColor; // 设置图层的圆角 layer.cornerRadius = 10; // 相当于Clip layer.masksToBounds = YES; // 设置图层边框宽度 layer.borderWidth = 3; // 设置图层边框颜色 layer.borderColor = [UIColor whiteColor].CGColor; // 设置图层显示内容 layer.contents = (__bridge id)([UIImage imageNamed:@"image"].CGImage); // 将自定义图层加载到父图层 [self.view.layer addSublayer:layer];&#125; 注意: UIImageView当中Image并不是直接添加在层上面的.而是添加在layer当中的contents里.我们设置层的所有属性它只作用在层上面.对contents里面的东西并不起作用.所以如果直接只设置cornerRadius我们是看不到图片的圆角效果的.想要让图片有圆角的效果,需要设置masksToBounds属性设为YES,它会把超过根层以外的东西都给裁剪掉. PS1: 为什么要使用CGImageRef、CGColorRef? 为了保证可移植性,QuartzCore不能使用UIImage、UIColor,只能使用CGImageRef、CGColorRef. PS2: 所有的动画都是基于锚点做参照来进行的. CALayer的CATransform3D属性 (只有旋转的时候才可以看出3D的效果). // x,y,z 分别代表x,y,z轴.// 旋转: CATransform3DMakeRotation(M_PI, 1, 0, 0);// 平移:CATransform3DMakeTranslation(x,y,z);// 缩放:CATransform3DMakeScale(x,y,z); CATransform3D的键值 隐式动画 什么是隐式动画 在了解隐式动画前先了解什么是根层和非根层: 根层: UIView内部自动关联着的那个layer我们称它是根层. 非根层: 自己手动创建的层,称为非根层. 隐式动画就是当对非根层的部分属性进行修改时,它会自动的产生一些动画的效果.我们称这个默认产生的动画为隐式动画. 给根层添加的动画叫做核心动画.隐式动画是系统默认给非根层添加的动画,核心动画是程序员自己手动来添加的,其实隐式动画就是核心动画. 如何取消隐式动画 隐式动画的底层是包装成一个事务(CATransaction)来进行的. 事物: 很多操作绑定在一起,当这些操作执行完毕后,才去执行下一个操作. 手动在事物中关闭动画[CATransaction setDisableActions:YES]; - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event&#123; UITouch *touch = [touches anyObject]; CGPoint point = [touch locationInView:self.view]; // 1. 开启事务 [CATransaction begin]; // 动画时长 [CATransaction setAnimationDuration:0.1]; // 取消隐式动画 (默认有) [CATransaction setDisableActions:YES]; // 2. 修改图层属性 CGFloat r = arc4random_uniform(256) / 255.0; CGFloat g = arc4random_uniform(256) / 255.0; CGFloat b = arc4random_uniform(256) / 255.0; // 修改背景颜色 self.layer.backgroundColor = [UIColor colorWithRed:r green:g blue:b alpha:1].CGColor; // 修改圆角度数 self.layer.cornerRadius = arc4random_uniform(10); // 修改位置 self.layer.position = point; // 3. 提交事务 [CATransaction commit];&#125; 核心动画 核心动画中所有类都遵守CAMediaTiming协议 核心动画的继承结构 CAAnaimation是个抽象类,不具备动画效果,必须用它的子类才有动画效果,其中: CAAnimationGroup是个动画组,可以同时进行缩放,旋转; CATransition是转场动画,界面之间跳转都可以用转场动画; CAPropertyAnimation也是个抽象类,本身不具备动画效果,只有调用其子类才有动画,其中: CABasicAnimation基本动画，做一些简单效果; CAKeyframeAnimation帧动画，做一些连续的流畅的动画; 基础核心动画 // 创建基本核心动画// 旋转CABasicAnimation *rotation = [CABasicAnimation animation];// 直接通过KVC来更改键值rotation.keyPath = @"transform.rotation";rotation.toValue = @M_PI_2;// 位移CABasicAnimation *position = [CABasicAnimation animation];position.keyPath = @"position";position.toValue = [NSValue valueWithCGPoint:CGPointMake(50, 200)];// 缩放CABasicAnimation *scale = [CABasicAnimation animation];scale.keyPath = @"transform.scale";scale.toValue = @0.5;// 创建一个动画组(组合动画)CAAnimationGroup *group = [CAAnimationGroup animation];// 将动画添加到动画组group.animations = @[rotation, position, scale];// 动画时间group.duration = 1;// 取消反弹group.removedOnCompletion = NO;// 保存动画最前面的效果group.fillMode = kCAFillModeForwards;// 给控件图层添加动画[image.layer addAnimation:group forKey:nil]; 使用动画组的好处: 不需要每次都去添加动画,设置动画完成时的属性.只需要把要执行的动画,添加到动画组的animations数组当中即可.最后把组动画添加到层上面,就会自动执行数组当中的动画.动画完成时设置的属性也只需要设置一次. 关键帧动画 // 1.创建关键帧动画对象CAKeyframeAnimation *frameAnim = [CAKeyframeAnimation animation];// 2.绘制一个路径UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(50, 50, 200, 200)];// 3.设置动画参数group.duration = 1;group.removedOnCompletion = NO;group.fillMode = kCAFillModeForwards;// 4.给控件添加动画[self.redView.layer addAnimation:frameAnim forKey:nil]; 转场动画 - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 转场动画要和转场代码写在同一个方法当中才有动画效果. // 1.1 设定转场条件 _i++; if (_i &gt; 3) &#123; _i = 1; &#125; // 1.2 添加转场代码 - 替换图片 self.imageV.image = [UIImage imageNamed:[NSString stringWithFormat:@"%ld", _i]]; // 2.1 添加一个转场动画 CATransition *anim = [CATransition animation]; // 2.2 设置转场样式 anim.type = @"cube"; // 2.3 动画参数 //设置动画的开始位置 anim.startProgress = 0.5; //设置动画的结束位置 anim.endProgress =0.8; // 2.3 添加转场动画 [self.imageV.layer addAnimation:anim forKey:nil]&#125; 转场动画过渡效果 核心动画的代理方法 - 它所使用的是非正式协议(其实就是个分类) // 动画开始- (void)animationDidStart:(CAAnimation *)anim;// 动画结束- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag; 暂停动画和恢复动画 // 暂停动画- (void)pauseLayer:(CALayer*)layer&#123; CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil]; // 让CALayer的时间停止走动 layer.speed = 0.0; // 让CALayer的时间停留在pausedTime这个时刻 layer.timeOffset = pausedTime;&#125;// 恢复动画- (void)resumeLayer:(CALayer*)layer&#123; CFTimeInterval pausedTime = layer.timeOffset; // 1. 让CALayer的时间继续行走 layer.speed = 1.0; // 2. 取消上次记录的停留时刻 layer.timeOffset = 0.0; // 3. 取消上次设置的时间 layer.beginTime = 0.0; // 4. 计算暂停的时间(这里也可以用CACurrentMediaTime()-pausedTime) CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime; // 5. 设置相对于父坐标系的开始时间(往后退timeSincePause) layer.beginTime = timeSincePause;&#125; 补充两个控制动画的属性: fillMode属性值（要想fillMode有效，最好设置removedOnCompletion = NO）--------------kCAFillModeRemoved: 这个是默认值,也就是说当动画开始前和动画结束后,动画对layer都没有影响,动画结束后,layer会恢复到之前的状态;kCAFillModeForwards: 当动画结束后,layer会一直保持着动画最后的状态;kCAFillModeBackwards: 在动画开始前,只需要将动画加入了一个layer,layer便立即进入动画的初始状态并等待动画开始;kCAFillModeBoth: 这个其实就是上面两个的合成.动画加入后开始之前,layer便处于动画初始状态,动画结束后layer保持动画最后的状态.速度控制函数(CAMediaTimingFunction) --------------kCAMediaTimingFunctionLinear(线性): 匀速,给你一个相对静态的感觉;kCAMediaTimingFunctionEaseIn(渐进): 动画缓慢进入,然后加速离开;kCAMediaTimingFunctionEaseOut(渐出): 动画全速进入,然后减速的到达目的地;kCAMediaTimingFunctionEaseInEaseOut(渐进渐出): 动画缓慢的进入,中间加速，然后减速的到达目的地。这个是默认的动画行为. UIView动画与核心动画对比? UIView动画和核心动画区别? 核心动画只能添加到CALayer(图层); 核心动画一切都是假象,并不会改变真实的值; 什么时候使用UIView的动画? 如果需要与用户交互就使用UIView的动画; 不需要与用户交互可以使用核心动画; 什么场景使用核心动画最多? 在转场动画中,核心动画的类型比较多; 根据一个路径做动画,只能用核心动画（帧动画）; 动画组: 同时做多个动画; UIView和CALayer该怎样选择? 对比CALayer,UIView多了一个事件处理的功能.也就是说CALayer不能处理用户的触摸事件,而UIView可以,如果显示出来的东西需要跟用户进行交互的话,用UIView;如果不需要跟用户进行交互,用UIView或者CALayer都可以.CALayer的性能会高一些,因为它少了事件处理的功能,更加轻量级. 猜想： View持有CALayer用于显示，View中大部分用于显示的属性都是有layer映射过来的。是否Layer 的 delegate 在这里是 View，当其属性改变、动画产生时，View 能够得到通知。也就是说，UIView的动画只是对核心动画的一层封装，在动画完成后也同时改变了View的一些属性。UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。 使用UIView动画函数实现转场动画 /* 单视图 */+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion;// 参数说明：// duration：动画的持续时间// view：需要进行转场动画的视图// options：转场动画的类型// animations：将改变视图属性的代码放在这个block中// completion：动画结束后，会自动调用这个block /* 双视图 */+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion;// 参数说明：// duration：动画的持续时间// options：转场动画的类型// animations：将改变视图属性的代码放在这个block中// completion：动画结束后，会自动调用这个block]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[image与color之间互转]]></title>
      <url>%2F2015%2F01%2F26%2Fdemonayu%2Fblog%2F24.image%E4%B8%8Ecolor%E4%B9%8B%E9%97%B4%E4%BA%92%E8%BD%AC%2F</url>
      <content type="text"><![CDATA[颜色转图片, 集成到UIImage分类 + (UIImage *)imageWithColor:(UIColor *)color&#123; // 描述矩形 CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f); // 开启位图上下文 UIGraphicsBeginImageContext(rect.size); // 获取位图上下文 CGContextRef context = UIGraphicsGetCurrentContext(); // 使用color演示填充上下文 CGContextSetFillColorWithColor(context, color.CGColor); // 渲染上下文 CGContextFillRect(context, rect); // 从上下文中获取图片 UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext(); // 结束上下文 UIGraphicsEndImageContext(); return theImage;&#125; 图片转颜色 UIColor *color = [UIColor colorWithPatternImage:image];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[长按截屏和图片裁剪]]></title>
      <url>%2F2015%2F01%2F25%2Fdemonayu%2Fblog%2F23.%E9%95%BF%E6%8C%89%E6%88%AA%E5%B1%8F%E5%92%8C%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%2F</url>
      <content type="text"><![CDATA[长按截屏- (void)longPress:(UILongPressGestureRecognizer *)longPress&#123; // 注意这个longPress会调用两次,一次是触发时,一次是结束时, 所以这里需要对状态进行一次判定,避免两次触发 if (longPress.state == UIGestureRecognizerStateBegan) &#123; // 通过设置首尾式动画来达到屏幕闪一下的效果 [UIView animateWithDuration:0.2 animations:^&#123; self.view.alpha = 0.6; &#125; completion:^(BOOL finished) &#123; [UIView animateWithDuration:0.5 animations:^&#123; self.view.alpha = 1; &#125; completion:^(BOOL finished) &#123; // 开启一个全屏位图上下文 UIGraphicsBeginImageContextWithOptions([UIScreen mainScreen].bounds.size, YES, 0.0 ); // 获取当前上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 渲染图层到上下文 [self.view.layer renderInContext:ctx]; // 将当前上下文中的内容转成图片 UIImage *capture = UIGraphicsGetImageFromCurrentImageContext(); // 关闭上下文 UIGraphicsEndImageContext(); // 将图片输出 NSData *imgData = UIImagePNGRepresentation(capture); [imgData writeToFile:@"/Users/Xion/Desktop/image.png" atomically:YES]; &#125;]; &#125;]; &#125;&#125; 图片裁剪 为UIimage增加一个分类类方法,在实例化图片时就对其进行裁剪 #import "UIImage+ClipImage.h"@implementation UIImage (ClipImage)+ (instancetype)imageNamed:(NSString *)name withClipShape:(ClipShape)shape;&#123; UIImage *image = [self imageNamed:name]; // 开启一个上下文 UIGraphicsBeginImageContextWithOptions(image.size, NO, 0.0); // 设置为模具 switch (shape) &#123; case ClipShapeWithCircle: &#123; // 圆 CGFloat radius = image.size.width * 0.5; CGPoint center = CGPointMake(radius, radius); UIBezierPath *circlePath = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:0 endAngle:M_PI * 2 clockwise:YES]; // 设置裁剪区 [circlePath addClip]; break; &#125; case ClipShapeWithtriangle: &#123; // 三角形 UIBezierPath *path = [UIBezierPath bezierPath]; CGPoint startP = CGPointMake(image.size.width * 0.5, 0); [path moveToPoint:startP]; [path addLineToPoint:CGPointMake(0, image.size.height)]; [path addLineToPoint:CGPointMake(image.size.width, image.size.height)]; // 关闭路径 [path closePath]; [path addClip]; break; &#125; case ClipShapeWithRhombus: &#123; // 菱形 UIBezierPath *path = [UIBezierPath bezierPath]; CGPoint startP = CGPointMake(image.size.width * 0.5, 0); [path moveToPoint:startP]; [path addLineToPoint:CGPointMake(image.size.width, image.size.height * 0.5)]; [path addLineToPoint:CGPointMake(image.size.width * 0.5, image.size.height)]; [path addLineToPoint:CGPointMake(0, image.size.height * 0.5)]; [path closePath]; [path addClip]; break; &#125; &#125; // 画出裁剪范围 [image drawAtPoint:CGPointZero]; // 将当前上下文的内容转成图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); // 关闭上下文 UIGraphicsEndImageContext(); return newImage;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用手势识别来简化事件处理]]></title>
      <url>%2F2015%2F01%2F25%2Fdemonayu%2Fblog%2F22.%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[UIGestureRecognizer手势识别 UIGestureRecognizer是一个抽象类,定义了所有手势的基本行为,使用它的子类才能处理具体的手势. 利用UIGestureRecognizer,能轻松识别用户在某个view上面做的一些常见手势. 手势有以下几种: UITapGestureRecognizer(敲击) UIPinchGestureRecognizer(捏合，用于缩放) UIPanGestureRecognizer(拖拽) UISwipeGestureRecognizer(轻扫) UIRotationGestureRecognizer(旋转) UILongPressGestureRecognizer(长按) 手势使用方法: 创建手势 // 创建一个拖动手势UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)]; 添加手势 [self.view addGestureRecognizer:pan]; 实现手势方法 - (void)pan:(UIPanGestureRecognizer *)pan &#123; &#125; 拖动的状态 if(pan.state == UIGestureRecognizerStateBegan)&#123; NSLog(@"开始");&#125;else if(pan.state == UIGestureRecognizerStateChanged)&#123; NSLog(@"移动");&#125;else if(pan.state == UIGestureRecognizerStateEnded)&#123; NSLog(@"移开");&#125; 拖动状态复位 //复位 - 因为setTranslation会基于上一次的改变[pan setTranslation:CGPointZero inView:self.view]; 手势常用的代理方法 //是否允许接收手指点击- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch&#123; return YES;&#125;//是否允许同时支持多个手势 - 默认为NO-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; return YES;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[事件处理]]></title>
      <url>%2F2015%2F01%2F13%2Fdemonayu%2Fblog%2F21.%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[事件的产生和传递 iOS当中常用的事件: 触摸事件 加速计事件 远程控制事件 处理事件的常用方法: 触摸事件: - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; 加速计事件: - (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event; 远程控制事件: - (void)remoteControlReceivedWithEvent:(UIEvent *)event; 事件是怎么传递的? 比如当发生一个触摸事件后,系统会将该事件加入到一个由UIApplication管理的事件队列中. UIApplication会从事件队列中取出最前面的事件,并将事件分发下去以便处理. 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件. 触摸事件的传递是从父控件传递到子控件的, 如果一个父控件不能接收事件,那么它里面的了子控件也不能够接收事件. 一个控件什么情况下不能够接收事件. 不能与用户交互的时候userInteractionEnabled = NO.(注意:UIImageView默认是不可交互的) 隐藏的时候Hidden = YES. 颜色为全透明的时候alpha = 0. 事件响应 用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程 后，会找到最合适的视图控件来处理这个事件,找到最合适的视图控件后,就会调用控件的touches方法来作具体的事件处理那这些touches方法的默认做法是将事件顺着响应者链条向上传递,将事件交给上一个响应者进行处理. 什么是响应者对象和响应者链条: 继承了UIResponds的对象我们称它为响应者对象 UIApplication、UIViewController、UIView都继承自UIResponder,因此它们都是响应者对象，都能够接收并处理事件 响应者链条是由多个响应者对象连接起来的链条. 响应者链的事件传递过程 如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图 如果当前的View是控制器的View,那么控制器就是上一个响应者. 如果当前的View不是控制器的View,那么它的父控件就是上一个响应者. 在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理 如果window对象也不处理，则其将事件或消息传递给UIApplication对象 如果UIApplication也不能处理该事件或消息，则将其丢弃 如何寻找最合适的view 先判断自己是否能够接收触摸事件,如果能再继续往下判断, 再判断触摸的当前点在不在自己的身上. 如果在自己身上,它会从后往前遍历子控件,遍历出每一个子控件后,重复前面的两个步骤. 如果没有符合条件的子控件,那么它自己就是最适合的View. 事件传递的完整过程 以触摸事件为例,先将事件对象由上往下传递(由父控件传递给子控件),找到最合适的控件来处理这个事件. 调用最合适控件的touches…方法. 如果调用了[super touches….]就会将事件顺着响应者链条往上传递,传递给上一个响应者. 接着就会调用上一个响应者的touches…方法. hitTest方法与pointInside方法// 作用:寻找最适合的View.// 参数:当前手指所在的点;产生的事件// 返回值:返回谁, 谁就是最适合的View.// 什么时候用调用:只要一个事件,传递给一个控件时,就会调用这个控件的hitTest方法- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event // 作用:判断point在不在方法调用者上// point:必须是方法调用者的坐标系// 什么时候调用:hitTest方法底层会调用这个方法,判断点在不在控件上.- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; return YES;&#125; 模拟hitTest:withEvent:方法的底层实现(寻找最合适view) - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; //1.判断自己能否接收事件 if (self.hidden == YES || self.alpha &lt;= 0.01 || self.userInteractionEnabled == NO) &#123; return nil; &#125; //2.触摸点是否在自己身上 if (![self pointInside:point withEvent:event]) &#123; return nil; &#125; //3.从后往前遍历子控件,看自己的子控制器是否是最适合的View. int count = (int)self.subviews.count; for(int i = count - 1; i &gt;= 0; i--)&#123; UIView *childV = self.subviews[i]; //判断自己子控件是否是最适合的view //point点必须得要跟方法调用者在同一个坐标系上. //把当前点转换成子控件坐标系上面的点. CGPoint childViewP = [self convertPoint:point toView:childV]; UIView *fitView = [childV hitTest:childViewP withEvent:event]; if (fitView) &#123; return fitView; &#125; &#125; //没有比它更适合的View. return self;&#125; 监听UIView的触摸事件来实现拖拽: 想要监听UIViiew的触摸事件,首先第一步要自定义UIView,因为只有实现了UIResponder的事件方法才能够监听事件. 一次完整的触摸过程，会经历3个状态： // 1. 触摸开始- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event// 2. 触摸移动- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event// 3. 触摸结束- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event// 触摸取消（可能会经历,比如突然来电,手机自动关机）- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event 一次完整的触摸过程中，只会产生一个事件对象，4个触摸方法都是同一个event参数. 如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象. 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象. 举例: 实现UIview的拖拽- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 拿到这个点 UITouch *touch = [touches anyObject]; // 获得这个点的当前位置 CGPoint currentP = [touch locationInView:self]; // 获得这个点之前的位置 CGPoint previousP = [touch previousLocationInView:self]; // 计算出偏移量 - 要移动的距离 CGFloat distanceX = currentP.x - previousP.x; CGFloat distanceY = currentP.y - previousP.y ; // 改变view状态 self.transform = CGAffineTransformTranslate(self.transform, distanceX, distanceY);&#125; 使用手势识别来简化事件处理: 手势识别基本使用.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSArray和NSDictionary控制台中文打印]]></title>
      <url>%2F2014%2F12%2F22%2Fdemonayu%2Fblog%2F20.NSArray%E5%92%8CNSDictionary%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%87%E6%89%93%E5%8D%B0%2F</url>
      <content type="text"><![CDATA[使用方法: 在项目中新建一个.m文件将代码拷贝到文件中即可. #import &lt;Foundation/Foundation.h&gt;@implementation NSDictionary (Log)- (NSString *)descriptionWithLocale:(id)locale&#123; NSMutableString *str = [NSMutableString string]; [str appendString:@"&#123;\n"]; // 遍历字典的所有键值对 [self enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; [str appendFormat:@"\t%@ = %@,\n", key, obj]; &#125;]; [str appendString:@"&#125;"]; // 查出最后一个,的范围 NSRange range = [str rangeOfString:@"," options:NSBackwardsSearch]; // 删掉最后一个, [str deleteCharactersInRange:range]; return str;&#125;@end@implementation NSArray (Log)- (NSString *)descriptionWithLocale:(id)locale&#123; NSMutableString *str = [NSMutableString string]; [str appendString:@"[\n"]; // 遍历数组的所有元素 [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; [str appendFormat:@"%@,\n", obj]; &#125;]; [str appendString:@"]"]; // 查出最后一个,的范围 NSRange range = [str rangeOfString:@"," options:NSBackwardsSearch]; // 删掉最后一个, [str deleteCharactersInRange:range]; return str;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSFileManager计算文件夹大小]]></title>
      <url>%2F2014%2F12%2F21%2Fdemonayu%2Fblog%2F19.NSFileManager%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%2F</url>
      <content type="text"><![CDATA[计算文件夹大小 给NSString添加一个计算文件夹大小的分类, 以字节输出 // 文件大小- (NSUInteger)sizeOfFile&#123; // 创建一个文件管理者 NSFileManager *mgr = [NSFileManager defaultManager]; // 文件大小 NSUInteger fileSize = 0; BOOL isDir = NO; if (![mgr fileExistsAtPath:self isDirectory:&amp;isDir]) return 0; //如果文件不存在直接退出 if (isDir) &#123; // 如果是文件夹 // 取出所有子文件 NSArray *subpaths = [mgr subpathsAtPath:self]; // 遍历所有子文件 for (NSString *subpath in subpaths) &#123; // 拼接拿到文件的全路径 NSString *fullSubPath = [self stringByAppendingPathComponent:subpath]; // 判断是否是文件夹 BOOL isDirectory = NO; if ([mgr fileExistsAtPath:fullSubPath isDirectory:&amp;isDirectory]) &#123; // 这个文件夹/文件存在 if (isDirectory == NO) &#123; // 是文件 fileSize += [[mgr attributesOfItemAtPath:fullSubPath error:nil][NSFileSize] integerValue]; &#125; &#125; &#125; &#125; else &#123; // 如果是文件 fileSize = [[mgr attributesOfItemAtPath:self error:nil][NSFileSize] integerValue]; &#125; return fileSize;&#125; 将字节单位转化为兆 NSString * (^fileSize)(NSUInteger) = ^(NSUInteger size) &#123; NSString *sizeStr = nil; // 拿到图片缓存, 将字节转为兆 float cacheSize = size / 1000; sizeStr = [NSString stringWithFormat:@"%d KB", (int)cacheSize]; if (((int)cacheSize / 1000)) &#123; cacheSize /= 1000; sizeStr = [NSString stringWithFormat:@"%.1f M", cacheSize]; &#125; else if (!cacheSize) &#123; sizeStr = @"没有缓存"; &#125; return sizeStr;&#125;; NSFileManager一些常用方法 判断一个文件或者文件夹是否存在BOOL flag = [manager fileExistsAtPath:@"/Users/apple/Desktop/abc.txt"]; 判断一个文件是否存在, 并且判断它是否是一个文件夹 注意: 该方法的返回值是说明传入的路径对应的文件或文件夹是否存在 第二个参数是用于保存判断结果的, 如果是一个目录, 那么就会赋值为YES, 如果不是就赋值为NO BOOL dir = NO; BOOL flag = [manager fileExistsAtPath:@"/Users/apple/Desktop/abc.txt" isDirectory:&amp;dir]; 获取文件或文件夹的属性 NSDictionary *info = [manager attributesOfItemAtPath:@"/Users/apple/Desktop/abc.txt" error:nil]; 获取文件夹中所有的文件 contentsOfDirectoryAtPath方法有一个弊端, 只能获取当前文件夹下所有的文件, 不能获取子文件夹下面的文件 subpathsOfDirectoryAtPath方法能够获取当前文件夹下的所有子文件和孙子文件. NSArray *res = [manager contentsOfDirectoryAtPath:@"/Users/apple/Desktop/video" error:nil]; NSArray *res = [manager subpathsOfDirectoryAtPath:@"/Users/apple/Desktop/video" error:nil]; 创建文件夹 createDirectoryAtPath: 告诉系统文件夹需要创建到什么位置 withIntermediateDirectories: 如果指定的文件中有一些文件夹不存在, 是否自动创建不存在的文件夹 attributes: 指定创建出来的文件夹的属性 error: 是否创建成功, 如果失败会给传入的参数赋值 注意: 该方法只能用于创建文件夹, 不能用于创建文件 BOOL flag = [manager createDirectoryAtPath:@"/Users/apple/Desktop/abc" withIntermediateDirectories:YES attributes:nil error:nil]; 创建文件 createFileAtPath: 指定文件创建出来的位置 contents : 文件中的内容 attributes: 创建出来的文件的属性 NSData : 二进制数据 注意: 该方法只能用于创建文件, 不能用于创建文件夹 NSString *str = @“我叫野原新之助”; NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];[manager createFileAtPath:@"/Users/apple/Desktop/abc.txt" contents:data attributes:nil];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[copy深浅的规律]]></title>
      <url>%2F2014%2F12%2F19%2Fdemonayu%2Fblog%2F18.copy%E6%B7%B1%E6%B5%85%E7%9A%84%E8%A7%84%E5%BE%8B%2F</url>
      <content type="text"><![CDATA[只有源对象和副本对象都不可变时，才是浅复制，其它都是深复制. 浅复制（浅拷贝，指针拷贝，shallow copy） 源对象和副本对象是同一个对象 源对象（副本对象）引用计数器+1,相当于做一次retain操作 本质是：没有产生新的对象 原对象引用计数器+1 必须对原对象进行释放 深复制（深拷贝，内容拷贝，deep copy） 源对象和副本对象是不同的两个对象 源对象引用计数器不变,副本对象计数器为1（因为是新产生的） 本质是：产生了新的对象 必须释放新对象]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重写可变数组的[removeObject:]方法]]></title>
      <url>%2F2014%2F10%2F18%2Fdemonayu%2Fblog%2F17.%E9%87%8D%E5%86%99%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84removeObject%3A%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[可变数组删除元素的原理: [NSMutableArray removeObject:obj]; 可变数组在调用removeObject:方法的时候会先去根类NSObject中调用isEqual:方法来遍历数组中所有对象的地址,来比对需要删除对象的地址,如果一样返回YES,如果不同返回NO.我们可以根据这个特性在子类中重写isEqual:方法来达到只要对象的某一个属性值一样就能删除掉这个对象的目的. 系统默认的做法 - (BOOL)isEqual:(Book *)other&#123; if (self == ohter) &#123; return YES; &#125; else &#123; return NO; &#125;&#125; 在子类中重写方法 - (BOOL)isEqual:(Book *)other&#123; // 比对两个对象的name属性值是否一样 return [self.name isEqualToString:other.name];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TableView顶部图片下拉放大]]></title>
      <url>%2F2014%2F09%2F13%2Fdemonayu%2Fblog%2F16.TableView%E9%A1%B6%E9%83%A8%E5%9B%BE%E7%89%87%E4%B8%8B%E6%8B%89%E6%94%BE%E5%A4%A7demo%2F</url>
      <content type="text"><![CDATA[实现tableView顶部图片下拉放大功能@interface ViewController () &lt;UITableViewDataSource, UITableViewDelegate&gt;@property (weak, nonatomic) IBOutlet UITableView *tableView;@property(nonatomic, weak) UIImageView *photoView;@end@implementation ViewControllerCGFloat photoViewWH;- (void)viewDidLoad &#123; [super viewDidLoad]; // 设定图片的宽高 photoViewWH = self.view.bounds.size.width; // 设置tableView内边距 self.tableView.contentInset = UIEdgeInsetsMake(photoViewWH * 0.5, 0, 0, 0); UIImageView *photoView = [[UIImageView alloc] init]; // 设置图片的位置,保证图片正好在tableView的上面不被覆盖 photoView.frame = CGRectMake(0, -photoViewWH, photoViewWH, photoViewWH); photoView.image = [UIImage imageNamed:@"photo"]; // 设置图片在photoView中的填充样式,ScaleAspectFill样式可以在图片size变大时,对图片等比例进行拉伸 photoView.contentMode = UIViewContentModeScaleAspectFill; // 将photoView插入到tableView的最底层 [self.tableView insertSubview:photoView atIndex:0]; _photoView = photoView;&#125;#pragma mark - UITableViewDataSource- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return 10;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *ID = @"cell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID]; &#125; cell.textLabel.text = [NSString stringWithFormat:@"测试数据&gt;&gt;&gt;%ld", indexPath.row]; return cell;&#125;#pragma mark - UIScrollViewDelegate- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; // 当tableView的偏移量的y值小于photoView高度的一半时,则不改变photoView的frame.因为偏移量是负数所以这里用加号 if (photoViewWH * 0.5 + scrollView.contentOffset.y &gt; 0) return; // 取出photoView的frame修改高度后重新赋值 CGRect frame = self.photoView.frame; frame.size.height = frame.size.height * 0.5 - scrollView.contentOffset.y; self.photoView.frame = frame;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebView代理方法拦截网络请求]]></title>
      <url>%2F2014%2F07%2F26%2Fdemonayu%2Fblog%2F15.WebView%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
      <content type="text"><![CDATA[拦截请求的一个重要代理方法这个代理方法是原生与网页之间的路由，通过这个方法可以拦截来自网页的请求。以下是截取出 URL 中想要的字符串来来进行 OAuth 认证。 // 拦截网络请求- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; // 1.取得请求路径 NSString *urlStr = request.URL.absoluteString; // 2.获取到是否有 code= 关键字 NSRange range = [urlStr rangeOfString:@"code="]; if (range.length != 0) &#123; // 3.截取code的值 NSUInteger fromIndex = range.location + range.length; NSString *code = [urlStr substringFromIndex:fromIndex]; // 4.发送一个post请求，来获取到access_token NSMutableDictionary *param = [NSMutableDictionary dictionary]; param[@"client_id"] = client_id; param[@"client_secret"] = client_secret; param[@"grant_type"] = @"authorization_code"; param[@"code"] = code; param[@"redirect_uri"] = redirect_uri; [HTTPTool POST:@"https://api.weibo.com/oauth2/access_token" parameters:param success:^(id JSON) &#123; // 将返回值转成模型并归档 AccountData *account = [AccountData accountDataWithDict:JSON]; [AccountTool accountSave:account]; &#125; failure:^(NSError *error) &#123; NSLog(@"%@", error); &#125;]; return NO; &#125; return YES;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UITableViewCell自定义布局子控件]]></title>
      <url>%2F2014%2F07%2F03%2Fdemonayu%2Fblog%2F14.UITableViewCell%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80%E5%AD%90%E6%8E%A7%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[TableView自定义cell的子控件布局有两种实现方式: 第一种是用传统的纯代码Frame设置; 第二种是用storyboard来设置. Frame实现自定义cell布局两个重要的setter方法: 在cellView重写StatusesFrame的setter方法给中cellView的每个子控件赋值 - (void)setStatusesFrame:(XVStatusesFrame *)statusesFrame&#123; _statusesFrame = statusesFrame; XVStatuses *status = statusesFrame.status; // 给子控件赋值 self.nameLabel.text = status.name; self.text_Label.text = status.text; self.iconView.image = [UIImage imageNamed:status.icon]; // 判断是否有图片 if (status.picture) &#123; self.pictureView.hidden = NO; self.pictureView.image = [UIImage imageNamed:status.picture]; &#125; else &#123; self.pictureView.hidden = YES; &#125; // 判断是否是vip if (status.isVip) &#123; self.vipView.hidden = NO; self.vipView.image = [UIImage imageNamed:@"vip"]; self.nameLabel.textColor = [UIColor orangeColor]; &#125; else &#123; self.vipView.hidden = YES; self.nameLabel.textColor = [UIColor blackColor]; &#125; // 设置子控件位置 self.nameLabel.frame = statusesFrame.nameLabelF; self.text_Label.frame = statusesFrame.text_LabelF; self.iconView.frame = statusesFrame.iconViewF; self.pictureView.frame = statusesFrame.pictureViewF; self.vipView.frame = statusesFrame.vipViewF;&#125; 在StatusesFrame模型中重写Status的setter方法,根据传进来的数据来算出各个子控件的frame,并返回给控制器来设置每个cell的高度 - (void)setStatus:(XVStatuses *)status&#123; _status = status; // 根据文字来计算UILabel的rect CGSize (^fontSize)(NSString*, CGFloat, CGFloat) = ^(NSString *text, CGFloat fontSize, CGFloat maxWidth) &#123; return [text boundingRectWithSize:CGSizeMake(maxWidth, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName : [UIFont systemFontOfSize:fontSize]&#125; context:nil].size; &#125;; // icon的位置 CGFloat iconViewW = 50; CGFloat iconViewH = 50; CGFloat iconViewX = margin; CGFloat iconViewY = margin; self.iconViewF = CGRectMake(iconViewX, iconViewY, iconViewW, iconViewH); // name的位置 CGSize nameSize = fontSize(status.name, nameFontSize, MAXFLOAT); CGFloat nameLabelW = nameSize.width; CGFloat nameLabelH = nameSize.height; CGFloat nameLabelX = CGRectGetMaxX(self.iconViewF) + margin; CGFloat nameLabelY = margin; self.nameLabelF = CGRectMake(nameLabelX, nameLabelY, nameLabelW, nameLabelH); // vip的位置 CGFloat vipViewW = 14; CGFloat vipViewH = nameLabelH; CGFloat vipViewX = CGRectGetMaxX(self.nameLabelF) + margin; CGFloat vipViewY = margin; self.vipViewF = CGRectMake(vipViewX, vipViewY, vipViewW, vipViewH); // text位置 CGFloat text_LabelW = [UIScreen mainScreen].bounds.size.width - 2 * margin; CGFloat text_LabelH = fontSize(status.text, textFontSize, text_LabelW).height; CGFloat text_LabelX = margin; CGFloat text_LabelY = CGRectGetMaxY(self.iconViewF) + margin; self.text_LabelF = CGRectMake(text_LabelX, text_LabelY, text_LabelW, text_LabelH); if (self.status.picture.length) &#123; // picture位置 CGFloat pictureVieW = 100; CGFloat pictureVieH = 100; CGFloat pictureVieX = margin; CGFloat pictureVieY = CGRectGetMaxY(self.text_LabelF) + margin; self.pictureViewF = CGRectMake(pictureVieX, pictureVieY, pictureVieW, pictureVieH); self.statusHeight = CGRectGetMaxY(self.pictureViewF) + margin; &#125; else &#123; self.statusHeight = CGRectGetMaxY(self.text_LabelF) + margin; &#125;&#125; 在代理方法中返回当前每个cell的高度 - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; XVStatusesFrame *frame = self.statusFrame[indexPath.row]; return frame.statusHeight;&#125; Storyboard实现自定义cell的布局 首先在使用storyboard布局单元格前先了解一下苹果在iOS8推出的Self Sizing Cells功能. Self Sizing Cells是为了解放程序员以往苦逼的计算不等高cell尺寸而推出的新功能, 它可以动态的计算tableView每一行cell的高度. Self Sizing Cells依赖于Auto Layout. 举一个例子来展示如何使用: 在storyboard中拖一个UITableView, 采用系统默认的设置, prototype cell数量设为1. 为cell中的每一个控件摆好位置并设置束缚 设置tableView的rowHeight属性为UITableViewAutomaticDimension // 设置自动计算高度self.tableView.rowHeight = UITableViewAutomaticDimension; 设置tableView的estimatedRowHeight估计高度为44(这个值可以根据自己需要修改) // 估算高度self.tableView.estimatedRowHeight = 44; 然后给cell中的每一个子控件赋值就能显示出来了, 不用做任何计算. - (void)setStatus:(XVStatuses *)status&#123; _status = status; self.nameLabel.text = status.name; self.text_Label.text = status.text; self.iconView.image = [UIImage imageNamed:status.icon]; // 判断是否有图片 if (status.picture.length ) &#123; self.pictureView.hidden = NO; // 根据控制束缚的值来控制控件的尺寸 self.pictureHeight.constant = 100; self.pictureBottom.constant = 10; self.pictureView.image = [UIImage imageNamed:status.picture]; &#125; else &#123; self.pictureHeight.constant = 0; self.pictureBottom.constant = 0; self.pictureView.hidden = YES; &#125; // 判断是否是vip if (status.vip) &#123; self.vipView.hidden = NO; self.vipView.image = [UIImage imageNamed:@"vip"]; self.nameLabel.textColor = [UIColor orangeColor]; &#125; else &#123; self.vipView.hidden = YES; self.nameLabel.textColor = [UIColor blackColor]; &#125;&#125; 注意: cell的高度是通过改变约束的长度来控制的.这里利用约束的优先级特性不能达到要求, 因为即使pictureView隐藏了但它身上的约束仍然生效. 如果要让低优先级的约束生效,必须要移除高优先级的控件或其上面的约束,但是这样在显示下一个cell的时候又需要重新添加约束.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQLite在iOS中的使用(下)]]></title>
      <url>%2F2014%2F06%2F21%2Fdemonayu%2Fblog%2F13.SQLite%E5%9C%A8iOS%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8(%E4%B8%8B)%2F</url>
      <content type="text"><![CDATA[使用数据库存储任意对象 使用FMDB框架来操作数据库 新建一个模型类,有name和price两个属性, 并导入FMDB头文件 #import "Shop.h"#import "FMDB.h" 在加载类的时候创建数据库 // 初始化一个FMDatabase类的对象static FMDatabase *_db;// 第一次使用类时+ (void)initialize&#123; // 1.数据库路径 NSString *path = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).lastObject stringByAppendingPathComponent:@"shop.sqlite"]; // 2.链接数据库 _db = [FMDatabase databaseWithPath:path]; // 3.打开数据库 [_db open]; // 4.建表 [_db executeUpdate:@"CREATE TABLE IF NOT EXISTS t_shop (id integer PRIMARY KEY, shop blob NOT NULL)"];&#125; 添加增/删/查方法 // 插入数据, 直接传入shop对象+ (void)insertObject:(id)object&#123; // 将对象转成NSData数据 NSData *data = [NSKeyedArchiver archivedDataWithRootObject:shop]; // 将data存进数据库 [_db executeUpdateWithFormat:@"INSERT INTO t_shop (shop) VALUES (%@);", data];&#125;// 删除所有数据+ (void)deleteAll&#123; [_db executeUpdateWithFormat:@"DELETE FROM t_shop;"];&#125;// 取出数据+ (NSArray *)shops&#123; NSMutableArray *array = [NSMutableArray array]; FMResultSet *set = [_db executeQuery:@"SELECT * FROM t_shop;"]; while (set.next) &#123; // 取出二进制数据 NSData *data = [set dataForColumn:@"shop"]; // 将二进制数据还原成对象 Shop *shop = [NSKeyedUnarchiver unarchiveObjectWithData:data]; // 将还原出来的对象存进数组 [array addObject:shop]; &#125; return array;&#125; 在shop.h中遵守 &lt; NSCoding &gt; 协议,并在shop.m中实现 encodeWithCoder: 和 initWithCoder: - (void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:self.name forKey:@"name"]; [aCoder encodeFloat:self.price forKey:@"price"];&#125;- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self.name = [aDecoder decodeObjectForKey:@"name"]; self.price = [aDecoder decodeFloatForKey:@"price"]; return self;&#125; 在控制器中直接调用模型方法就可以从数据库中得到数据了 // 存入对象- (void)save&#123; Shop *shop = [[Shop alloc] init]; shop.name = [NSString stringWithFormat:@"电脑"]; shop.price = 1999.9; // 存入数据 [Shop insertObject:shop];&#125;// 取- (void)read&#123; NSArray *array = [Shop shops]; for (Shop *shop in array) &#123; NSLog(@"%@", shop); &#125;&#125;// 删- (void)delete&#123; [Shop deleteAll];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQLite在iOS中的使用(上)]]></title>
      <url>%2F2014%2F06%2F18%2Fdemonayu%2Fblog%2F12.%E5%9C%A8iOS%E4%B8%AD%E4%BD%BF%E7%94%A8SQLite(%E4%B8%8A)%2F</url>
      <content type="text"><![CDATA[1. 什么是SQLite SQLite是一款轻型的嵌入式数据库, 它属于关系数据库 它的处理速度非常快,它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了. 如何使用SQLite 在iOS中要使用SQLite,必须先导入libsqlite3.dylib库.如图: 新建一个模型类, 并导入头文件 #import &lt;sqlite3.h&gt; 在实现方法中定义一个全局的静态变量 @implementation// 定义一个sqlite3类型的结构体指针(数据库对象)static sqlite3 *_db;@end 链接数据库, 创建表 // 首次调用这个类的时候链接数据库+ (void)initialize&#123; // 1&gt; 获取沙盒路径 NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject stringByAppendingPathComponent:@"computer.sqlite"]; // 2&gt; 根据路径打开数据库(相当于执行connection),传入数据库对象的地址,如果打开成功创建表. int result = sqlite3_open(path.UTF8String, &amp;_db); if (result != SQLITE_OK) &#123; // 打开数据库失败 // 关闭数据库 sqlite3_close(_db); NSLog(@"打开数据库失败"); &#125; else &#123; // 打开数据库成功 char *err; // 创表失败的错误信息 // 定义sql语句 const char *sql = "CREATE TABLE IF NOT EXISTS t_computer (ID INTEGER PRIMARY KEY, name TEXT, price REAL);"; // 3&gt; 执行sql语句,在数据库(_db)中建表 if (sqlite3_exec(_db, sql, NULL, NULL, &amp;err) != SQLITE_OK) &#123; NSLog(@"创表失败---%s", err); // 打印错误信息 &#125; else &#123; NSLog(@"创表成功"); &#125; &#125;&#125; 定义类方法来快速实现数据库的增\删\改\查 // 增 - 传一个名字和价格增加一条记录+ (void)insertDataWithName:(NSString *)name price:(float)price&#123; // 定义sql语句 NSString *str = [NSString stringWithFormat:@"INSERT INTO t_computer (name, price) VALUES ('%@', '%f');", name, price]; const char *sql = str.UTF8String; // 执行sql语句 sqlite3_exec(_db, sql, NULL, NULL, NULL);&#125; // 删 - 传入名字删除对应名字的记录+ (void)deletedDataWithName:(NSString *)name&#123; NSString *str = [NSString stringWithFormat:@"DELETE FROM t_computer WHERE name = '%@';", name]; const char *sql = str.UTF8String; sqlite3_exec(_db, sql, NULL, NULL, NULL);&#125; // 改 - 修改对应名字的价格+ (void)updatePrice:(float)price forName:(NSString *)name&#123; NSString *str = [NSString stringWithFormat:@"UPDATE t_computer SET price = '%f' WHERE name = '%@';", price, name]; const char *sql = str.UTF8String; sqlite3_exec(_db, sql, NULL, NULL, NULL);&#125; // 查 - 取出数据库中所有的数据并将每一个字段转成模型的属性值存入数组返回出去+ (NSArray *)computers&#123; // 创建一个可变数组来接收模型 NSMutableArray *arrayM = [NSMutableArray array]; // 定义sql语句 const char *sql = [NSString stringWithFormat:@"SELECT * FROM t_computer;"].UTF8String; // 用来接收数据库查询的所有内容 sqlite3_stmt *stmt = NULL; // 如果查询到数据 if (sqlite3_prepare_v2(_db, sql, -1, &amp;stmt, nil) == SQLITE_OK) &#123; // 传入所有查询结果(stmt),逐步检索每一条记录,一直往下查找,直到SQLITE_ROW为null while (sqlite3_step(stmt) == SQLITE_ROW) &#123; XVComputers *computer = [[XVComputers alloc] init]; // 取出查找的值并赋给模型 computer.name = [NSString stringWithUTF8String:(char *)sqlite3_column_text(stmt, 1)]; computer.price = sqlite3_column_double(stmt, 2); // 将赋值后的对象放进数组 [arrayM addObject:computer]; &#125; &#125; return arrayM;&#125; 2. FMDB 什么是FMDB FMDB是iOS平台的SQLite数据库框架 FMDB以OC的方式封装了SQLite的C语言API FMDB的优点 使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码 对比苹果自带的Core Data框架，更加轻量级和灵活 提供了多线程安全的数据库操作方法，有效地防止数据混乱 项目地址: FMDB 如何使用FMDB 在Xcode中导入libsqlite3.dylib动态链接库 新建一个模型类导入框架的头文件 #import "FMDB.h" 在实现方法中定义一个全局的静态变量 @implementation// 创建一个FMDatabase对象static FMDatabase *_db;@end 链接数据库,建表 + (void)initialize&#123; // 文件路径 NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject stringByAppendingPathComponent:@"cmpt.sqlite"]; // 链接数据库 _db = [FMDatabase databaseWithPath:path]; // 打开数据库 [_db open]; // 建表 [_db executeUpdate:@"CREATE TABLE IF NOT EXISTS t_cmpt (id INTEGER PRIMARY KEY, name TEXT, price REAL);"];&#125; 实现增\删\改\查 框架中的增删改都是用的 executeUpdate 方法 // 插入数据+ (void)insertName:(NSString *)name price:(float)price&#123; // 注意在这个框架中sql语句中的字符串占位符不需要加单引号 [_db executeUpdateWithFormat:@"INSERT INTO t_cmpt (name, price) VALUES (%@, %f)", name, price];&#125; // 删除数据+ (void)deleteAll&#123; [_db executeUpdateWithFormat:@"DELETE FROM t_cmpt"];&#125; 查询使用的是 executeQuery 方法 // 查询数据并返回模型数组+ (NSArray *)computers&#123; // 返回一个查询到的结果集 FMResultSet *set = [_db executeQuery:@"SELECT * FROM t_cmpt;"]; // 创建一个可变数组来存放模型 NSMutableArray *arrM = [NSMutableArray array]; // 在集中往下查询每一条记录 while ([set next]) &#123; XVComputers *computer = [[XVComputers alloc] init]; computer.name = [set stringForColumn:@"name"]; computer.price = [set stringForColumn:@"price"].floatValue; [arrM addObject:computer]; &#125; return arrM;&#125; FMDatabaseQueue FMDatabase这个类是线程不安全的，如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题. 为了保证线程安全，FMDB提供方便快捷的FMDatabaseQueue类. // 创建一个FMDatabaseQueue队列NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject stringByAppendingPathComponent:@"cmpt.sqlite"];FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:path];// 执行队列[queue inDatabase:^(FMDatabase *db) &#123; // 写数据 [db executeUpdate:@"INSERT INTO t_cpmt (name) VALUES (?)", @"惠普"]; [db executeUpdate:@"INSERT INTO t_cpmt (name) VALUES (?)", @"戴尔"]; [db executeUpdate:@"INSERT INTO t_cpmt (name) VALUES (?)", @"华硕"]; // 取数据 FMResultSet *set = [db executeQuery:@"select * from t_cpmt"]; while ([set next]) &#123; //... &#125;&#125;];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[直接修改对象frame结构体中的成员属性]]></title>
      <url>%2F2014%2F04%2F16%2Fdemonayu%2Fblog%2F11.%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%B1%A1frame%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[在iOS中系统默认不能直接修改结构体成员属性的值, 通过添加分类来实现这个功能. 头文件(.h) #import &lt;UIKit/UIKit.h&gt;@interface UIView (Extension)@property (nonatomic, assign) CGFloat x;@property (nonatomic, assign) CGFloat y;@property (nonatomic, assign) CGFloat centerX;@property (nonatomic, assign) CGFloat centerY;@property (nonatomic, assign) CGFloat width;@property (nonatomic, assign) CGFloat height;@property (nonatomic, assign) CGSize size;@property (nonatomic, assign) CGPoint origin;@end 实现文件(.m) #import "UIView+Extension.h"@implementation UIView (Extension)- (void)setX:(CGFloat)x&#123; CGRect frame = self.frame; frame.origin.x = x; self.frame = frame;&#125;- (void)setY:(CGFloat)y&#123; CGRect frame = self.frame; frame.origin.y = y; self.frame = frame;&#125;- (CGFloat)x&#123; return self.frame.origin.x;&#125;- (CGFloat)y&#123; return self.frame.origin.y;&#125;- (void)setCenterX:(CGFloat)centerX&#123; CGPoint center = self.center; center.x = centerX; self.center = center;&#125;- (void)setCenterY:(CGFloat)centerY&#123; CGPoint center = self.center; center.y = centerY; self.center = center;&#125;- (CGFloat)centerX&#123; return self.center.x;&#125;- (CGFloat)centerY&#123; return self.center.y;&#125;- (void)setWidth:(CGFloat)width&#123; CGRect frame = self.frame; frame.size.width = width; self.frame = frame;&#125;- (void)setHeight:(CGFloat)height&#123; CGRect frame = self.frame; frame.size.height = height; self.frame = frame;&#125;- (CGFloat)height&#123; return self.frame.size.height;&#125;- (CGFloat)width&#123; return self.frame.size.width;&#125;- (void)setSize:(CGSize)size&#123; CGRect frame = self.frame; frame.size = size; self.frame = frame;&#125;- (CGSize)size&#123; return self.frame.size;&#125;- (void)setOrigin:(CGPoint)origin&#123; CGRect frame = self.frame; frame.origin = origin; self.frame = frame;&#125;- (CGPoint)origin&#123; return self.frame.origin;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AutoLayout的简单使用]]></title>
      <url>%2F2014%2F04%2F15%2Fdemonayu%2Fblog%2F10.AutoLayout%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[AutoResizing AutoResizing可以用作屏幕适配,但只能设置自身与父控件之间的相对关系,局限性很大. AutoResizing是UIView的一个成员属性. AutoResizing可用于控件关系简单的轻量的屏幕适配. AutoResizing与AutoLayout是互斥的.// scrollView的宽高可伸缩, 意思就是scrollView的宽高与父控件宽高始终一致self.scrollView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;// pageController的顶部间隙与宽高可伸缩, 意思就是把控件固定在父控件底部, 宽度随父控件的宽度而变化self.pageController.autoresizingMask = UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleWidth; AutoLayout Autolayout是一种“自动布局”技术，专门用来布局UI界面. Autolayout的2个核心概念 约束:通过给控件添加约束,来决定控件的位置和尺寸 参照:在添加约束时,是依照谁来添加(可以是父控件或者兄弟控件) 添加约束的规则 对于有层次关系的两个view之间的约束关系，添加到层次较高的父view上 对于两个同层级view之间的约束关系，添加到它们的父view上 对于两个不同层级view之间的约束关系，添加到他们最近的共同父view上 StoryBorad 中实现AutoLayout 添加新的约束 设置对齐 更新frame和约束 修改单个约束属性 Autolayout的警告和错误 警告 控件的frame不匹配所添加的约束,比如约束控件的宽度为100, 而控件现在的宽度是110. 错误 缺乏必要的约束, 比如只约束了宽度和高度, 没有约束具体的位置. 两个约束冲突, 比如1个约束控件的宽度为100, 1个约束控件的宽度为110. 代码实现AutoLayout 如果使用了自动布局就不用再给view设置frame 使用AutoLayout要先禁止autoresizing功能，设置view的下面属性为NO 创建约束对象的常用方法 view1 ：要约束的控件 attr1 ：约束的类型（做怎样的约束） relation ：与参照控件之间的关系 view2 ：参照的控件 attr2 ：约束的类型（做怎样的约束） multiplier ：乘数 c ：常量+ (id)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c; 示例: 给一个view添加约束 // 1.创建红色的view添加到控制器中UIView *redView = [[UIView alloc] init];redView.backgroundColor = [UIColor redColor];// 禁止autoresizing自动转为autolayout的约束redView.translatesAutoresizingMaskIntoConstraints = NO;[self.view addSubview:redView];// 2.添加约束 - 利用NSLayoutConstraint类创建具体的约束对象// 宽度约束NSLayoutConstraint *wLc = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:0.0 constant:100];[redView addConstraint:wLc];// 高度约束NSLayoutConstraint *hLc = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:0.0 constant:100];[redView addConstraint:hLc];// 右边约束NSLayoutConstraint *rightLc = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeRight relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeRight multiplier:1.0 constant:-20];[self.view addConstraint:rightLc];// 底部约束NSLayoutConstraint *bottomLc = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeBottom multiplier:1.0 constant:-20];[self.view addConstraint:bottomLc]; VFL语言实现autolayout VFL全称是Visual Format Language, 翻译过来是“可视化格式语言”, 它是苹果公司为了简化Autolayout的编码而推出的抽象语言. 使用VFL来创建约束数组 format ：VFL语句 opts ：约束类型 metrics ：VFL语句中用到的具体数值 views ：VFL语句中用到的控件 + (NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(NSDictionary *)metrics views:(NSDictionary *)views; 示例: 给一个view添加约束 // 1.创建红色的view添加到控制器中UIView *redView = [[UIView alloc] init];redView.backgroundColor = [UIColor redColor];// 禁止autoresizing自动转为autolayout的约束redView.translatesAutoresizingMaskIntoConstraints = NO;[self.view addSubview:redView];// 2.设置约束 // 束缚规则 // 水平方向NSDictionary *views = @&#123;@"redView" : redView&#125;;NSDictionary *metrics = @&#123;@"space" : @30&#125;; // 要执行的VFL语言 - 这句话表示:水平方向上，redView与父控件左右边缘的距离NSString *vfl_h = @"H:|-space-[redView]-space-|";NSArray *hLcs = [NSLayoutConstraint constraintsWithVisualFormat:vfl_h options:kNilOptions metrics:metrics views:views];[self.view addConstraints:hLcs]; // 垂直方向 // 垂直方向上，redView与父控件底部边缘的距离NSString *vfl_v = @"V:[redView(40)]-space-|";NSArray *vLcs = [NSLayoutConstraint constraintsWithVisualFormat:vfl_v options:kNilOptions metrics:metrics views:views];[self.view addConstraints:vLcs]; PS : 创建一个字典（内部包含VFL语句中用到的控件）的快捷宏定义 NSDictionaryOfVariableBindings(...) Masonry框架的简单使用 目前最流行的Autolayout第三方框架, 用优雅的代码方式编写Autolayout, 省去了苹果官方恶心的Autolayout代码, 大大提高了开发效率 项目地址: Masonry //define this constant if you want to use Masonry without the 'mas_' prefix#define MAS_SHORTHAND//define this constant if you want to enable auto-boxing for default syntax#define MAS_SHORTHAND_GLOBALS#import "ViewController.h"// 导入框架头文件#import "Masonry.h"@interface ViewController ()@property (nonatomic, weak) UIView *blueView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; /* 添加三个View */ UIView *redView = [[UIView alloc] init]; redView.backgroundColor = [UIColor redColor]; [self.view addSubview:redView]; UIView *blueView = [[UIView alloc] init]; blueView.backgroundColor = [UIColor blueColor]; [self.view addSubview:blueView]; _blueView = blueView; UIView *greenView = [[UIView alloc] init]; greenView.backgroundColor = [UIColor greenColor]; [self.view addSubview:greenView]; // 给redView添加约束 [redView makeConstraints:^(MASConstraintMaker *make) &#123; // 设置宽高 make.width.height.equalTo(100); // 不写参照,默认参照为父控件 // 设置左边约束偏移量 make.left.equalTo(20); // 设置底部约束偏移量 make.bottom.equalTo(-20); &#125;]; // 给blueView添加约束 [blueView makeConstraints:^(MASConstraintMaker *make) &#123; make.width.height.equalTo(redView); make.left.equalTo(redView.right).offset(20); // 以redView为参照 make.bottom.equalTo(redView); &#125;]; // 给greenView添加约束 [greenView makeConstraints:^(MASConstraintMaker *make) &#123; make.width.height.equalTo(redView); make.left.equalTo(blueView.right).offset(20); // 以blueView为参照 make.bottom.equalTo(redView); // 设置优先级 - 当优先级较高的约束失效后优先级低的约束生效 make.left.equalTo(redView.right).offset(20).priorityLow(); &#125;];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 移除blueView使greenView的另一条约束生效 [self.blueView removeFromSuperview]; // 执行动画 [UIView animateWithDuration:0.5 animations:^&#123; // 强制刷新控件 [self.view layoutIfNeeded]; &#125;]; // 更新约束 // [self.greenView updateConstraints:^(MASConstraintMaker *make) &#123; // make.left.equalTo(self.redView.right).offset(20); // &#125;];&#125; PS: AutoLayout 关于更新约束的几个方法 setNeedsLayout: 告知页面需要更新,但是不会立刻开始更新,执行后会立刻调用layoutSubviews. layoutIfNeeded: 告知页面布局立刻更新.所以一般都会和setNeedsLayout一起使用.如果希望立刻生成新的frame需要调用此方法,利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效. layoutSubviews: 系统重写布局. setNeedsUpdateConstraints: 告知需要更新约束,但是不会立刻开始. updateConstraintsIfNeeded: 告知立刻更新约束. updateConstraints:系统更新约束.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单的首尾式动画]]></title>
      <url>%2F2014%2F03%2F18%2Fdemonayu%2Fblog%2F09.%E9%A6%96%E5%B0%BE%E5%BC%8F%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[在iOS的中实现首尾式动画是一件很简单的事情, 只需要几行代码搞定. 1. 实现渐变动画 在控制器中新建一个监听手势点击的方法. - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;&#125; 在方法中添加一个UIView, 当然UIImageView,UILabel都可以, 只要继承自UIView就OK. // 子控件的初始状态UIView *animationView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 50, 50)];animationView.center = self.view.center;// 初始化view的alpha为0.0,它是一个实型,可以理解成透明度,当控件alpha的为0时是全透明,不可见且不可交互.// 使用alpha可以实现渐隐的动画效果animationView.alpha = 0.0;animationView.backgroundColor = [UIColor redColor];// 将控件添加进父控件[self.view addSubview:animationView]; 实现动画效果 // 1. 开始动画[UIView beginAnimations:nil context:nil];// 2. 动画时长NSTimeInterval time = 2.0;[UIView setAnimationDuration:time];// 3. 需要动画执行完毕后控件的状态animationView.bounds = CGRectMake(0, 0, 300, 300);// 改变alpha值实现渐隐效果animationView.alpha = 0.8;// 4. 提交动画[UIView commitAnimations]; 这样我们新创建的控件会伴有动画效果显示出来并且一直待在父控件上. 用block来是实现动画效果 [UIView animateWithDuration:2.0 animations:^&#123; // 控件的最终状态 animationView.frame = CGRectMake(0, 0, 50, 50); animationView.center = self.view.center; animationView.alpha = 0.0;&#125;]; 2. 实现首尾式动画 实现提示框(hub)那种类型的首尾式动画效果 (显示后立即消失). block嵌套实现首尾式动画 将上面实现动画的代码替换成下面的代码: // delay: 表示动画需要延时多少秒后执行// options: 可以选择动画在执行过程中方式(比如先快后慢等等)[UIView animateWithDuration:2.0 delay:0 options:UIViewAnimationOptionCurveEaseInOut animations:^&#123; // 第一阶段动画执行完毕后的控件状态 animationView.frame = CGRectMake(0, 0, 300, 300); animationView.center = self.view.center; animationView.alpha = 0.8;&#125; completion:^(BOOL finished) &#123; // 第一阶段动画执行完毕后 // 控件的最终状态 [UIView animateWithDuration:2.0 animations:^&#123; // 第二阶段动画并显示控件最终状态 animationView.frame = CGRectMake(0, 0, 50, 50); animationView.center = self.view.center; animationView.alpha = 0.0; &#125;];&#125;]; 这个子控件会在两秒钟内放大并显示,然后在两秒钟后缩小消失. ps: 首尾式动画是显式动画.pps: 能够实现动画的属性基本都是实型,像BOOL类型的属性就不能用来显示动画效果.ppps: 每个UIView都是由图层来显示图像的, 也就是说每个UIView中都有一个CALayer成员变量,来显示图像, 而且这个成员变量是不可交互的, 改变自定义图层的属性, 可以触发隐式动画.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[了解一下KVC和KVO]]></title>
      <url>%2F2014%2F03%2F16%2Fdemonayu%2Fblog%2F08.KVC%E5%92%8CKVO%2F</url>
      <content type="text"><![CDATA[KVCKVC的一般使用 全称：Key Value Coding（键值编码） 赋值 // 能修改私有成员变量- (void)setValue:(id)value forKey:(NSString *)key;- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;- (void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues; 取值 // 能取得私有成员变量的值- (id)valueForKey:(NSString *)key;- (id)valueForKeyPath:(NSString *)keyPath;- (NSDictionary *)dictionaryWithValuesForKeys:(NSArray *)keys; KVC的底层原理 KVC的本质就是调用成员属性的setter和getter方法. setValuesForKeysWithDictionary:方法的底层实现 // 遍历字典给对应模型的成员属性赋值(key值就是成员属性名) [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; [item setValue:obj forKeyPath:key]; &#125;]; setValue:forKeyPath:的底层实现: 调用key对应成员属性名的setter方法; 如果找不到,找带下划线(_)的成员属性名,然后给这个成员属性直接赋值. 如果找不到,找与key名完全相同的成员属性名,然后直接赋值. 如果都找不到,则程序崩溃,报错找不到对应的成员属性. ps: 可以利用KVC的实现原理来重写赋值过程 容器操作符:KVC还提供了一些复杂的函数操作符,比如: NSArray *array = @[@"aba",@"cbc",@"dvd"];NSUInteger totalLenth = [[array valueForKeyPath:@"@sum.length"] intValue]; 其中key值里面包含的@sum就是一个操作符, 能够对指定的属性(length)求和.类似数据操作的还有:@avg平均值, @count 总数, @max最大, @min最小.注:以上这些操作符只能用于集合(如:NSArray). KVOKVO的一般使用 全称：Key Value Observing（键值监听） 作用：监听模型的属性值改变 步骤 添加监听器 // 利用b对象来监听a对象name属性的改变[a addObserver:b forKeyPath:@"name" options:NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:@"test"]; 在监听器中实现监听方法 -(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; NSLog(@"%@ %@ %@ %@", object, keyPath, change, context);&#125; 举例: // 1&gt; 在控制器中创建和初始化成员变量self.person = [[Person alloc] initWithName:@"Xion" age:23];// 2&gt; 添加观察者 self.person将控制器添加为监听自己的观察者,来观察age属性的改变[self.person addObserver:self forKeyPath:@"age" options:0 context:nil]; // 添加一个button操作来修改成员变量的值- (void)buttonClick&#123; // 改变成员变量属性值 self.person.age += 5;&#125; // 3&gt; 控制器监听值的改变- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123; // 当监听的值为age, 且监听的对象为self.person if ([keyPath isEqualToString:@"age"] &amp;&amp; object == self.person) &#123; // 更新显示 self.label.text = [NSString stringWithFormat:@"%@现在的年龄是%lu", _person.name, _person.age]; &#125;&#125; KVO的底层原理 一句话概括: 系统利用runtime动态添加一个被监听类(以NSKVONotifying_开头)的子类, 在该子类中重写需要被监听key值的setter方法,在内部调用willChangeValueForKey: didChangeValueForKey:方法来监听key值得变化. ps:苹果不希望这个机制暴露在外部.除了setters,这个动态生成的子类同时也重写了-class方法,依旧返回原先的class!如果不仔细看的话,被KVO过的object看起来和原先的object没什么两样. 参考建议: (译)KVO的内部实现, objc kvo简单探索.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用NSValue来包装结构体]]></title>
      <url>%2F2014%2F03%2F14%2Fdemonayu%2Fblog%2F07.%E5%88%A9%E7%94%A8NSValue%E6%9D%A5%E5%8C%85%E8%A3%85%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
      <content type="text"><![CDATA[NSValue可以包装任意值,可以用NSValue将结构体包装后,加入NSArray\NSDictionary中. 利用NSValue包装常用结构体 CGPoint point = NSMakePoint(100, 100);NSValue *value = [NSValue valueWithPoint:point];NSArray *arr = @[value]; 利用NSValue包装自定义结构体 typedef struct &#123; int age; char *name; double height;&#125;Person;Person p = &#123;24, "XiaoMing", 183&#125;;// valueWithBytes: 接收一个指针, 传递需要包装的结构体的地址.// objCType: 需要包装的数据类型NSValue *pValue = [NSValue valueWithBytes:&amp;p objCType:@encode(Person)];NSArray *arr = @[pValue];// 从NSValue中取出自定义的结构体变量Person res;[pValue getValue:&amp;res]; 常见的结构体包装方法 将结构体包装成NSValue对象 + (NSValue *)valueWithPoint:(NSPoint)point;+ (NSValue *)valueWithSize:(NSSize)size;+ (NSValue *)valueWithRect:(NSRect)rect; 从NSValue中取出包装的结构体 - (NSPoint)pointValue;- (NSSize)sizeValue;- (NSRect)rectValue; NSValue包装任意数据类型 // value参数 : 所包装数据的地址// type参数 : 用来描述这个数据类型的字符串, 用@encode指令来生成+ (NSValue *)valueWithBytes:(const void *)value objCType:(const char *)type;// 从NSValue中取出所包装的数据- (void)getValue:(void *)value;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个应用程序的启动流程]]></title>
      <url>%2F2014%2F03%2F07%2Fdemonayu%2Fblog%2F06.%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[应用程序完整启动流程 执行Main函数. 在main函数中调用UIApplicationMain函数. int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 创建UIApplication对象,并设置UIApplicationMain对象的代理. UIApplicationMain的第三个参数就是UIApplication的名称,如果指定为nil,它会默认为UIApplication.(nil == @”UIApplication”); UIApplicationMain的第四个参数为UIApplication的代理. 开启一个主运行循环,保证应用程序不退出. 加载info.plist程序配置文件.判断info.plist文件当中的key:[Main storyboard file base name]有没有指定storyboard文件,如果有就去加载storyboard文件,如果没有,那么应用程序加载完毕. UIApplication UIApplication类提供了对运行在iOS设备上的app集中控制和调度的机制.每一个app有且只有一个UIApplication或者其子类的实例.当程序启动的时候,会调用UIApplicationMain函数,在这个函数中会创建一个UIApplication类的单例,这个单例在整个iOS系统中就是app的抽象.之后你就能够通过shareApplication方法来调用该单例. UIApplication对象的主要工作是处理用户事件的路由.它也会给UIcontrol对象分发动作消息.另外,UIApplication还维护了当前App打开的窗口的列表.所以,你通过它能够取到你App中任何一个View. 这个app实例还实现了一个delegate,接受各种各样程序运行时的事件,比如: 程序启动、低内存警告、程序崩溃等等. 程序还能通过openURL: 方法来接受和处理一个邮件或者图片文件.比如一个以Email开头的URL将能够唤起Email程序来展示这个邮件. UIApplication的编程接口让你能够管理一些硬件指定的行为.比如: 控制App来响应设备方向变化 暂时终止接受触摸事件 打开或者关闭接近用户脸部的感应 注册远程消息通知 打开或者关闭undo-redo UI 决定你的程序是否能够支持某一类的URL 扩展程序能力,让app能够在后台运行 发布或者取消本地通知 接受运程控制事件 执行程序级别的复位操作 UIApplication必须实现UIApplicationDelegate协议来实现他的一些协议. UIApplication的一些功能具体使用 设置应用的监听权限 // 获取当前iOS版本号float sysVersion = [[UIDevice currentDevice] systemVersion].floatValue;// iOS8以后必须要获取通知权限才能显示applicationIconBadgeNumberif (sysVersion &gt;= 8.0) &#123; UIUserNotificationType type = UIUserNotificationTypeBadge | UIUserNotificationTypeAlert | UIUserNotificationTypeSound; UIUserNotificationSettings *setting = [UIUserNotificationSettings settingsForTypes:type categories:nil]; [[UIApplication sharedApplication] registerUserNotificationSettings:setting];&#125; 网络提醒(连接网络提示) application.networkActivityIndicatorVisible = YES; 设置状态栏 // 隐藏状态栏[[UIApplication sharedApplication] setStatusBarHidden:YES withAnimation:YES];// 状态栏样式application.statusBarStyle = UIStatusBarStyleLightContent; 应用程序的状态栏默认是控制器来管理, 但是通常在开发当中都设置为应用程序来统一管理状态栏. 在info.plist当中进行配置:View controller-based status bar appearance : NO 跳转页面// 打开网页[application openURL:[NSURL URLWithString:@"http://www.baidu.com"]];// 跳转到打电话[application openURL:[NSURL URLWithString:@"tel://10000"]];// 跳转到发短信[application openURL:[NSURL URLWithString:@"sms://10000"]]; 应用程序的生命周期 应用程序启动完成 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; NSLog(@"应用程序启动了"); NSLog(@"UIApplication调用了我"); return YES;&#125; 应用程序即将失去焦点 - (void)applicationWillResignActive:(UIApplication *)application &#123; NSLog(@"我退出了");&#125; 应用程序完全进入后台 - (void)applicationDidEnterBackground:(UIApplication *)application &#123; NSLog(@"进入后台");&#125; 应用程序即将进入前台 - (void)applicationWillEnterForeground:(UIApplication *)application &#123; NSLog(@"我回来了");&#125; 应用程序重新获得焦点 - (void)applicationDidBecomeActive:(UIApplication *)application &#123; NSLog(@"我刷新了");&#125; 应用程序即将关闭 - (void)applicationWillTerminate:(UIApplication *)application &#123; NSLog(@"我拜拜了");&#125; 应用程序显示流程 创建一个窗口 (UIWindow, 系统已经默认创建这个成员属性, 需要手动初始化) 创建根控制器 (rootViewController) 给窗口设置根控制器 (window.rootViewController) 显示窗口(makeKeyAndVisible).makeKeyAndVisible方法 : 把窗口设置为应用程序的主窗口. 窗口默认是隐藏的,当调用该方法后, 会设置窗口的hidden = no, 并把这个窗口设置为主窗口并显示. - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 1.创建UIWindow self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; self.window.backgroundColor = [UIColor whiteColor]; // 2.初始化根控制器 ViewController *vc = [[ViewController alloc] init]; // 3.设置窗口根控制器 self.window.rootViewController = vc; // 4.把UIWindow 设为当前窗口 [self.window makeKeyAndVisible]; return YES;&#125; ps: window的显示与根控制器中view的显示互不影响. view在window的上面. 控制器view的显示流程 先判断控制器是不是从storyboard中加载. UIViewController *vc = [[UIStoryboard storyboardWithName:@"Main" bundle:nil] instantiateInitialViewController]; 再判断是不是从xib中加载 UIViewController *vc = [[UIViewController alloc] initWithNibName:@"VC" bundle:nil];// 1&gt; initWithNibName:如果指定了名称,那么它就会去加载指定名称的Xib.// MyViewController *vc = [[MyViewController alloc] initWithNibName:@"VC" bundle:nil];// 2&gt; 如果没有指定名称.指定为nil,那么它就会去先加载跟它相同名称的Xib.// MyViewController *vc = [[MyViewController alloc] initWithNibName:nil bundle:nil];// 3&gt; 如果没有跟它名称相同的Xib,那么它就会去加载去掉Controller后跟它名称相同的Xib ps: 控制器的init方法默认会调用initWithNibName:方法. 如果都不是,控制器会调用loadView方法,创建一个空的UIView. // 当控制器被使用的时候,控制器会调用loadView方法.loadView --&gt; viewDidLoad- (void)loadView&#123; self.view = [[UIView alloc] initWithFrame:[UIScreen mainScreen].bounds];&#125; 附:在Xcode6以后配置pch文件 在pch文件中配置调试模式时运行XWLog(…)代码: #ifdef DEBUG#define XWLog(...) NSLog(__VA_ARGS__)#else#define XWLog(...)#endif ps: 在宏当中...表示可变参数.在函数中表示可变参数用:__VA_ARGS__. 拓展阅读: iOS应用程序的生命周期.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[监听事件的4种方式]]></title>
      <url>%2F2014%2F02%2F16%2Fdemonayu%2Fblog%2F05.%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[OC中监听事件的4种方法 通知（NSNotificationCenter\NSNotification） 任何对象之间都可以传递消息 1个对象可以发通知给多个对象 1个对象可以接受多个对象发出的通知 要求:必须得保证通知的名字在发出和监听时是一致的 KVO 仅仅是能监听对象属性的改变（灵活度不如通知和代理） 只能作用在单个文件 代理 协议就是接口, 提供方法的声明来给代理去实现. 1个对象只能设置一个代理(假设这个对象只有1个代理属性) 1个对象能成为多个对象的代理 target 继承UIControl的类都能使用addTarget方法来监听事件 必须在控件创建时就添加监听行为 一个对象只能监听一个事件点击 只能作用在单个文件 如何选择? target用于监听控件的点击/长按等触发事件 通知适用于层级很深或者两个没有关联的类之间的事件监听 KVO适用于监听对象某个属性的改变 代理比通知规范,建议使用代理多于通知,能使用代理尽量使用代理 监听方式的核心代码 通知notificationName: 通知内容(key)object: 通知发布者userInfo: 发布者附带的信息 // 发布通知[[NSNotificationCenter defaultCenter] postNotificationName:key object:object userInfo:userInfo]; observer: 监听者selector: 监听后执行的方法name: 通知内容(key)object: 通知发布者 // 添加监听者[[NSNotificationCenter defaultCenter] addObserver:observer selector:@selector(selector:) name:name object:object]; 注意: 有添加就要有移除, 一般移除监听写在dealloc方法中 // 移除监听[[NSNotificationCenter defaultCenter] removeObserver:self]; KVOobject: 被监听者observer: 监听者keyPath: 被监听者的属性options: 监听模式(内容)context: 上下文 // 添加监听[object addObserver:observer forKeyPath:keyPath options:options context:context]; keyPath: 被监听的属性object: 被监听的对象change: 被监听属性值的改变情况(字典)context: 上下文 // 实现监听方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123; // 监听当_per这个成员变量的age这个属性发生改变时 if ([keyPath isEqualToString:@"age"] &amp;&amp; object == _person) &#123; // 给控制器的成员变量赋新值 self.label.text = [NSString stringWithFormat:@"%@现在的年龄是%lu", _person.name, _person.age]; &#125;&#125; 代理@required: 代理方法必须实现(默认)@optional: 代理方法选择实现 // 定义协议@protocol XVFooterBarDelegate&lt;NSObject&gt;@optional- (void)footbarValueChanged:(XVFooterBar *)footbar;@end // 添加代理@property(nonatomic, weak) id&lt;XVFooterBarDelegate&gt; delegate; - (void)cleanBuy&#123; // 添加代理的事件监听 if ([self.delegate respondsToSelector:@selector(footbarValueChanged:)]) &#123; [self.delegate footbarValueChanged:self]; &#125;&#125; // 在代理的类中实现代理方法 - (void)footbarValueChanged:(XVFooterBar *)footbar&#123; // ....&#125; targettarget: 监听者action: 要执行的方法controlEvents:触发事件 // 添加监听- (void)addTarget:(nullable id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TableView中MVC模式的简单应用]]></title>
      <url>%2F2014%2F01%2F13%2Fdemonayu%2Fblog%2F04.%E6%A8%A1%E5%9E%8B%E6%8E%A7%E5%88%B6View%E7%9A%84%E6%98%BE%E7%A4%BAdemo%2F</url>
      <content type="text"><![CDATA[模型视图控制器之间: 模型与视图互不干涉, 由控制器来处理模型, 然后将模型传给视图显示. 模型决定视图的显示内容而不是控制器, 控制器负责修改模型和传递模型. 人机之间的交互由控制器完成 视图和模型互不干扰. 作用: 便于代码的管理和阅读 用控制器来管理模型和视图, 通过修改模型来改变显示内容. 以tableView自定义cell为例: 自定义一个cell (View) // 重写构造方法- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier&#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if (self) &#123; UIImageView *checkImg = [[UIImageView alloc] init]; checkImg.image = [UIImage imageNamed:@"check"]; checkImg.hidden = YES; [self addSubview:checkImg]; _checkImg = checkImg; &#125;return self;&#125;// 快速创建一个cell+ (instancetype)cellWithTable:(UITableView *)tableView&#123;static NSString *ID = @"cell";XVWineCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (cell == nil) &#123; cell = [[XVWineCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID]; &#125;return cell;&#125; 在控制器中实现数据源协议, 将自定义cell作为tableView的cell显示, 并将模型传递给cell (Controller) - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; XVWineCell *cell = [XVWineCell cellWithTable:tableView]; cell.wine = self.wine[indexPath.row]; return cell;&#125; 在自定义cell类中重写模型属性的setter方法,给cell中的子控件赋值 (Model) - (void)setWine:(XVWine *)wine&#123; _wine = wine; self.imageView.image = [UIImage imageNamed:wine.image]; self.textLabel.text = wine.name; self.detailTextLabel.text = [NSString stringWithFormat:@"￥%@", wine.money]; self.detailTextLabel.textColor = [UIColor orangeColor];&#125; 在控制器中修改模型数据刷新tableView, 这时会来到控制器的数据源方法将所有的cell重新赋予修改后的模型的值,cell的显示内容改变. (Controller) // 添加数据 - (void)addWine&#123; // 新建一个模型 XVWine *wine = [[XVWine alloc] init]; wine.image = @"newWine"; wine.name = @"新酒"; wine.money = @"999"; // 将新模型添加进数组 [self.wine addObject:wine]; // cell对应的模型数组的最后一位 NSIndexPath *indexPath = [NSIndexPath indexPathForRow:(self.wine.count - 1) inSection:0]; // 刷新表格 [self.tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TableView自定义header]]></title>
      <url>%2F2014%2F01%2F09%2Fdemonayu%2Fblog%2F03.TableView%E8%87%AA%E5%AE%9A%E4%B9%89header%2F</url>
      <content type="text"><![CDATA[自定义tableView的header, 利用转换坐标系来达到header的停留与跟随#import "ViewController.h"#define toolbarH 44@interface ViewController () &lt;UITableViewDelegate&gt;@property(nonatomic, weak) UITableView *tableView;@property(nonatomic, weak) UIView *toolbar;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 创建tableView UITableView *tableView = [[UITableView alloc] init]; tableView.frame = self.view.bounds; // 设置tableView的内边距的top位置为toolbar的高 tableView.contentInset = UIEdgeInsetsMake(toolbarH, 0, 0, 0); tableView.delegate = self; [self.view addSubview:tableView]; _tableView = tableView; // 创建toolbar CGFloat toolbarW = self.tableView.bounds.size.width; UIView *toolbar = [[UIView alloc] init]; toolbar.frame = CGRectMake(0, -toolbarH, toolbarW, toolbarH); toolbar.backgroundColor = [UIColor orangeColor]; [self.tableView addSubview:toolbar]; _toolbar = toolbar;&#125;#pragma mark - UIScrollViewDelegate// 模拟tableView plain模式的header停留- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; // 存放新Y值 CGFloat newY = 0; if (toolbarH + scrollView.contentOffset.y &gt; 0) &#123; // 向上拖拽偏移量减少 - 转换坐标系 // 转换坐标系 UIWindow *window = [UIApplication sharedApplication].windows.lastObject; [window addSubview:self.toolbar]; newY = [self.tableView convertRect:self.tableView.bounds toView:window].origin.y; &#125; else &#123; // 向下拖拽时偏移量增加 - toolBar跟随tableView [self.tableView addSubview:self.toolbar]; newY = -toolbarH; &#125; // 更新frame CGRect frame = self.toolbar.frame; frame.origin.y = newY; self.toolbar.frame = frame;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIScrollView实现定时滚动分页]]></title>
      <url>%2F2013%2F11%2F23%2Fdemonayu%2Fblog%2F02.UIScrollView%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%2F</url>
      <content type="text"><![CDATA[通过使用UIScrollView控件来实现定时滚动分页#import "ViewController.h"// 图片个数#define imageViewCount 5@interface ViewController () &lt;UIScrollViewDelegate&gt;@property (weak, nonatomic) IBOutlet UIScrollView *scrollView;@property(nonatomic, weak) UIPageControl *pageContorl;@property(nonatomic, strong) NSTimer *timer;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 设置scrollView的一些属性 // scrollView的滚动范围 self.scrollView.contentSize = CGSizeMake(self.scrollView.bounds.size.width * imageViewCount, 0); // 禁用水平和垂直滑块 self.scrollView.showsHorizontalScrollIndicator = NO; self.scrollView.showsVerticalScrollIndicator = NO; // 禁用弹簧效果 self.scrollView.bounces = NO; // 初始化图片分页 [self setupPageView]; // 初始化分页指示器 [self setupPageControl]; // 开始计时器 [self startTiming];&#125;// 设置分页- (void)setupPageView&#123; CGSize scrollViewSize = self.scrollView.bounds.size; // 在scrollView中添加子控件 for (int i = 0; i &lt; imageViewCount; i++) &#123; NSString *imageName = [NSString stringWithFormat:@"img_%02d", i + 1]; UIImageView *imageView = [[UIImageView alloc] init]; imageView.image = [UIImage imageNamed:imageName]; CGFloat imageViewX = scrollViewSize.width * i; CGFloat imageViewY = 0; imageView.frame = (CGRect)&#123;&#123;imageViewX, imageViewY&#125;, scrollViewSize&#125;; [self.scrollView addSubview:imageView]; &#125;&#125;// 设置分页指示器- (void)setupPageControl&#123; UIPageControl *pageContorl = [[UIPageControl alloc] init]; // 单页的时候隐藏 pageContorl.hidesForSinglePage = YES; pageContorl.center = self.view.center; // 注意: 在Xcode6以后 _currentPageImage 和 _pageImage这两个私有属性已经不可见了 // 通过KVC设置指示器图片 [pageContorl setValue:[UIImage imageNamed:@"current"] forKeyPath:@"_currentPageImage"]; [pageContorl setValue:[UIImage imageNamed:@"other"] forKeyPath:@"_pageImage"]; // 设置页码个数 pageContorl.numberOfPages = imageViewCount; [self.view addSubview:pageContorl]; _pageContorl = pageContorl;&#125;// 开始计时器- (void)startTiming&#123; // 初始化定时器 self.timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(pageChanged:) userInfo:nil repeats:YES]; // 将计时添加进事件循环 [[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&#125;// 停止计时器- (void)endTiming&#123; [self.timer invalidate];// self.timer = nil; // 清空指针 - 这句可以不用写&#125;#pragma mark - 监听方法// 定时器滚动页面- (void)pageChanged:(NSTimer *)timer&#123; // 根据当前页码数乘上scrollView的宽度来算出偏移量 CGFloat x = ((self.pageContorl.currentPage + 1) % imageViewCount) * self.scrollView.width; // 这句是定时滚动页面的核心 *** [self.scrollView setContentOffset:(CGPoint)&#123;x,0&#125; animated:YES];&#125;#pragma mark - UIScrollViewDelegate// 监听scrollView的滚动- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; // scrollView内偏移量 / scrollView的宽 = 当前页面 --- 四舍五入 self.pageContorl.currentPage = self.scrollView.contentOffset.x / self.scrollView.bounds.size.width + 0.5;&#125;// 当拖拽scrollView时停止计时- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123; [self endTiming];&#125;// 当停止拖拽时开始计时- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; [self startTiming];&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字典转模型]]></title>
      <url>%2F2013%2F11%2F05%2Fdemonayu%2Fblog%2F01.%E5%AD%97%E5%85%B8%E8%BD%AC%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[为什么要将字典转成模型? 字典和模型都是用来存储数据的 . 字典 : 通过字符串类型的key取值.编写这些key时,编译器不会有任何友善提示,需要手动敲写.手动敲写字符串key,容易写错,而且如果写错,编译器不会有任何警告和报错,容易造成设错数据或者取错数据,增加bug几率. 模型类 : 即用来存放数据的类,继承自NSObject.所谓模型,其实就是数据模型,专门用来存放数据的对象.模型设置数据和取出数据都是通过它的属性,属性名如果写错,编译器会马上报错,因此保证了数据的正确性,而且这种方式更加的贴近面向对象的思想,更加符合苹果官方推荐的MVC编程模式. 字典转模型的两种常用赋值方法 如果是要自己快速创建一个模型最好先提供一个方便创建模型的类工厂方法,当然也可以只提供一个类工厂方法,然后定义这个模型对外的成员属性接口用于外部对象访问这个模型存储的数据. 第一种 : 直接取出字典键值赋值给模型成员属性 如果成员属性较少,或者这个模型将要接收不止一个字典,或者自定义对象有成员属性嵌套,则建议使用这种方法 // 传入一个字典将字典中的所有的键值取出来赋给模型的成员属性+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; // 这里的属性名称和字典的key可以不同名 // 注意:在这里假如这个字典中没有"icon"这个key也没有关系,当有对象访问这个模型数据时不会报错. Model *model = [[ShopsData alloc] init]; model.name = dict[@"name"]; model.icon = dict[@"icon"]; return model;&#125; 第二种 : 利用KVC(KeyValueCoding)赋值 如果字典有很多个key怎么破,当然我们可以像上面一样一个属性一个属性的赋值,只不过累一点嘛.那有没有捷径呢?有! 利用KVC来给属性赋值. + (instancetype)modelWithDict:(NSDictionary *)dict&#123; Model *model = [[ShopsData alloc] init]; // 这种写法与上面代码的意思一样.只不过是通过KVC来实现赋值 [data setValue:dict[@"name"]forKeyPath:@"name"]; [data setValue:dict[@"icon"]forKeyPath:@"icon"]; // 或用这个方法一次性给模型所有的属性赋值 [data setValuesForKeysWithDictionary:dict]; return model;&#125; KVC赋值有一个注意点:那就是模型的属性名必须跟字典的key名一样,否则在取值的时候会报找不到这个键值的错. 字典转模型的写法 除了上面写法外,还可以进行重写构造方法来实现 // 重写构造方法进行赋值- (instancetype)initWithDict:(NSDictionary *)dict&#123; self = [super init]; if (self) &#123; _name = dict[@"name"]; _icon = dict[@"icon"]; &#125; return self;&#125;// 提供工厂方法快速创建对象+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; return [[self alloc] initWithDict:dict];&#125; 如果模型对外界的取值是固定的,那么我们还可以更进一步封装,直接在模型内部把外界的数据转好,调给其他对象使用. 比如说我们要调用一个plist文件中的数据 // 将模型对象存进数组传出去+ (NSArray *)models&#123; // 获取plist文件路径 NSString *file = [[NSBundle mainBundle]pathForResource:@"model.plist" ofType:nil]; // 将plist文件里面的字典存进数组 NSArray *array = [NSArray arrayWithContentsOfFile:file]; // 创建一个临时数组用来存放模型 NSMutableArray *arrayM = [NSMutableArray array]; // 遍历数组,将数组里面的字典转成模型对象存进临时数组 for (NSDictionary *dict in array) &#123; [arrayM addObject:[self modelWithDict:dict]]; &#125; // 返回模型数组 return arrayM;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第二篇]]></title>
      <url>%2F2013%2F08%2F29%2Fdemonayu%2Fblog%2FREADME%2F</url>
      <content type="text"><![CDATA[#Heeeeello Wooooorld!!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开篇]]></title>
      <url>%2F2013%2F08%2F28%2Fdemonayu%2Fblog%2FSUMMARY%2F</url>
      <content type="text"><![CDATA[My Awesome blogThis file serves as your blog’s preface, a great place to describe your blog’s content and ideas.]]></content>
    </entry>

    
  
  
</search>
