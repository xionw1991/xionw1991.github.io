<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[在iOS10接入https的坑]]></title>
      <url>http://xionv.com/2016/09/04/demonayu/blog/43.%E5%9C%A8iOS10%E4%B8%8B%E6%8E%A5%E5%85%A5https%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<blockquote>
<p>从2017年1月1日开始，苹果将要求所有上传的应用必须使用https接口进行数据访问，这里面有些坑让我们来研究一下；</p>
</blockquote>
<h2 id="新https政策">新https政策</h2><ul>
<li>一句话概括：从2017年的元旦起，苹果将继续收紧应用对http的访问权限，要求开发者统一使用https进行数据访问，iOS8及更早的版本不受影响。</li>
<li>新规下，作为服务器的API是肯定是要使用https的，访问网页则有点特殊，因为ATS影响到<code>NSURLSession</code>和<code>UIWebView</code>，所以理论上使用webview访问的网页也必须是https，但这样显然不现实，所以苹果在iOS10添加了新key<code>NSAllowsArbitraryLoadsInWebContent</code>来容许访问未加密的网页。但是这个key在iOS9下并不起作用，这样尴尬了：上传的应用不容许使用<code>NSAllowsArbitraryLoads</code>来绕过ATS，而在应用中又需要访问http网页，怎么办？</li>
</ul>
<h2 id="App_Transport_Security">App Transport Security</h2><p>我们先来看看ATS的要求：</p>
<pre><code>The server certificate must meet <span class="keyword">at</span> least <span class="constant">one</span> <span class="operator">of</span> <span class="operator">the</span> following trust requirements:
    Issued <span class="keyword">by</span> <span class="operator">a</span> certificate authority (CA) whose root certificate is incorporated <span class="keyword">into</span> <span class="operator">the</span> operating <span class="keyword">system</span>
    Issued <span class="keyword">by</span> <span class="operator">a</span> trusted root CA <span class="operator">and</span> installed <span class="keyword">by</span> <span class="operator">the</span> user <span class="operator">or</span> <span class="operator">a</span> <span class="keyword">system</span> administrator
The negotiated Transport Layer Security <span class="built_in">version</span> must be TLS <span class="number">1.2</span>
The negotiated TLS connection cipher suite must support forward secrecy (FS) <span class="operator">and</span> be <span class="constant">one</span> <span class="operator">of</span> <span class="operator">the</span> following:
    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
The leaf server certificate must be signed <span class="operator">with</span> <span class="constant">one</span> <span class="operator">of</span> <span class="operator">the</span> following types <span class="operator">of</span> <span class="built_in">keys</span>:
    Rivest-Shamir-Adleman (RSA) key <span class="operator">with</span> <span class="operator">a</span> <span class="built_in">length</span> <span class="operator">of</span> <span class="keyword">at</span> least <span class="number">2048</span> bits
    Elliptic-Curve Cryptography (ECC) key <span class="operator">with</span> <span class="operator">a</span> size <span class="operator">of</span> <span class="keyword">at</span> least <span class="number">256</span> bits
In addition, <span class="operator">the</span> leaf server certificate hashing algorithm must be Secure Hash Algorithm <span class="number">2</span> (SHA-<span class="number">2</span>) <span class="operator">with</span> <span class="operator">a</span> digest <span class="built_in">length</span> <span class="operator">of</span> <span class="keyword">at</span> least <span class="number">256</span> (that is, SHA-<span class="number">256</span> <span class="operator">or</span> greater).
</code></pre><p>大白话的就是：</p>
<ul>
<li>服务器证书必须至少满足以下条件中的一个<ul>
<li>颁发给服务器证书的证书机构（CA）的根证书必须是内置于操作系统的<a href="https://support.apple.com/zh-cn/HT205205" target="_blank" rel="external">受信任根证书</a>；</li>
<li>受用户或者系统管理员信任并安装到操作系统上的；</li>
</ul>
</li>
<li>服务器TLS版本至少是1.2版本；</li>
<li>连接加密方式必须支持下列正向加密的一种；</li>
<li>证书必须使用SHA256或者更好的哈希算法进行签名，要么是2048位或者更长的RSA密钥，要么就是256位或更长的ECC密钥；</li>
</ul>
<p>其实在这一层客户端所做的事情不多，当https服务器满足ATS默认的条件，而且SSL证书是通过权威的CA机构认证过的，客户端直接接入就可以了正常通信了（后台的兄弟们辛苦了）。<br><br>搭建完成后可以使用命令行来测试是否满足ATS要求：<code>nscurl --ats-diagnostics --verbose https://google.com</code>。</p>
<h2 id="ATS设定">ATS设定</h2><ul>
<li>NSAllowsArbitraryLoads<ul>
<li>在Xcode7中这个key值默认为NO，我们将它设置为YES来访问任意接口，但是苹果新规出来后将限制这个key的使用，设置这个key值需要在应用审核的时候说明原因，能不能过还要看审核员的脸色；</li>
</ul>
</li>
<li>NSAllowsArbitraryLoadsInWebContent<ul>
<li>这是iOS10在ATS中新增加的key，目的是方便使用webview框架的应用在应用内访问http网页，这个key仅在iOS10起作用；</li>
</ul>
</li>
<li>NSExceptionDomains<ul>
<li>这个key值可以让开发者更加灵活的配置让哪些接口遵不遵守ATS的要求，具体设置方法可以参考：<a href="https://github.com/ChenYilong/iOS9AdaptationTips#how如何适配---弱弱地问下加班要多久" target="_blank" rel="external">NSExceptionDomains</a>；</li>
</ul>
</li>
<li>在iOS10下同时设置<code>NSAllowsArbitraryLoads</code>和<code>NSAllowsArbitraryLoadsInWebContent</code>，前者会失效，所以在iOS10下使用<code>NSAllowsArbitraryLoadsInWebContent</code>就意味着除了网页浏览，其他所有的连接都必须是https的；</li>
<li>在iOS9下仅设置<code>NSAllowsArbitraryLoads</code>有效，如果设置为YES则在审核时需要说明原因，如果为NO，则表示所有的连接必须是符合ATS的要求的，包括网页浏览；如果app内部使用webview访问的页面都是固定的域名，可以通过设置<code>NSExceptionDomains</code>白名单在不禁用ATS的情况下进行访问；</li>
<li>以下是整理出来的表格：<br>  <img src="http://ww3.sinaimg.cn/large/0060lm7Tgw1f7hp9c0t2aj314a0q2n5a.jpg" alt=""></li>
</ul>
<h2 id="解决方案">解决方案</h2><p>回到第一个问题：怎么在不禁用ATS的情况下使用webview访问http网页？<br><br>答：在iOS10使用<code>NSAllowsArbitraryLoadsInWebContent</code>来对网页内容禁用ATS，在iOS9使用<code>NSExceptionDomains</code>白名单形式让特定的域名绕过ATS规则，注意如果白名单的网页使用了其他的资源，比如一些图床，则需要将相关的域名也要添加进白名单。目前还不得知苹果对<code>NSExceptionDomains</code>的审核标准是怎样的，猜测如果在上传时说明是webview访问一些第三方的http资源问题应该不大。<br><img src="http://ww1.sinaimg.cn/large/0060lm7Tgw1f7hsq1ggncj30ro076jtw.jpg" alt=""></p>
<p>参考：<a href="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33" target="_blank" rel="external">苹果官方文档</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[处理URL的几种思路]]></title>
      <url>http://xionv.com/2016/08/06/demonayu/blog/42.%E5%A4%84%E7%90%86URL%E6%8B%BC%E6%8E%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在日常开发中，总会碰到需要在客户端对 URL 进行一些处理。这里就列举了三个处理 URL 的方式，灵活度逐渐提高。 </p>
</blockquote>
<h2 id="直接对_URL_字符串进行修改">直接对 URL 字符串进行修改</h2><p>第一种是马上能够想到的方法，直接将得到的 URL 转成 string 来进行操作，比如添加参数，直接将参数名和参数值写死成 <code>key=value</code> 的形式拼接到原有的 URL 上，这里有两点要注意：</p>
<ol>
<li><p>注意格式，需要判断原有的 URL 是否已经带了参数，来决定使用哪个分隔符号 <code>?</code> 还是 <code>&amp;</code>；</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断url是否已经有参数 </span></span><br><span class="line"><span class="keyword">if</span> ([newUrlStr isMatchedByRegex:<span class="string">@"[\\s\\S]+?[\?][\\s\\S]+?"</span>]) </span><br><span class="line">&#123;</span><br><span class="line">    newUrlStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@&amp;%@"</span>, newUrlStr, param];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    newUrlStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@?%@"</span>, newUrlStr, param];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要判断带拼接的参数是否已经在 URL 中存在，如果存在则需要忽略掉；</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([url rangeOfString:paramName]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>同样也有两点不方便：</p>
<ol>
<li>当遇到相同的参数时需要更新参数值就有些麻烦了，要在字符串中找出目标参数所在的范围然后将其替换；</li>
<li>直接操作字符串容易手抖写错，而且写错不好排查；</li>
</ol>
<h2 id="将_URL_解析成_dictionary_进行修改">将 URL 解析成 dictionary 进行修改</h2><p>将 URL 的参数部分提取出来打散拆分成键值对存进字典中，然后把待拼接的参数也以字典的形式与原有的参数进行比对。最后组成一个新的字典，把里面的键值重组排列成参数字符串拼接到 URL 的 path 后面。这种方法需要注意的是，防止字典写空值，和注意拼接格式。<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.将原始 query 转化为字典保存</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *paramsDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="built_in">NSArray</span> *paramsString = [url<span class="variable">.query</span> componentsSeparatedByString:<span class="string">@"&amp;"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *paramStr <span class="keyword">in</span> paramsString) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *tempArray = [paramStr componentsSeparatedByString:<span class="string">@"="</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *key = tempArray<span class="variable">.firstObject</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *value = tempArray<span class="variable">.lastObject</span>;</span><br><span class="line">    [paramsDict setObject:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.拼接新参数，如果相同参数则更新值，没有相同参数则添加</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> newParamsDict<span class="variable">.allKeys</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> value = [newParamsDict objectForKey:key];</span><br><span class="line">    [paramsDict setObject:key forKey:value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将参数字典重组为新的 query </span></span><br><span class="line">__block <span class="built_in">NSString</span> *newQuery = <span class="string">@""</span>;</span><br><span class="line">[paramsDict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull obj, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *param = <span class="string">@""</span>;</span><br><span class="line">    <span class="keyword">if</span> (newQuery<span class="variable">.length</span> == <span class="number">0</span>) <span class="comment">// 第一个参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        param = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"?%@=%@"</span>, [key description], [obj description]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        param = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&amp;%@=%@"</span>, [key description], [obj description]];</span><br><span class="line">    &#125;</span><br><span class="line">    newQuery = [newQuery stringByAppendingString:param];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>这种方式比第一种要更加灵活的处理参数的变化，其实系统已经给了我们一种解决方案，简化了上述方式的转化工作，看下一种解决方案。</p>
<h2 id="使用_NSURLComponents_类来组合参数">使用 NSURLComponents 类来组合参数</h2><p>NSURLComponents 是系统用来分解 URL 的一个类，它可以将原始的 URL 参数部分分解成一个参数数组。 NSURLQueryItem 就是这个数组中存储的对象，这个对象的 name 和 value 属性，对应着每个参数的键和值，我们可以通过遍历这个数组来添加和删除参数，最后将修改过后的参数数组重新赋值给 NSURLComponents 生成新的 URL。<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用URL初始化</span></span><br><span class="line"><span class="built_in">NSURLComponents</span> *urlComponent = [<span class="built_in">NSURLComponents</span> componentsWithURL:url resolvingAgainstBaseURL:<span class="literal">NO</span>];</span><br><span class="line"><span class="comment">// 新的query数组</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *newQureyItems = [urlComponent<span class="variable">.queryItems</span> mutableCopy];</span><br><span class="line"><span class="comment">// newParams是待拼接的参数数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURLQueryItem</span> *itemNew <span class="keyword">in</span> newParams)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 是否存在相同参数的标识位</span></span><br><span class="line">    <span class="built_in">BOOL</span> hasParam = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSURLQueryItem</span> *itemOld <span class="keyword">in</span> urlComponent<span class="variable">.queryItems</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ([itemOld<span class="variable">.name</span> isEqualToString:itemNew<span class="variable">.name</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果存在相同的参数则更新</span></span><br><span class="line">            [newQureyItems replaceObjectAtIndex:[newQureyItems indexOfObject:itemOld] withObject:itemNew];</span><br><span class="line">            hasParam = <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!hasParam)</span><br><span class="line">    &#123;</span><br><span class="line">        [newQureyItems addObject:itemNew];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取到新的query</span></span><br><span class="line">urlComponent<span class="variable">.queryItems</span> = newQureyItems;</span><br></pre></td></tr></table></figure></p>
<p>这种方式最大的好处就是不用我们自己来解析 URL 和拼参了，系统已经做好了这些繁琐的事情，剩下的只需要我们来修改这些值就可以了。</p>
<hr>
<p>以上就是三种拼接 URL 参数的方法，在经过性能测试也没有发现很大差距，最大的区别就在与灵活性和易用性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Github, Gitcafe和 Coding的Pages服务对比]]></title>
      <url>http://xionv.com/2015/12/14/demonayu/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%9B%BD%E5%86%85%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<ul>
<li><p>GitHub/GitCafe/Coding的Pages服务<br> 因为之前博客放在github上, 有时候网络不稳定访问很慢,并且push的时候要等很久,甚至直接push失败, 借昨天放假休息正好可以认真搞一搞博客的部署.<br> 把线路迁移到国内有几个比较流行的代码托管网站,比如gitcafe和coding. gitcafe可以自定义域名,但最近好像不太稳定,在我部署的当天就宕机了,而且到今天数据还不能更新;coding速度很快,一键部署非常方便(运行环境要选择html),但是这个网站默认不支持自定义域名,当然成为付费用户可以选择香港线路来自定义域名,还有在代码上传后需要手动点击一键部署来更新文档, 也可以参照官方的帮助文档设定自动更新<a href="http://static-site.coding.io" target="_blank" rel="external">Coding 云端演示平台静态网站部署指南</a>.</p>
</li>
<li><p>说说心得:</p>
<ul>
<li>github: 稳定,除了网络抽风push的时候有点慢和国内的搜索引擎可能爬不到,其他完美仍然是首选.</li>
<li>gitcafe: 据说服务器在香港,相比github访问速度要快一些,但是最近很不稳定,比如昨天就宕机了很久,导致博客打不开,之后push上去的新内容不能及时更新.不知道是不是我昨天运气不好,等稳定了再说.</li>
<li>coding: 速度快,而且界面友好,但是不支持免费自定义域名,需要花钱办会员,对于没有绑定域名需求的朋友还是很推荐的.</li>
</ul>
</li>
<li><p>最后: 我还是推荐把github作为主站,然后把gitcafe作为镜像用于国内的搜索引擎去收入(使用dnspods把gitcafe.io解析为搜索引擎线路).coding作为备份网站,当前面两个网站打不开的时候救急.</p>
<blockquote>
<p>最后的最后, 生命止于折腾.</p>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[升级Xcode后插件失效的解决办法]]></title>
      <url>http://xionv.com/2015/12/10/demonayu/blog/Xcode%E6%8F%92%E4%BB%B6%E5%A4%B1%E6%95%88%E5%90%8E%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<p> 1.打开终端，输入以下代码获取到DVTPlugInCompatibilityUUID:<br>    <code>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID</code></p>
<p> 2.然后输入如下命令(最后一项是获取到的DVTPlugInCompatibilityUUID):<br>    <code>find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add F41BD31E-2683-44B8-AE7F-5F09E919790E</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图片折叠小demo]]></title>
      <url>http://xionv.com/2015/12/04/demonayu/blog/41.%E5%9B%BE%E7%89%87%E6%8A%98%E5%8F%A0%E5%B0%8Fdemo/</url>
      <content type="html"><![CDATA[<h2 id="利用图层特性实现图片折叠的效果">利用图层特性实现图片折叠的效果</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define imageWH 200.0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIImageView</span> *imageTop;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIImageView</span> *imageBottom;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">CAGradientLayer</span> *gradient;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化图片</span></span><br><span class="line">    [<span class="keyword">self</span> setupImageView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 初始化图片 */</span></span><br><span class="line">- (<span class="keyword">void</span>)setupImageView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建一个透明的蒙版作为手势的接受者 */</span></span><br><span class="line">    <span class="built_in">UIView</span> *cover = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    cover<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, imageWH, imageWH);</span><br><span class="line">    cover<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line">    cover<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">    <span class="comment">// 添加pan手势</span></span><br><span class="line">    <span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pan:)];</span><br><span class="line">    [cover addGestureRecognizer:pan];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:cover];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 添加图片 - 原图片添加两次,分别显示上下部分 */</span></span><br><span class="line">    <span class="comment">// 上半部图片</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *imageTop = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">    imageTop<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">50</span>, imageWH, imageWH * <span class="number">0.5</span>);</span><br><span class="line">    imageTop<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"知道错了"</span>];</span><br><span class="line">    <span class="comment">// 修改layer的contentsRect只显示显示图片的上半部</span></span><br><span class="line">    imageTop<span class="variable">.layer</span><span class="variable">.contentsRect</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 修改锚点Y值为图片的高度</span></span><br><span class="line">    imageTop<span class="variable">.layer</span><span class="variable">.anchorPoint</span> = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">    _imageTop = imageTop;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下半部图片</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *imageBottom = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">    imageBottom<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">50</span>, imageWH, imageWH * <span class="number">0.5</span>);</span><br><span class="line">    imageBottom<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"知道错了"</span>];</span><br><span class="line">    <span class="comment">// 修改layer的contentsRect只显示显示图片的下半部</span></span><br><span class="line">    imageBottom<span class="variable">.layer</span><span class="variable">.contentsRect</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 修改锚点Y值为0</span></span><br><span class="line">    imageBottom<span class="variable">.layer</span><span class="variable">.anchorPoint</span> = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">    _imageBottom = imageBottom;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 给下半部图片添加阴影效果 */</span></span><br><span class="line">    <span class="comment">// 创建一个渐变层用来显示阴影效果</span></span><br><span class="line">    <span class="built_in">CAGradientLayer</span> *gradient = [<span class="built_in">CAGradientLayer</span> layer];</span><br><span class="line">    _gradient = gradient;</span><br><span class="line">    <span class="comment">// 设置图层的位置</span></span><br><span class="line">    gradient<span class="variable">.frame</span> = imageBottom<span class="variable">.bounds</span>;</span><br><span class="line">    <span class="comment">// 设置渐变颜色</span></span><br><span class="line">    gradient<span class="variable">.colors</span> = @[(<span class="keyword">id</span>)[<span class="built_in">UIColor</span> clearColor]<span class="variable">.CGColor</span>, (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> blackColor]<span class="variable">.CGColor</span>];</span><br><span class="line">    <span class="comment">// 设置不透明度</span></span><br><span class="line">    gradient<span class="variable">.opacity</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 给下半部图片添加图层</span></span><br><span class="line">    [imageBottom<span class="variable">.layer</span> addSublayer:gradient];</span><br><span class="line">    </span><br><span class="line">    [cover addSubview:imageBottom];</span><br><span class="line">    [cover addSubview:imageTop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 监听pan手势 */</span></span><br><span class="line">- (<span class="keyword">void</span>)pan:(<span class="built_in">UIPanGestureRecognizer</span> *)pan</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得手指偏移量的Y值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> offsetY = [pan translationInView:<span class="keyword">self</span><span class="variable">.view</span>]<span class="variable">.y</span>;</span><br><span class="line">    <span class="comment">// 将偏移量转成旋转弧度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> angle = offsetY * M_PI / imageWH;</span><br><span class="line">    <span class="keyword">if</span> (angle &gt; M_PI) &#123;</span><br><span class="line">        angle = M_PI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置透视效果 - 除数值越大透视效果越不明显(可以理解成眼睛看到物体的距离)</span></span><br><span class="line">    <span class="built_in">CATransform3D</span> transform = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">    transform<span class="variable">.m34</span> = -<span class="number">1</span> / <span class="number">400.0</span>;</span><br><span class="line">    <span class="comment">// 根据偏移量沿x轴旋转上半部图片</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageTop</span><span class="variable">.layer</span><span class="variable">.transform</span> = <span class="built_in">CATransform3DRotate</span>(transform, -angle, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 给下半部图片添加阴影效果</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.gradient</span><span class="variable">.opacity</span> = offsetY * <span class="number">1</span> / imageWH;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当手指松开的时候将位置返回</span></span><br><span class="line">    <span class="keyword">if</span> (pan<span class="variable">.state</span> == <span class="built_in">UIGestureRecognizerStateEnded</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置反弹动画</span></span><br><span class="line">        <span class="comment">// Duration:动画的执行时长</span></span><br><span class="line">        <span class="comment">// delay:延时执行时长</span></span><br><span class="line">        <span class="comment">// Damping:弹性系数(越小,弹性越大)</span></span><br><span class="line">        <span class="comment">// SpringVelocity:初始的弹性系数</span></span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.25</span> delay:<span class="number">0</span> usingSpringWithDamping:<span class="number">0.1</span> initialSpringVelocity:<span class="number">0</span> options:<span class="number">0</span> animations:^&#123;</span><br><span class="line">            <span class="comment">// 清空transform</span></span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageTop</span><span class="variable">.layer</span><span class="variable">.transform</span> = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">            <span class="comment">// 还原不透明度</span></span><br><span class="line">            <span class="keyword">self</span><span class="variable">.gradient</span><span class="variable">.opacity</span> = <span class="number">0</span>;</span><br><span class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[调用系统相册的两种方法]]></title>
      <url>http://xionv.com/2015/10/08/demonayu/blog/40.%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%86%8C%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<ul>
<li><p>调用系统相册</p>
<ol>
<li><p>调用系统相册需要先实例化一个照片选择控制器</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建照片选择器</span></span><br><span class="line"><span class="built_in">UIImagePickerController</span> *picker = [[<span class="built_in">UIImagePickerController</span> alloc] init];</span><br><span class="line"><span class="comment">// 2. 设置数据源类型(是相册还是照相机)</span></span><br><span class="line">picker<span class="variable">.sourceType</span> = <span class="built_in">UIImagePickerControllerSourceTypeSavedPhotosAlbum</span>;</span><br><span class="line"><span class="comment">// 3. 将调用改控制的对象设置为代理 - 这里必须要实现系统要求的两个协议</span></span><br><span class="line">picker<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">// 4. modal出照片选择控制器</span></span><br><span class="line">[<span class="keyword">self</span> presentViewController:picker animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用代理方法拿到照片</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// info这个字典参数是选中照片的一些信息,根据里面的key可以拿到选择的照片</span></span><br><span class="line">- (<span class="keyword">void</span>)imagePickerController:(<span class="built_in">UIImagePickerController</span> *)picker didFinishPickingMediaWithInfo:(<span class="built_in">NSDictionary</span> *)info</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 拿到图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = info[<span class="built_in">UIImagePickerControllerOriginalImage</span>];</span><br><span class="line">    <span class="comment">// 将照片选取器隐藏</span></span><br><span class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>往相册里存入照片</p>
<ol>
<li><p>调用写入方法</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将图片保存到用户相册里面</span></span><br><span class="line"><span class="comment">// image: 将要保存的图片</span></span><br><span class="line"><span class="comment">// target: 方法监听者</span></span><br><span class="line"><span class="comment">// SEL: 保存图片完成时调用的方法(系统规定写法,用来监听保存状态)</span></span><br><span class="line"><span class="comment">// contextInfo: 上下文信息</span></span><br><span class="line"><span class="built_in">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="keyword">self</span>, <span class="keyword">@selector</span>(image:didFinishSavingWithError:contextInfo:), <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现监听方法</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存相册后回调的监听方法</span></span><br><span class="line">- (<span class="keyword">void</span>)image:(<span class="built_in">UIImage</span> *)image didFinishSavingWithError:(<span class="built_in">NSError</span> *)error contextInfo:(<span class="keyword">void</span> *)contextInfo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"保存失败"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"保存成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>待续…</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS面试题]]></title>
      <url>http://xionv.com/2015/10/05/demonayu/blog/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这是从简书上拷贝下来题目,没事自己做做.</p>
</blockquote>
<a id="more"></a>
<h2 id="初级">初级</h2><ul>
<li><strong>关于单方面技术</strong><ul>
<li>ARC / MRC 简单叙述一下<br><code>ARC和MRC的意思分别是自动引用计数和手动引用计数，它是iOS中内存管理的一种机制。当一个对象被创建和引用时那么它的引用计数器就会+1，当没有这个对象的引用计数为0时这个对象就会被销毁。MRC中有3个关键字来控制引用计数分别是retain/release/autorelease，retain表示计数器+1，release和autorelease表示计数器-1。ARC与MRC对内存管理的原理是一样的，只是具体实现不一样，ARC它是一种编译器特性，在ARC环境下我们不用手动编写retain和release，编译器会自动在适当的地方插入这些方法。ARC它是通过判断有没有强引用来判断对象是否该销毁，它也有3个关键字来控制对象的生命，strong/weak/assign，strong表示强引用，只要有一个强引用引用者该对象，那么这个对象就不会被销毁。</code></li>
<li>封装过什么控件, 简单叙述一下<br><code>封装过一些HUD和自定义tabbar， hud就是自定义一个UIView，然后重写view的drewRect: 方法使用cg和ca框架来画出需要的图形。自定义一个tabbar来替换系统自带的tabbar，还有就是自己写一个tabbarViewcontroller来实现完全的自定义。</code></li>
<li>属性readwrite，readonly，assign，retain，copy，nonatomic各是什么作用<br><code>以上关键字是用来修饰成员属性的，readwrite表示该成员属性可读可写，意味着编译器会默认生成带下划线的成员变量名和与之对应的setter和getter方法；readonly则表示只读，意味着只会生成带下划线的成员变量和对应的getter方法；assign一般用来修饰基本数据类型；retain一般在MRC环境下使用，它修饰的成员属性在被调用的时候，引用计数器会+1；copy一般用来修饰集合类型，因为集合类型分为可变和不可变类型，如果直接使用retain或strong修饰的话，外界就有可能会改这个集合中的值，导致数据污染，通常做法就是当外界使用这个集合的时候都会进行一次拷贝操作，以保证原始数据的完整性；nonatomic表示非原子性，表示非线程安全的，当有多个线程同时访问和修改一个成员变量时，会出现抢夺资源的情况，导致访问成员变量值出错，而atomic就是给这个成员变量配一把锁，当有一个线程访问这个成员变量时就会得到这把锁，其他线程就不能访问，只有这个线程把这个锁释放后其他线程才能访问，保证数据的安全性。</code></li>
<li>Get Set方法<br><code>get 和 set 方法是为了保证对象的封装性而存在的。一般在程序设计时，如果把一个成员变量暴露在外供外界随意调用是一件很危险的事情。所以这时需要对成员变量进行一次封装，让这个成员变量只能在类的内部调用，对外则提供一些特定的接口让外界访问，这用就能有效的过滤外界对成员变量的行为，保证数据的安全性。</code></li>
<li>id 是什么<br><code>id可以理解为一个万能指针，它能指向任意一个对象。它是oc多态特征的表现，1.只有当程序运行的时候对象的真实类型才能被确定；2.可以用父类指针指向子类。</code></li>
<li>代理, Block, 循环引用<br><code>代理实际上是一种设计模式，一个类有一些方法需要外界来实现的时候就可以使用代理模式，比如tableView的数据源，tableView的代理方法。它的存在主要是为了让类之间解耦，以达到模块化的目的；block其实就是一段代码块，用来保存一段代码，然后让这段代码在合适的时候进行调用。block的本质其实就是一个指向结构体的指针，block保存的代码块则最终会被转成一个函数，然后block指向的结构体会生成一个指向该函数的指针型成员变量，当block被调用的时候实际上就是调用的这段函数；循环引用的意思就是，当两个对象互相强引用着对方时，谁也不能被销毁。代理模式和block都会产生循环引用的问题，所以当一个类声明一个代理属性的时候，需要将那个类修饰为弱引用来防止出现循环引用。在block中也是，当block的调用者在block的回调函数中被引用时就会产生循环引用，解决办法就是，新定义一个弱引用的变量来指向block调用者，在block的回调函数中使用这个弱引用来指代这个调用者。</code></li>
<li>通知的使用<br><code>通知的流程就是当一个事件产生时拿到通知中心单例对象，通过这个单例对象post一个事件，这个事件中包含这个通知的标识，通知发送者和一个字典类型的参数，接下来如果有对象要接收这个通知则先需要add一个监听者来监听这个通知的发送在做一些响应操作，最后当通知的监听对象被销毁的时候记得使用remove来移除监听。通知的使用场景一般是，结构层次很深，或互不相干的两个对象需要进行一个事件监听和数据处理。</code></li>
</ul>
</li>
<li><strong>关于项目方面</strong><ul>
<li>参与过什么项目, 负责什么</li>
<li>项目中你参与的模块遇到过什么大的问题, 怎么解决的, 详细叙述</li>
<li>Git/SVN<br><code>一个是集中式源代码管理工具，一个分布式源代码管理工具，这个没什么好说的。</code></li>
</ul>
</li>
</ul>
<h2 id="中级">中级</h2><ul>
<li><p><strong>在基础技术问题的基础上</strong></p>
<ul>
<li>本地通知和远程通知<br><br><code>感觉没什么好说的，本地通知，用来提示本地信息。远程通知是当客户端不在活跃状态时由服务器发送消息给苹果的APNS服务器，然后再根据deviceToken推送给各个设备</code></li>
<li><p>简单讲述SDWebImage实现原理<br><br><code>直接上代码</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadImageWithUrlStr:(<span class="built_in">NSString</span> *)urlStr placeholder:(<span class="built_in">NSString</span> *)placeholder completeHandle:(<span class="keyword">void</span> (^)(<span class="built_in">UIImage</span> *image))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1&gt; 先从内存缓存中取</span></span><br><span class="line">    <span class="comment">// 根据url取出图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *memoryImage = <span class="keyword">self</span><span class="variable">.images</span>[urlStr];</span><br><span class="line">    <span class="keyword">if</span> (memoryImage) &#123; <span class="comment">// 当内存中有图片时</span></span><br><span class="line">        block(memoryImage);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当内存中没有图片时</span></span><br><span class="line">        <span class="comment">// 2&gt; 再从沙盒中取 - 每一张图片都是一个文件 文件名为url名</span></span><br><span class="line">        <span class="built_in">UIImage</span> *diskImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:cachePath(urlStr)];</span><br><span class="line">        <span class="keyword">if</span> (diskImage) &#123; <span class="comment">// 沙盒中有图片时</span></span><br><span class="line">            block(diskImage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当沙盒中没有对应的图片时</span></span><br><span class="line">            <span class="comment">// 设置占位图片</span></span><br><span class="line">            block([<span class="built_in">UIImage</span> imageNamed:placeholder]);</span><br><span class="line">            <span class="comment">// 3&gt; 从网络上下载</span></span><br><span class="line">            <span class="comment">/* 为了保证一张图片只下载一次,需要判断当前url是否有下载任务,如果没有才需要创建下载任务 */</span></span><br><span class="line">            <span class="comment">/* 如何才能判断当前的url是否有下载任务呢?利用字典一对一绑定来判断 */</span></span><br><span class="line">            <span class="comment">// 取出字典中url对应的下载任务</span></span><br><span class="line">            <span class="built_in">NSBlockOperation</span> *operation = <span class="keyword">self</span><span class="variable">.operations</span>[urlStr];</span><br><span class="line">            <span class="comment">// 如果当前url有下载任务 - 就不创建任务</span></span><br><span class="line">            <span class="keyword">if</span> (!operation) &#123;</span><br><span class="line">                __<span class="keyword">weak</span> <span class="keyword">typeof</span> (<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">                <span class="comment">// 创建异步任务 - 将下载图片的操作放入到子线程中 - 解决异步下载的问题</span></span><br><span class="line">                operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">                    <span class="comment">// 将字符串转成url</span></span><br><span class="line">                    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlStr];</span><br><span class="line">                    <span class="comment">// 从url获取数据</span></span><br><span class="line">                    <span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">                    <span class="comment">// 将二进制数据转成图片</span></span><br><span class="line">                    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 返回主线程刷新数据</span></span><br><span class="line">                    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">                        <span class="comment">// 如果下载成功将图片存入字典 - 字典不能存空</span></span><br><span class="line">                        <span class="keyword">if</span> (image) &#123;</span><br><span class="line"></span><br><span class="line">                            block(image);</span><br><span class="line">                            <span class="comment">// 1)将下载好的图片添加进图片字典中 url为key</span></span><br><span class="line">                            [weakself<span class="variable">.images</span> setObject:image forKey:urlStr];</span><br><span class="line">                            <span class="comment">// 2)将image写入沙盒</span></span><br><span class="line">                            <span class="comment">// 将图片转成二进制数据</span></span><br><span class="line">                            <span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line">                            <span class="comment">// 写入沙盒</span></span><br><span class="line">                            [data writeToFile:cachePath(urlStr) atomically:<span class="literal">YES</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 下载完毕后将任务从字典中移除 - 如果下载失败将任务移除后还有机会下载,如果不移除,这个key就会一直存在永远也不能再次下载了</span></span><br><span class="line">                        <span class="comment">// 在主线程中移除是为了保证下载操作已经执行完毕</span></span><br><span class="line">                        [<span class="keyword">self</span><span class="variable">.operations</span> removeObjectForKey:urlStr];</span><br><span class="line">                    &#125;];</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将任务添加到队列 - 如果当前队列有相同任务则不添加</span></span><br><span class="line">            <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.queue</span><span class="variable">.operations</span> containsObject:operation]) &#123;</span><br><span class="line">                [<span class="keyword">self</span><span class="variable">.queue</span> addOperation:operation];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将下载任务写入到字典里(解决重复下载问题)</span></span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.operations</span> setObject:operation forKey:urlStr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库语句<br><br><code>列举几个常用的数据库语句：</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 创表</span><br><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> t_cmpt (<span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span>, <span class="keyword">name</span> <span class="built_in">TEXT</span>, price <span class="built_in">REAL</span>)</span><br><span class="line">// 插入数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_cmpt (<span class="keyword">name</span>, price) <span class="keyword">VALUES</span> (abc, <span class="number">998</span>)</span><br><span class="line">// 删除数据</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t_cmpt</span><br><span class="line">// 查询数据</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_cmpt</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CoreData常用使用<br><br><code>一般用sqlite，没用过CoreData</code></p>
</li>
<li><p>优化UITableView的方式, 方法<br></p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby"> 对于复杂的视图，使用纯代码来实现布局（storyboard对资源的消耗要大于纯代码）</span><br><span class="line"></span>-<span class="ruby"> 使用<span class="constant">SDWebImage</span>来异步加载图片, 管理下载队列, 缓存数据</span><br><span class="line"></span>-<span class="ruby"> 使用估算高度,来防止tableView一显示就计算所有cell的高度(延迟调用heightForRow)</span><br><span class="line"></span>-<span class="ruby"> 在不等高cell中,使用字典来保存已经计算高度的cell,在下次滑动到这个cell的时候优先调用字典里的cellHeight, 最好的办法是在数据返回的时候就根据数据来计算出cell的高度并缓存起来</span><br><span class="line"></span>-<span class="ruby"> 调用scrollView的代理方法,在滑动tableView的时候就停止所有的网络请求(比如图片下载)</span><br><span class="line"></span>-<span class="ruby"> 在cell已经离开显示区域后从内存中清除cell,特别是带大量图片的复杂的cell, 防止内存占用过多导致程序崩溃</span><br><span class="line"></span>-<span class="ruby"> 在cell中使用高清大图时尽量使用fileFormPath来加载图片而不是使用<span class="symbol">imageName:</span> 前者是一次性显示,当从可显示区域移除后就会自动从内存中销毁, 而后者只有内存警告的时候才会被回收</span><br><span class="line"></span>-<span class="ruby"> 在对象销毁的时候将所有的代理清空</span><br><span class="line"></span>-<span class="ruby"> 尽量让所有的view不透明(opaque), 因为透明会额外消耗性能</span><br><span class="line"></span>-<span class="ruby"> 尽量不要动态给cell添加子控件(意思就是不要在cellForRow中添加子控件)</span><br><span class="line"></span>-<span class="ruby"> 不需要交互的内容不使用系统封装好的控件来显示，而是调用独立功能的<span class="constant">API</span>来在图层上绘制，比如cell中的图片只需要显示，而不需要交互，则可以考虑自定义图层来绘制出这个图片，还有文字使用更底层的<span class="constant">CoreText</span>来绘制文字而不是使用label</span><br><span class="line"></span>-<span class="ruby"> 根据滑动的位置异步按需加载内容(比如提前加载当前显示cell附近cell的内容)</span><br><span class="line"></span>-<span class="ruby"> 使用第三方框架的tableView(异步渲染<span class="constant">UI</span>)，比如<span class="constant">AsyncDisplayKit</span>框架</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>深浅拷贝<br></p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">浅复制（浅拷贝，指针拷贝，shallow copy）</span><br><span class="line">-<span class="ruby"> 源对象和副本对象是同一个对象</span><br><span class="line"></span>-<span class="ruby"> 源对象（副本对象）引用计数器+<span class="number">1</span>,相当于做一次retain操作</span><br><span class="line"></span>-<span class="ruby"> 本质是：没有产生新的对象</span><br><span class="line"></span>-<span class="ruby"> 原对象引用计数器+<span class="number">1</span></span><br><span class="line"></span>-<span class="ruby"> 必须对原对象进行释放</span><br><span class="line"></span>深复制（深拷贝，内容拷贝，deep copy）</span><br><span class="line">-<span class="ruby"> 源对象和副本对象是不同的两个对象</span><br><span class="line"></span>-<span class="ruby"> 源对象引用计数器不变,副本对象计数器为<span class="number">1</span>（因为是新产生的）</span><br><span class="line"></span>-<span class="ruby"> 本质是：产生了新的对象</span><br><span class="line"></span>-<span class="ruby"> 必须释放新对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行时你知道多少（是什么？有哪些用处？）<br><br><code>运行时是一套纯c语言的函数库，它是支撑整个OC动态特性的幕后工作者，在OC环境下所编写的代码在编译的时候都会先转换成纯c的运行时代码然后在再编译成二进制的机器语言。使用运行时可以办到一些OC办不到的事情，比如获取类中的私有成员变量，动态添加方法，动态添加成员属性，动态添加一个类（KVO），Method Swizzle，实现消息转发等。</code></p>
</li>
<li>封装过什么<br><code>封装过一些工具类，视图类，模型缓存类等</code></li>
</ul>
</li>
<li><p><strong>关于项目方面</strong></p>
<ul>
<li>熟练的使用Git</li>
<li><p>如果让你设计一个缓存模块, 你会怎么设计,需要考虑到什么</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">每次获取数据优先从内存中获取，如果没有再查找本地数据库和文件，如果没有则发送网络请求，从服务区加载数据，然后将获得的数据进行本地缓存。</span><br><span class="line">数据库缓存方面注意点：</span><br><span class="line"><span class="number">1.</span>首先考虑到的是线程安全，因为在iOS中sqlite不支持多线程并发访问，会引起数据库锁定，所以在访问数据库的时候都是以同步串行的方式进行访问的；</span><br><span class="line"><span class="number">2.</span>添加文件校验，将文件名和文件数据进行关联，防止文件多次下载；</span><br><span class="line"><span class="number">3.</span>防止文件名冲突，比如像SDWebImage对下载下来的文件名进行MD5加密，防止文件被覆盖；</span><br></pre></td></tr></table></figure>
</li>
<li><p>说说MVC MVVM MVP<br><code>MVP是MVC的衍生版，真正做到了模型与视图的隔离，每次视图需要获取数据必须要通过Presenter，当然这又产生一个问题，就是Presenter的体积会越来越庞大，不便于后期的维护。MVVM则更像MVC的改良版，它将控制器中对数据的处理全部抽到了一个视图模型中，减小了控制器的体积，同时也办到了视图与模型的隔离。</code></p>
</li>
<li>做过最失败的项目是什么, 为什么</li>
<li>你觉得怎么划分模块会好一点<br><code>我觉得按功能划分最好啦~</code></li>
</ul>
</li>
</ul>
<h2 id="高级">高级</h2><ul>
<li><strong>基于前两个</strong><ul>
<li>多线程详细说一下, 怎么封装一个适合自己项目的线程池,怎么处理会好一点。</li>
<li>多线程CoreData, 这个基本所有的面试都会提到一下吧</li>
<li>使用过什么开源的动画库, 这就是随便问问 比如pop, canvas等</li>
<li>有自己的开源项目么？</li>
<li>有全面的对网络库进行二次开发封装么, 怎么干的。</li>
<li>讲一下运行时调换系统方法swizzle的原理</li>
<li>自己尝试着模拟系统Block的实现</li>
<li>怎么理解界面模板, 有做过相关开发么</li>
<li>IM的东西随便问问，如果公司需要</li>
<li>内存优化怎么搞一下<br><br><code>见tableView的优化思路</code></li>
<li>自己写个tableView玩玩？</li>
</ul>
</li>
<li><strong>项目方面</strong><ul>
<li>参与过什么项目, 做过什么大型的项目, 负责哪些模块</li>
<li>框架的设计有没有参与, 如果有的话, 参与了框架中哪一部分的工作, 怎么考虑你这部分未来的可扩展性的。</li>
<li>在项目中严格按照产品,UIUE的思维去做,还是会把自己的想法提出来。</li>
<li>怎么为一个项目写一套完整的网络库, 缓存库, 界面库。</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UIAlertView在iOS9中的使用]]></title>
      <url>http://xionv.com/2015/09/20/demonayu/blog/39.UIAlertView%E5%9C%A8IOS9%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>iOS9中改变了UIAlertView的使用方式, 并且与UIActionSheet融合进了一个类里面,统一进行管理.</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注销</span></span><br><span class="line">- (<span class="keyword">void</span>)loginOut</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建一个alertController来管理警示窗口, 并指定样式</span></span><br><span class="line">    <span class="built_in">UIAlertController</span> *alertController = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@"确定注销吗?"</span> message:<span class="literal">nil</span> preferredStyle:<span class="built_in">UIAlertControllerStyleActionSheet</span>];</span><br><span class="line">    <span class="comment">// 2.创建点击行为, 在block中实现事件</span></span><br><span class="line">    <span class="built_in">UIAlertAction</span> *action = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"确定"</span> style:<span class="built_in">UIAlertActionStyleDestructive</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.navigationController</span> popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"已注销"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">UIAlertAction</span> *cancel = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"取消"</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"取消注销"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 3.为alertController添加点击行为</span></span><br><span class="line">    [alertController addAction:action];</span><br><span class="line">    [alertController addAction:cancel];</span><br><span class="line">    <span class="comment">// 4.弹出警示窗口</span></span><br><span class="line">    [<span class="keyword">self</span> presentViewController:alertController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Runtime黑魔法]]></title>
      <url>http://xionv.com/2015/09/18/demonayu/blog/38.Runtime%E9%BB%91%E9%AD%94%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="Runtime消息机制">Runtime消息机制</h2><p>之前写过一篇短文: <a href="http://xionv.com/2015/05/08/demonayu/blog/29.利用运行时特性获取系统类的私有成员变量/">利用运行时特性获取系统类的私有成员属性</a>.<br><br>通过运行时特性获得私有的成员变量target, 然后为target重新指定手势方法来达到全屏都能接收到滑动返回的事件.</p>
<ul>
<li><p>如果要搞清楚为什么能这样做首先得明白OC的运行时机制,看下面代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pan:)];</span><br></pre></td></tr></table></figure>
</li>
<li><p>这行代码的意思就是:使用UIPanGestureRecognizer类来实例化了一个名为pan的实例对象,并为这个对象指定了手势的监听对象(假设是控制器)和监听方法. 其实这只是我们看到的表面,实际上OC所有的方法调用本质上还是函数的调用.</p>
</li>
<li>大概了解一下什么是runtime:<ul>
<li>Runtime顾名思义就是运行时的意思.在运行的时候才会调用需要实现的函数.</li>
<li>OC是一门动态的语言,相对于C语言来讲,OC方法的调用是在程序运行的时候才决定的.也就是说只有方法的声明没有方法的实现照样也能编译通过.这样就需要一个运行时系统 (runtime system) 来执行编译后的代码.</li>
</ul>
</li>
<li><p>运行时中的消息机制: </p>
<ul>
<li>每一个方法的调用实际上就是向对象发送了一条消息让其执行SEL指向的方法实现(IMP);</li>
<li><p>上面的代码可以使用runtime函数改写:</p>
<ul>
<li><p>导入头文件,在项目设置中将<code>enable strict checking of objcmsgsend calls</code>改成<code>NO</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/message.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>改写方法为消息函数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = objc_msgSend(objc_msgSend (objc_getClass(<span class="string">"UIPanGestureRecognizer"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"initWithTarget:action:"</span>), <span class="keyword">self</span>, sel_registerName(<span class="string">"pan:"</span>));</span><br></pre></td></tr></table></figure>
<p>解释: <code>objc_msgSend</code>就是消息函数.<br><code>objc_getClass</code>将字符串转化成类名, <code>sel_registerName</code> 将字符串注册成一个方法标识.<br>后面的<code>self</code>和<code>sel_registerName(&quot;pan:&quot;)</code>则相当于消息的参数. 这句话翻译过来就是,系统向<code>UIPanGestureRecognizer</code>这个类对象发送了一条消息,让它去执行参数<code>alloc</code>所指向的方法实现,返回一个实例对象, 再发送一条消息让返回的实例对象去执行<code>initWithTarget:action:</code>这个方法,并且同时传入了两个参数.</p>
</li>
</ul>
</li>
<li>分析消息函数:<code>objc_msgSend(id self, SEL op, ...);</code><ul>
<li>每一个消息函数都需要至少传入两个参数, 一个是消息的接收者(target), 一个方法代号(SEL).</li>
<li>这个两个参数被称为隐式参数.如果你用过<code>NSInvocation</code>那么你就会明白为什么调用<code>[invocation setArgument:&amp;param1 atIndex:2];</code>传入参数的时候索引要从2开始.</li>
<li><strong>系统在向一个对象发送消息并不意味着会被马上执行.如果消息的接收者能够找到对应的selector,那么就相当于直接执行了接收者这个对象的特定方法;否则,消息被转发,或是临时向接收者动态添加这个selector对应的实现内容(动态方法解析),如果都没有则程序崩溃.</strong></li>
</ul>
</li>
</ul>
</li>
<li>消息发送的步骤:<ol>
<li>检测这个<code>selector</code>是不是要忽略的;</li>
<li>检测这个<code>target</code>是不是<code>nil</code>对象;</li>
<li>如果上面两关都过了则开始查找类中的cache中的IMP, 如果能找到这执行函数,如果不能在去映射表中查找;</li>
<li>如果当前类中映射表中查不到,则向上沿着父类的映射表查找,一直找到根类;</li>
<li>如果仍然没有找到则开始动态方法解析和消息转发.</li>
</ol>
</li>
</ul>
<h3 id="Class">Class</h3><ul>
<li>在OC中类本身也是一个对象,为了处理类和对象的关系,runtime库创建了一种叫做元类 (Meta Class) 的东西,类对象所属类型就叫做元类,它用来表述类对象本身所具备的元数据.类方法就定义于此处,因为这些方法可以理解成类对象的实例方法.每个类仅有一个类对象,而每个类对象仅有一个与之相关的元类.当发出一个类似<code>[NSObject alloc]</code>的消息时,事实上是把这个消息发给了一个类对象 (Class Object),这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class)的实例.所有的元类最终都指向根元类为其超类.所有的元类的方法列表都有能够响应消息的类方法.所以当<code>[NSObject alloc]</code>这条消息发给类对象的时候,objc_msgSend()会去它的元类里面去查找能够响应消息的方法,如果找到了,然后对这个类对象执行方法调用.<br><img src="http://cn.cocos2d-x.org/uploads/20141018/1413628797629491.png" alt=""></li>
</ul>
<h3 id="SEL">SEL</h3><ul>
<li>方法的selector用于表示运行时方法的名字.OC在编译时,会依据每一个方法的名字,参数序列,生成一个唯一的整型标识(Int类型的地址),这个标识就是SEL;</li>
<li>SEL类型代表着方法的签名,在类对象的方法列表中存储着该签名与方法代码的对应关系;</li>
<li>每一个方法都对应着一个SEL.所以在同一个类(及类的继承体系)中,不能存在2个同名的方法,即使参数类型不同也不行.相同的方法只能对应一个SEL。</li>
<li>本质上,SEL只是一个指向方法的指针(准确的说,只是一个根据方法名hash化了的KEY值,能唯一代表一个方法),它的存在只是为了加快方法的查询速度,最终指向方法的实现.</li>
<li>运行时有三种方式获得SEL<ul>
<li><code>sel_registerName</code>函数</li>
<li>编译器提供的<code>@selector()</code></li>
<li><code>NSSelectorFromString()</code>方法</li>
</ul>
</li>
</ul>
<h3 id="IMP">IMP</h3><ul>
<li>IMP实际上是一个函数指针,指向方法实现的首地址.可以理解成它就是实现方法的一个入口,连接着代码区的方法实现代码.取得IMP后我们就可以像调用普通的C语言函数一样来使用这个函数指针了.</li>
<li>通过取得IMP,我们可以跳过Runtime的消息传递机制,直接执行IMP指向的函数实现,这样省去了Runtime消息传递过程中所做的一系列查找操作,会比直接向对象发送消息高效一些.</li>
<li>直接获取方法地址: <code>methodForSelector:</code>.</li>
</ul>
<h3 id="Method">Method</h3><ul>
<li><p>Method的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL method_name                 OBJC2_UNAVAILABLE;  <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">char</span> *method_types              OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                  OBJC2_UNAVAILABLE;  <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到该结构体中包含一个SEL和IMP,实际上相当于在SEL和IMP之间作了一个映射.有了SEL,我们便可以找到对应的IMP,从而调用方法的实现代码.</p>
<p><img src="http://r5.loli.io/EVBVVn.png" alt=""></p>
</li>
</ul>
<h3 id="Cache">Cache</h3><ul>
<li>Cache为方法调用的性能进行优化,通俗地讲,每当实例对象接收到一个消息时,它不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法,因为这样效率太低了,而是优先在Cache中查找.Runtime系统会把被调用的方法存到Cache中(理论上讲一个方法如果被调用，那么它有可能今后还会被调用),下次查找的时候效率更高.</li>
</ul>
<h2 id="Runtime几个常见的用法">Runtime几个常见的用法</h2><h3 id="获取成员和方法列表">获取成员和方法列表</h3><ul>
<li><p>在Runtime面前没有私有变量,使用私有变量调用自定义方法.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来记录成员变量个数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ivarCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 取出所有的成员变量</span></span><br><span class="line">Ivar *ivars = class_copyIvarList([<span class="built_in">UIPageControl</span> class], &amp;ivarCount);</span><br><span class="line"><span class="comment">// 遍历所有的成员变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ivarCount; i++) &#123;</span><br><span class="line">    <span class="comment">// 打印变量名</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, ivar_getName(ivars[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"----------分割线-----------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录成员属性个数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> propertyCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 取出所有的成员属性</span></span><br><span class="line">objc_property_t *propertise = class_copyPropertyList([<span class="built_in">UIPageControl</span> class], &amp;propertyCount);</span><br><span class="line"><span class="comment">// 遍历成员属性列表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) &#123;</span><br><span class="line">    <span class="comment">// 打印属性名</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, property_getName(propertise[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取方法列表:调用私有方法成为可能</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取出方法列表</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outcount = <span class="number">0</span>;</span><br><span class="line">Method *methods = class_copyMethodList([<span class="built_in">UIPageControl</span> class], &amp;outcount);</span><br><span class="line"><span class="comment">// 遍历方法列表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outcount; i++) &#123;</span><br><span class="line">    SEL action = method_getName(methods[i]);</span><br><span class="line">    <span class="comment">// 打印所有方法(包括私有)</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(action));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用私有方法, UIPageControl默认是不能设置图片的, 通过调用这个私有方法可以设置指示器图片</span></span><br><span class="line">[[<span class="built_in">UIPageControl</span> new] performSelector:<span class="keyword">@selector</span>(_pageIndicatorImageForPage:) withObject:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image"</span>]];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="三种方式调用私有方法">三种方式调用私有方法</h4><ol>
<li><p>performSelector: – 优点:方便; 缺点:最多只能传2个参数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[XVPerson new] performSelector:<span class="keyword">@selector</span>(eat:drink:play:) withObject:<span class="string">@"hamburger"</span> withObject:<span class="string">@"coke"</span>];</span><br></pre></td></tr></table></figure>
<p>ps: 让selector调用的方法接受的参数类型为Dictionary类型可以间接实现多参数传递.</p>
</li>
<li><p>NSInvocation – 优点:可以传多个参数; 缺点:调用麻烦,代码较多</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个方法签名</span></span><br><span class="line">SEL myMethod = <span class="keyword">@selector</span>(eat:drink:play:);</span><br><span class="line"><span class="built_in">NSMethodSignature</span> *signature = [[XVPerson class] instanceMethodSignatureForSelector:myMethod];</span><br><span class="line"><span class="comment">// 初始化一个NSInvocation对象</span></span><br><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];</span><br><span class="line"><span class="comment">// 要执行的方法</span></span><br><span class="line">[invocation setSelector:myMethod];</span><br><span class="line"><span class="comment">// 注: 这里的index为什么要从2开始? 因为每一个OC方法的本质就是一个至少带有两个参数(self,_cmd)的普通C函数</span></span><br><span class="line"><span class="comment">// 这两个参数在这里所对应的就是Target和Selector, 这两个参数已经将0 和 1 的位置给占了.所以其他参数要从 2 开始.</span></span><br><span class="line"><span class="built_in">NSString</span> *param1 = <span class="string">@"hamburger"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *param2 = <span class="string">@"coke"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *param3 = <span class="string">@"hockey"</span>;</span><br><span class="line">[invocation setArgument:&amp;param1 atIndex:<span class="number">2</span>];</span><br><span class="line">[invocation setArgument:&amp;param2 atIndex:<span class="number">3</span>];</span><br><span class="line">[invocation setArgument:&amp;param3 atIndex:<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 调用方法 并指定调用谁的方法</span></span><br><span class="line">[invocation invokeWithTarget:[XVPerson new]];</span><br></pre></td></tr></table></figure>
</li>
<li><p>Runtime – 优点:代码简单,能传多参数 缺点:要导入头文件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">objc_msgSend([XVPerson new], sel_registerName(<span class="string">"eat:drink:play:"</span>), <span class="string">@"hamburger"</span>, <span class="string">@"coke"</span>, <span class="string">@"hockey"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="交换方法"><strong>交换方法</strong></h3><ul>
<li>目标: 当系统找不到方法的时候会调用<code>doesNotRecognizeSelector:</code>来抛出崩溃详情. 要求通过添加分类来实现改写这个系统方法.本质上就是一种消息转发机制.</li>
<li><p>思路: 利用Runtime在程序抛出错误时添加一行打印, 通过交换方法可以在不影响错误打印的同时在程序退出时做一些事情.</p>
<ol>
<li><p>为NSObject添加一个分类,并导入头文件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> (Extension)</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/message.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个自定义方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)xv_doesNotRecognizeSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"因为找不到%@方法,程序即将崩溃!"</span>, <span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"====================================="</span>);</span><br><span class="line">    <span class="comment">// 这个时候实现这个方法并不会死循环, 因为实际上执行的是doesNotRecognizeSelector:</span></span><br><span class="line">    [<span class="keyword">self</span> xv_doesNotRecognizeSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与系统方法进行交换</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在类加载的时候就进行交换</span></span><br><span class="line"> + (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前类中的对象方法</span></span><br><span class="line">    Method method1 = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(doesNotRecognizeSelector:));</span><br><span class="line">    Method method2 = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(xv_doesNotRecognizeSelector:));</span><br><span class="line">    <span class="comment">// 交换方法</span></span><br><span class="line">    method_exchangeImplementations(method1, method2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="动态方法解析">动态方法解析</h3><ul>
<li>使用场景: 用到该方法时再加载该方法;</li>
<li><p>思路: 当对象调用一个未实现的方法时, 系统就会调用下面这个方法,本质上就消息转发</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系统调用这个方法的意思就是,给个机会让类添加这个未实现的方法</span></span><br><span class="line"> + (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br></pre></td></tr></table></figure>
</li>
<li><p>假如person这个对象要调用未实现的方法<code>eat:drink:play:</code>, 具体步骤:</p>
<ol>
<li><p>当前类重写<code>resolveInstanceMethod:</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> + (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当传进来的sel是未实现的sel时</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"eat:drink:play:"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 参数1: 需要添加方法的类</span></span><br><span class="line">        <span class="comment">// 参数2: 传进来的方法名称</span></span><br><span class="line">        <span class="comment">// 参数3: 需要添加的方法实现</span></span><br><span class="line">        <span class="comment">// 参数4: "v@:@@@" 这个方法的参数描述 -- v表示空值, @表示对象, :表示方法(SEL)</span></span><br><span class="line">        <span class="comment">// 对应函数 void myMethodIMP(id self, SEL _cmd, NSString *eat, NSString *drink, NSString *play) 的5个参数类型</span></span><br><span class="line">        <span class="comment">// 给类动态添加一个方法来救命</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)myMethodIMP, <span class="string">"v@:@@@"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加的方法实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每一个OC方法的本质其实就是一个至少带有两个参数（self,_cmd）的普通C函数</span></span><br><span class="line"><span class="keyword">void</span> myMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *eat, <span class="built_in">NSString</span> *drink, <span class="built_in">NSString</span> *play) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"eat: %@, drink: %@, play:%@"</span>, eat, drink, play);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@--%@"</span>, <span class="keyword">self</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="动态添加成员属性">动态添加成员属性</h3><ul>
<li>需求: 为根类NSObject添加属性,不准使用继承;</li>
<li>思路: 如果要扩展某个系统类,不使用继承就只有使用分类了,但是在分类中使用property只会生成setter和getter方法并不会生成成员变量.</li>
<li><p>实现步骤:</p>
<ol>
<li><p>在分类的.h文件中添加属性接口</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为只会生成setter和getter方法,写上修饰属性的关键字没有意义(nonatomic, strong)</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *myProperty;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在分类的.m文件中实现setter和getter方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setter方法</span></span><br><span class="line"> - (<span class="keyword">void</span>)setMyProperty:(<span class="built_in">NSString</span> *)myProperty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加成员属性</span></span><br><span class="line">    <span class="comment">// 参数1: 给那个对象添加成员属性</span></span><br><span class="line">    <span class="comment">// 参数2: 添加的成员属性名</span></span><br><span class="line">    <span class="comment">// 参数3: 添加的成员属性值</span></span><br><span class="line">    <span class="comment">// 参数4: 属性策略 - RETAIN_NONATOMIC ==&gt; (nonatomic, strong)</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="string">"property"</span>, myProperty, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getter方法</span></span><br><span class="line"> - (<span class="built_in">NSString</span> *)myProperty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回成员属性</span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="string">"property"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="MJExtension框架中字典转模型的原理">MJExtension框架中字典转模型的原理</h3><ul>
<li>一句话概括: 利用运行时获取对象中所有成员变量, 然后将成员变量名与字典中的key名进行比对,将比对成功的成员变量进行赋值.</li>
<li>思路: 为基类添加一个分类, 让所有的类都能调用这个方法.</li>
<li>要注意的细节: <ul>
<li>如果字典中嵌套字典;</li>
<li>如果字典中嵌套字典数组;</li>
</ul>
</li>
<li><p>具体实现的代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认返回nil, 有数组字典需要转成模型时需要在外部重写这个方法</span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)arrayContentModelClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入一个字典将其转成模型</span></span><br><span class="line">+ (instancetype)objectWithDict:(<span class="built_in">NSDictionary</span> *)dict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个id对象</span></span><br><span class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    <span class="comment">// 遍历类中所有的成员变量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ivarCount = <span class="number">0</span>;</span><br><span class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;ivarCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ivarCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 取出成员变量</span></span><br><span class="line">        Ivar ivar = ivarList[i];</span><br><span class="line">        <span class="comment">// 取出成员的类型名称字符串 @"@\"classname\""</span></span><br><span class="line">        <span class="built_in">NSString</span> *classname = @(ivar_getTypeEncoding(ivar));</span><br><span class="line">        <span class="comment">// 截取出类型名字</span></span><br><span class="line">        classname = [classname stringByReplacingOccurrencesOfString:<span class="string">@"\""</span> withString:<span class="string">@""</span>];</span><br><span class="line">        classname = [classname stringByReplacingOccurrencesOfString:<span class="string">@"@"</span> withString:<span class="string">@""</span>];</span><br><span class="line">        <span class="comment">// 截取出所有成员变量的名称</span></span><br><span class="line">        <span class="built_in">NSString</span> *ivarName = [@(ivar_getName(ivar)) substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拿到属性名与字典的key名一样的值, 如果字典中找不到跟key名一样的属性名那么value为nil</span></span><br><span class="line">        <span class="keyword">id</span> value = dict[ivarName];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 二级转换 - 当value为字典时 */</span></span><br><span class="line">        <span class="comment">// 当值的类型是字典并且是自定义类型的时候, 取出类名, 再转一次</span></span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> class]] &amp;&amp; ![classname hasPrefix:<span class="string">@"NS"</span>]) &#123;</span><br><span class="line">            value = [<span class="built_in">NSClassFromString</span>(classname) objectWithDict:value];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 三级转换 - 当value为字典数组时 */</span></span><br><span class="line">        <span class="comment">// 问题: 将数组中的字典转成哪个类?</span></span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> class]]) &#123;</span><br><span class="line">            <span class="comment">// 当一个数组字典想要转成一个模型时,必须要实现这个方法: arrayContentModelClass</span></span><br><span class="line">            <span class="comment">// 如果不做判断, 那么在数据源中有数组的而没有实现这个方法的话就会报找不到方法的错</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> arrayContentModelClass] != <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="comment">// key:数组名 ; value:模型类名</span></span><br><span class="line">                <span class="built_in">NSDictionary</span> *classDict = [<span class="keyword">self</span> arrayContentModelClass];</span><br><span class="line">                <span class="built_in">NSArray</span> *array = value;</span><br><span class="line">                <span class="built_in">NSMutableArray</span> *arrM = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">                <span class="comment">// 遍历数组</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> array) &#123;</span><br><span class="line">                    <span class="comment">// 根据当前成员变量名取出来的值就是类名字符串, 再将字符串转成类</span></span><br><span class="line">                    <span class="keyword">id</span> tempValue = [<span class="built_in">NSClassFromString</span>(classDict[ivarName]) objectWithDict:dict];</span><br><span class="line">                    <span class="comment">// 当类名写错时 对象会没有值, 数组中不能添加nil, 所以要做这个容错处理</span></span><br><span class="line">                    <span class="keyword">if</span> (tempValue == <span class="literal">nil</span>) &#123;</span><br><span class="line">                        arrM = value;</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@"创建模型失败, 找不到类..."</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        [arrM addObject:tempValue];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                value = [<span class="built_in">NSArray</span> arrayWithArray:arrM];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当value有值时才进行赋值</span></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="comment">// 利用kvc赋值</span></span><br><span class="line">            [objc setValue:value forKey:ivarName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有数组字典时,在模型类中重写</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 说明将要把数组里面的字典转成哪个模型</span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)arrayContentModelClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将哪个数组中的字典元素转成哪个类</span></span><br><span class="line">    <span class="keyword">return</span> @&#123; <span class="string">@"pic_urls"</span> : <span class="string">@"XVPicURL"</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="利用消息转发给程序三次起死回生的机会">利用消息转发给程序三次起死回生的机会</h2><p><img src="http://images.cnitblog.com/i/31852/201404/231837047638961.png" alt=""></p>
<ul>
<li>在程序运行时如果找不到实现方法,系统会给程序几次机会来使能够程序正常运行,实在没出路了才会抛出异常.</li>
<li>三次补救机会<ol>
<li>动态方法解析,<code>resolveInstanceMethod</code> 给类一个动态添加方法的机会,前面已经提及.</li>
<li>快速消息转发,<code>forwardingTargetForSelector:</code>将SEL转给其他对象实现的机会;</li>
<li>标准消息转发,<code>methodSignatureForSelector:</code>(函数符号制造器)让重载方有机会抛出一个函数的签名,再由<code>forwardInvocation:</code>(函数执行器)去执行这个函数.</li>
</ol>
</li>
<li>具体流程参考: <a href="http://blog.csdn.net/yiyaaixuexi/article/details/8970734" target="_blank" rel="external">Objective-C 的“多继承”</a></li>
</ul>
<h2 id="self与super">self与super</h2><ul>
<li><p>看过一个题目是这样的: 问打印结果是什么?</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> class]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>答案: 都输出 Son.</p>
</li>
<li>本质上super是一个编译指示器, 它并不是一个指针, 它仅仅是表示调用父类的方法,但是调用者仍然是当前对象,跟父类没有关系.也就是说上面的例子不管调用<code>[self class]</code>还是<code>[super class]</code>,接受消息的对象都是当前<code>Son</code>这个对象.</li>
<li>当使用self调用方法时,会从当前类的方法列表中开始找,如果没有,就从父类中再找;而当使用super时,则从父类的方法列表中开始找.然后调用父类的这个方法.</li>
<li><code>[super superClass]</code>等价于<code>[self superClass]</code>表示获取当前方法调用者的父类.</li>
</ul>
<p>参考:</p>
<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></li>
<li><a href="http://www.cocoachina.com/ios/20141008/9844.html" target="_blank" rel="external">理解 Objective-C Runtime</a></li>
<li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="external">Objective-C Runtime</a></li>
</ul>
<p>拓展阅读:</p>
<ul>
<li><a href="http://www.cocoachina.com/ios/20141224/10740.html" target="_blank" rel="external">刨根问底Objective－C Runtime</a></li>
<li><a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RunLoop基础知识]]></title>
      <url>http://xionv.com/2015/09/13/demonayu/blog/37.RunLoop%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h2 id="什么是RunLoop">什么是RunLoop</h2><ul>
<li>RunLoop: 运行循环, 顾名思义就是跑圈, 兜圈子的意思. 一个应用程序能够一直运行而不会退出就是基于这种机制.</li>
<li>基本作用:<ol>
<li>保持程序持续运行, 相当于一个死循环;</li>
<li>处理应用程序中的各种事件, 比如触摸事件, 定时器事件等;</li>
<li>它的作用机制是有就做事, 没事就待命休息, 节省资源;</li>
</ol>
</li>
<li>主RunLoop: 当程序一启动系统就会在main函数中调用<code>UIApplicationMain()</code>这个函数, 该函数会在程序的主线程中开启一个RunLoop一直保持程序的运行.</li>
<li>自动释放池什么时候创建和释放?<ol>
<li>第一次创建,是在RunLoop进入的时候创建,对应的状态 = kCRunLoopEntry</li>
<li>最后一释放,是在RunLoop时候,对应的状态 = kCFRuRunLoopExit</li>
<li>它创建和释放,每次睡觉的时候都会释放前自动释放池,然后再建一个新的.</li>
</ol>
</li>
<li>RunLoop对象 <ol>
<li>在iOS开发中有两套api访问RunLoop<ul>
<li>Foundation框架<code>NSRunLoop</code></li>
<li>Core Foundation框架<code>CFRunLoopRef</code></li>
</ul>
</li>
<li>这个两个框架中所代表RunLoop是等价的.</li>
<li>NSRunLoop基于<code>CFRunLoopRef</code>的一层OC封装.</li>
</ol>
</li>
<li>RunLoop与线程 <ol>
<li>每一个线程都有一个与之对应的RunLoop对象.</li>
<li>RunLoop生命周期与子线程息息相关,当子线程被销毁时,与之对应的RunLoop也会被销毁.</li>
<li>子线程的RunLoop要程序员手动开启.</li>
</ol>
</li>
<li><p>获取RunLoop对象:</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 获当前的RunLoop对象</span></span><br><span class="line"><span class="comment">// NSRunLoop</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *runLoop1 = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="comment">// CFRunLoopRef</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> runLoop2 = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="comment">// 2. 拿到当前应用程序的主RunLoop(主线程RunLoop)</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *mainRunLoop = [<span class="built_in">NSRunLoop</span> mainRunLoop];</span><br><span class="line"><span class="built_in">CFRunLoopRef</span> mainRunLoop = <span class="built_in">CFRunLoopGetMain</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>在子线程中如果不主动获取RunLoop的话,那么在子线程内部是不会主动创建RunLoop的.</li>
<li>在子线程中创建一个RunLoop对象不是通过<code>alloc init</code>方法创建,而是直接调用currentRunLoop方法,而且这个方法本身就是一个懒加载,所以在该线程中RunLoop对象只会被创建一次.</li>
<li>RunLoop对象是利用字典以当前的线程作为key来进行储存的.</li>
</ul>
</li>
</ul>
<h2 id="RunLoop相关类">RunLoop相关类</h2><ul>
<li>RunLoop的运行原理<br> <img src="http://r5.loli.io/AzUZFb.png" alt="RunLoop的运行原理图"></li>
<li>Core Foundation关于RunLoop的五个类<ul>
<li>CFRunLoopRef (RunLoop抽象类)</li>
<li>CFRunLoopModeRef (RunLoop的运行模式)</li>
<li>CFRunLoopSourceRef (RunLoop要处理的事件源)</li>
<li>CFRunLoopTimerRef (Timer事件)</li>
<li>CFRunLoopObserverRef (RunLoop的观察者/监听者)</li>
</ul>
</li>
<li>RunLoop和相关类之间的关系图<br><img src="http://r.loli.io/nIFNja.png" alt=""><br> <img src="http://r6.loli.io/AnI3eu.png" alt="RunLoop和相关类之间的关系图"></li>
</ul>
<h3 id="RunLoop的运行模式">RunLoop的运行模式</h3><ul>
<li>每一个RunLoop运行必须要指定一个模式,而且必须要有source和timer,如果子线程的NSRunLoop没有设置source和timer,那么子线程的RunLoop会立刻关闭.</li>
<li>一个RunLoop可以有多个模式,一个模式可以有多个source\observer\timer.</li>
<li>如果需要切换mode,只能先退出当前RunLoop,再重新指定一个模式.</li>
<li>系统默认提供了5个模式:<ul>
<li>kCFRunLoopDefaultMode: App的默认Mode,通常主线程是在这个Mode下运行,与NSDefaultRunLoopMode等价;</li>
<li>UITrackingRunLoopMode: 界面跟踪Mode, 用于ScrollView追踪触摸滑动, 保证界面滑动时不受其他Mode影响;</li>
<li>UIInitializationRunLoopMode: 在刚启动App时第进入的第一个Mode, 启动完成后就不再使用;</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部Mode, 通常用不到;</li>
<li>kCFRunLoopCommonModes: 这是一个占位用的Mode,不是一种真正的Mode.</li>
</ul>
</li>
</ul>
<h3 id="CFRunLoopTimerRef_时间源">CFRunLoopTimerRef 时间源</h3><ul>
<li>CFRunLoopTimerRef: 它是基于时间的触发器约等于<code>NSTimer</code>, 说直白点那就是时间到了就触发一个事件, 执行一个操作.</li>
<li>一个mode里面可以添加多个NSTimer,也就是说以后创建NSTimer的时候,可以指定它是在什么模式下运行,从侧面说明了 NSTimer就是CFRunLoopTimerRef.</li>
<li><p>在主线程中使用定时器</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建定时器</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 2.1 把定时器添加到runLoop,选择默认运行模式(只有当runLoop处于默认模式时,定时器才工作)</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"><span class="comment">// 2.2 把定时器添加到runLoop,选择界面跟踪模式(只有当runLoop处于界面跟踪模式时,定时器才工作)</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">UITrackingRunLoopMode</span>];</span><br><span class="line"><span class="comment">// 2.3 把定时器添加被标记的RunLoop(意味着当前的定时器会被添加到所有被标记为Common Modes的运行模式下面)</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>在子线程中使用定时器</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建子线程RunLoop</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *currentRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="comment">//2.创建定时器对象,会把当前的定时器对象自动添加到runLoop,并设定为默认模式</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer =  [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">//3.子线程对应的runLoop需要手动开启</span></span><br><span class="line">[currentRunLoop run];</span><br></pre></td></tr></table></figure>
</li>
<li><p>GCD中的定时器(注：GCD的定时器跟runloop没有什么关系，它们是两套系统)</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1.创建GCD定时器对象</span></span><br><span class="line"> <span class="comment">// 第一个参数:source的类型DISPATCH_SOURCE_TYPE_TIMER 定时器</span></span><br><span class="line"> <span class="comment">// 第二个参数:描述信息 传递0</span></span><br><span class="line"> <span class="comment">// 第三个参数:详细的描述 传递0</span></span><br><span class="line"> <span class="comment">// 第四个参数:队列,决定定时器调用的方法在哪个线程执行</span></span><br><span class="line"> dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 2.设定时器(开始时间|间隔时间|精准度)</span></span><br><span class="line"> <span class="comment">// 第一个参数:imer 定时器对象</span></span><br><span class="line"> <span class="comment">// 第二个参数:开始计时的时间:DISPATCH_TIME_NOW --从现在开始</span></span><br><span class="line"> <span class="comment">// 第三个参数:间隔时间 2.0</span></span><br><span class="line"> <span class="comment">// 第四个参数:精准度 如果要求对准确的话,传0(误差)</span></span><br><span class="line"> <span class="comment">// GCD时间单位:纳秒</span></span><br><span class="line"> dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 3.定时器要执行的操作</span></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"download ----%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 4.恢复 (启动执行)</span></span><br><span class="line"> dispatch_resume(timer);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// GCD定时器补充 - source的类型</span></span><br><span class="line"> <span class="comment">// DISPATCH_SOURCE_TYPE_TIMER         定时响应（定时器事件）</span></span><br><span class="line"> <span class="comment">// DIPATCH_SOURCE_TYPE_SIGNAL        接收到UNIX信号时响应</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// DISPATCH_SOURE_TYPE_READ          IO操作，如对文件的操作、socket操作的读响应</span></span><br><span class="line"> <span class="comment">// DISPATCH_SOURCE_TYPE_WRITE         IO操作，如对文件的操作、socket操作的写响应</span></span><br><span class="line"> <span class="comment">// DISPATCH_SOURCE_TYPE_VNODE         文件状态监听，文件被删除、移动、重命名</span></span><br><span class="line"> <span class="comment">// DISPATCH_SOURCE_TYPE_PROC          进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 下面两个都属于Mach相关事件响应</span></span><br><span class="line">     <span class="comment">// DISPATCH_SOURCE_TYPE_MACH_SEND</span></span><br><span class="line">     <span class="comment">// DISPATCH_SOURCE_TYPE_MACH_RECV</span></span><br><span class="line"> <span class="comment">// 下面两个都属于自定义的事件，并且也是有自己来触发</span></span><br><span class="line">     <span class="comment">// DISPATCH_SOURCE_TYPE_DATA_ADD</span></span><br><span class="line">     <span class="comment">// DISPATCH_SOURCE_TYPE_DATA_OR</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="CFRunLoopSourceRef_事件源">CFRunLoopSourceRef 事件源</h3><ul>
<li>事件源也就是输入源,可能包括用户输入设备(如点击button),网络链接(socket收到数据),定期或时间延迟事件(NSTimer),还有异步回调(NSURLConnection的异步请求).</li>
<li><p>有两种分类模式:</p>
<ul>
<li>一种是按照苹果官方文档进行划分<ul>
<li>Port-Based Sources</li>
<li>Custom Input Sources</li>
<li>Cocoa Perform Selector Sources</li>
</ul>
</li>
<li>一种是基于函数的调用栈来进行划分(source0和source1)<ul>
<li>Source1: 基于端口(port)的输入源(系统内部调用, 比如线程间通信). 它只包含了一个回调(函数指针), 并不能主动触发事件. 使用时你需要先调用CFRunLoopSourceSignal(source), 将这个Source标记为待处理, 然后手动调用CFRunLoopWakeUp(runloop) 来唤醒RunLoop, 让其处理这个事件.</li>
<li>Source0: 基于非端口的输入源 (主动触发, 比如用户的交互). 包含了一个mach_port和一个回调(函数指针), 被用于通过内核和其他线程相互发送消息. 这种Source能主动唤醒RunLoop的线程.</li>
</ul>
</li>
</ul>
</li>
<li><p>添加输入源<code>[performSelector:OnThread]</code>. Cocoa提供了可以在任一线程执行函数<code>[perform selector]</code>的输入源, 和基于端口的源不同的是, <code>[perform selector]</code>执行完后会自动清除出RunLoop. </p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送消息给主线程并且是否等待任务执行完成(下面一个方法是指定RunLoop模式)</span></span><br><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:  </span><br><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:modes:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息给指定的线程并且是否等待任务执行完成</span></span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:  </span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:modes:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息给主线程延迟调用方法</span></span><br><span class="line">performSelector:withObject:afterDelay:</span><br><span class="line">performSelector:withObject:afterDelay:inModes:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消当前线程的消息发送</span></span><br><span class="line">cancelPreviousPerformRequestsWithTarget:  </span><br><span class="line">cancelPreviousPerformRequestsWithTarget:selector:object:</span><br></pre></td></tr></table></figure>
<ul>
<li>当调用NSObject的<code>performSelecter:afterDelay:</code>后, 实际上其内部会创建一个<code>Timer</code>并添加到当前线程的RunLoop中. 所以如果当前线程没有开启RunLoop, 这个方法则会失效. </li>
<li>当调用<code>performSelector:onThread:</code>时, 实际上其会创建一个<code>Timer</code>加到对应的线程去, 同样的如果对应线程没有开启RunLoop该方法也会失效.</li>
</ul>
</li>
</ul>
<h3 id="CFRunLoopObserverRef_观察者">CFRunLoopObserverRef 观察者</h3><ul>
<li>CFRunLoopObserverRef是观察者,能够监听RunLoop的状态改变</li>
<li>如何监听 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建观察者</span></span><br><span class="line"><span class="comment">// 第一个参数:分配空间</span></span><br><span class="line"><span class="comment">// 第二个参数:要监听的状态</span></span><br><span class="line"><span class="comment">// 第三个参数:YES 持续监听</span></span><br><span class="line"><span class="comment">// 第四个参数:和优先级相关 总是传递0</span></span><br><span class="line"><span class="comment">// 第五个参数:当发现runLoop状态改变的时候就会调用该block</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), k<span class="built_in">CFRunLoopAllActivities</span>, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopEntry</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"启动runLoop"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopBeforeTimers</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"即将处理定时器事件"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopBeforeSources</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"即将处理source事件"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopBeforeWaiting</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"即将休眠"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopAfterWaiting</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"刚从休眠中唤醒"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopExit</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"runLoop退出"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.给runLoop添加观察者</span></span><br><span class="line"><span class="comment">// 第一个参数:runLoop对象</span></span><br><span class="line"><span class="comment">// 第二个参数:观察者对象</span></span><br><span class="line"><span class="comment">// 第三个参数:运行模式(要监听那种模式下状态的改变)</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, k<span class="built_in">CFRunLoopDefaultMode</span>);</span><br><span class="line"><span class="comment">// 3.开启定时器</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(demo) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="RunLoop运行逻辑详情">RunLoop运行逻辑详情</h2><p><img src="http://r5.loli.io/ZrimYv.png" alt="示意图"><br><img src="http://r6.loli.io/NNn26b.png" alt="逻辑详情"></p>
<h2 id="补充">补充</h2><ul>
<li><p>从上图可以看出:</p>
<ul>
<li>如果是事件到达,消息会被传递给相应的处理程序来处理,runLoop处理完当次事件后,runLoop会退出,而不管之前预定的时间到了没有.你可以重新启动runLoop来等待下一事件.</li>
<li>如果线程中有需要处理的源,但是响应的事件没有到来的时候,线程就会休眠等待相应事件的发生.这就是为什么runLoop可以做到让线程有工作的时候忙于工作,而没工作的时候处于休眠状态.</li>
</ul>
</li>
<li><p>什么时候使用runLoop:</p>
<ul>
<li>仅当在为你的程序创建辅助线程的时候,你才需要显式运行一个run loop.RunLoop是程序主线程基础设施的关键部分.所以,Cocoa和Carbon程序提供了代码运行主程序的循环并自动启动runLoop.iOS程序中UIApplication的run方法作为程序启动步骤的一部分,它在程序正常启动的时候就会启动程序的主循环.类似的,RunApplicationEventLoop函数为Carbon程序启动主循环.如果你使用xcode提供的模板创建你的程序,那你永远不需要自己去显式的调用这些例程.</li>
<li>对于辅助线程,你需要判断一个runLoop是否是必须的.如果是必须的,那么你要自己配置并启动它.你不需要在任何情况下都去启动一个线程的runLoop.比如.你使用线程来处理一个预先定义的长时间运行的任务时,你应该避免启动runLoop.RunLoop在你要和线程有更多的交互时才需要,比如以下情况:<ul>
<li>使用端口或自定义输入源来和其他线程通信</li>
<li>使用线程的定时器</li>
<li>Cocoa中使用任何performSelector…的方法</li>
<li>使线程周期性工作.</li>
</ul>
</li>
</ul>
</li>
<li>AFNetWorking 这个框架就是这么干的, 当第一次创建一个manager单例时, 它就会开辟一个子线程同时开启一个runloop, 然后手动维护这个runloop, 来持续监听事件的接收.<br><img src="http://r5.loli.io/aYZnYf.png" alt=""></li>
</ul>
<p>参考: <a href="http://www.cocoachina.com/ios/20150601/11970.html" target="_blank" rel="external">深入理解RunLoop</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[封装NavigationController基类]]></title>
      <url>http://xionv.com/2015/08/06/demonayu/blog/36.%E5%B0%81%E8%A3%85NavigationController%E5%9F%BA%E7%B1%BB/</url>
      <content type="html"><![CDATA[<blockquote>
<p>目前绝大多数应用的各个子控制器的NavigationBar都是是统一风格的,封装Nav一劳永逸.</p>
</blockquote>
<ul>
<li><p>第一步</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在第一次使用这个类的时候初始化成员属性</span></span><br><span class="line">+ (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 获取所有导航控制器的bar实例</span></span><br><span class="line">    <span class="built_in">UINavigationBar</span> *navbar = [<span class="built_in">UINavigationBar</span> appearance];</span><br><span class="line">    <span class="comment">// 1.1 设置导航条字体</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    dict[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">17</span>];</span><br><span class="line">    [navbar setTitleTextAttributes:dict];</span><br><span class="line">    <span class="comment">// 1.2 设置导航条背景图片</span></span><br><span class="line">    [navbar setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"navigationbar_background_landscape"</span>] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">    <span class="comment">// 1.3 设置导航栏分割线为透明</span></span><br><span class="line">    [navbar setShadowImage:[[<span class="built_in">UIImage</span> alloc] init]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 获取所有导航控制器的item实例</span></span><br><span class="line">    <span class="built_in">UIBarButtonItem</span> *barBtn = [<span class="built_in">UIBarButtonItem</span> appearance];</span><br><span class="line">    <span class="comment">// 2.1 设置barButton的文字普通状态下的属性</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *barBtnAttributesN = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    barBtnAttributesN[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">    barBtnAttributesN[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">        <span class="comment">// 设置普通状态</span></span><br><span class="line">    [barBtn setTitleTextAttributes:barBtnAttributesN forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    <span class="comment">// 2.2 设置barButton的文字不可用状态下的属性</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *barBtnAttributesS = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    barBtnAttributesS[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    barBtnAttributesS[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">        <span class="comment">// 设置不可用状态</span></span><br><span class="line">    [barBtn setTitleTextAttributes:barBtnAttributesS forState:<span class="built_in">UIControlStateDisabled</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 添加一个边缘滑动手势</span></span><br><span class="line">    <span class="built_in">UIScreenEdgePanGestureRecognizer</span> *edgePan = [[<span class="built_in">UIScreenEdgePanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(edgePan:)];</span><br><span class="line">    edgePan<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 方向为左划</span></span><br><span class="line">    edgePan<span class="variable">.edges</span> = <span class="built_in">UIRectEdgeLeft</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addGestureRecognizer:edgePan];</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#pragma mark - 监听手势方法</span></span><br><span class="line">- (<span class="keyword">void</span>)edgePan:(<span class="built_in">UIScreenEdgePanGestureRecognizer</span> *)edgePan</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三步</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写push方法</span></span><br><span class="line">- (<span class="keyword">void</span>)pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当不是根控制器时</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.viewControllers</span><span class="variable">.count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 隐藏tabBar</span></span><br><span class="line">        viewController<span class="variable">.hidesBottomBarWhenPushed</span> = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">// 自定义导航栏左边按钮</span></span><br><span class="line">        <span class="built_in">UIButton</span> *leftBtn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">        [leftBtn setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"navigationbar_back"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        [leftBtn setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"navigationbar_back_highlighted"</span>] forState:<span class="built_in">UIControlStateHighlighted</span>];</span><br><span class="line">        [leftBtn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(backPress) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">        [leftBtn sizeToFit];</span><br><span class="line">        viewController<span class="variable">.navigationItem</span><span class="variable">.leftBarButtonItem</span> = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithCustomView:leftBtn];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置完毕后调用父类的push方法</span></span><br><span class="line">    [<span class="keyword">super</span> pushViewController:viewController animated:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)backPress</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四步</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - UIGestureRecognizerDelegate</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不允许在根控制器使用返回手势</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.childViewControllers</span><span class="variable">.count</span> &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[单例设计模式]]></title>
      <url>http://xionv.com/2015/08/03/demonayu/blog/35.Singleton/</url>
      <content type="html"><![CDATA[<h1 id="单例模式概念">单例模式概念</h1><ul>
<li><p>什么是单例模式:(Singleton)</p>
<ul>
<li>单例模式的意图是让类的对象成为系统中唯一的实例,􏰀供一个访问点,供客户类共享资源。</li>
</ul>
</li>
<li><p>什么情况下使用单例?</p>
<ul>
<li>1、类只能有一个实例,而且必须从一个为人熟知的访问点对其进行访问,比如工厂方法。</li>
<li>2、这个唯一的实例只能通过子类化进行扩展,而且扩展的对象不会破坏客户端代码。</li>
</ul>
</li>
<li><p>单例设计模式的要点:</p>
<ul>
<li>1) 某个类只能有一个实例;</li>
<li>2) 他必须自行创建这个对象;</li>
<li>3) 必须自行向整个系统􏰀供这个实例;</li>
<li>4) 为了保证实例的唯一性,我们必须将;</li>
<li>5) 这个方法必须是一个静态类;</li>
</ul>
</li>
</ul>
<h1 id="单例模式宏,预处理ARC和MRC">单例模式宏,预处理ARC和MRC</h1><a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#define interfaceSingleton(name)  +(instancetype)share##name</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if __has_feature(objc_arc)</span></span><br><span class="line"><span class="comment">// ARC</span></span><br><span class="line"><span class="preprocessor">#define implementationSingleton(name)  \</span></span><br><span class="line">+ (instancetype)share<span class="preprocessor">##name \</span></span><br><span class="line">&#123; \</span><br><span class="line">name *instance = [[<span class="keyword">self</span> alloc] init]; \</span><br><span class="line"><span class="keyword">return</span> instance; \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">static</span> name *_instance = <span class="literal">nil</span>; \</span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">_instance = [[<span class="keyword">super</span> allocWithZone:zone] init]; \</span><br><span class="line">&#125;); \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone&#123; \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#else</span></span><br><span class="line"><span class="comment">// MRC</span></span><br><span class="line"><span class="preprocessor">#define implementationSingleton(name)  \</span></span><br><span class="line">+ (instancetype)share<span class="preprocessor">##name \</span></span><br><span class="line">&#123; \</span><br><span class="line">name *instance = [[<span class="keyword">self</span> alloc] init]; \</span><br><span class="line"><span class="keyword">return</span> instance; \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">static</span> name *_instance = <span class="literal">nil</span>; \</span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">_instance = [[<span class="keyword">super</span> allocWithZone:zone] init]; \</span><br><span class="line">&#125;); \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone&#123; \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>)release \</span><br><span class="line">&#123; \</span><br><span class="line">&#125; \</span><br><span class="line">- (instancetype)retain \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">return</span>  MAXFLOAT; \</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UIButton调换文字与图片位置的两种方法]]></title>
      <url>http://xionv.com/2015/08/02/demonayu/blog/34.UIButton%E8%B0%83%E6%8D%A2%E6%96%87%E5%AD%97%E4%B8%8E%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>假设自定义一个UIButton控件, 然后在button里面初始化了一个title和一个image:<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置button文字</span></span><br><span class="line">        [<span class="keyword">self</span> setTitle:<span class="string">@"title"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        <span class="comment">// 设置button图片</span></span><br><span class="line">        [<span class="keyword">self</span> setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        <span class="comment">// 设置文字大小</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.titleLabel</span><span class="variable">.font</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">17</span>];</span><br><span class="line">        <span class="comment">// 设置图片居中</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.contentMode</span> = <span class="built_in">UIViewContentModeCenter</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="第一种_-_重写layoutSubviews方法来实现">第一种 - 重写<code>layoutSubviews</code>方法来实现</h3><ol>
<li><p>重写<code>layoutSubviews</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    <span class="comment">// 修改titleButton里面子控件的位置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.frame</span><span class="variable">.origin</span><span class="variable">.x</span> &lt; <span class="keyword">self</span><span class="variable">.titleLabel</span><span class="variable">.frame</span><span class="variable">.origin</span><span class="variable">.x</span>) &#123; </span><br><span class="line">        <span class="comment">// 1. 取出title和image的frame</span></span><br><span class="line">        <span class="built_in">CGRect</span> titleFrame = <span class="keyword">self</span><span class="variable">.titleLabel</span><span class="variable">.frame</span>;</span><br><span class="line">        <span class="built_in">CGRect</span> imageFrame = <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.frame</span>;</span><br><span class="line">        <span class="comment">// 2. 调整title和imageView的x值</span></span><br><span class="line">        titleFrame<span class="variable">.origin</span><span class="variable">.x</span> = imageFrame<span class="variable">.origin</span><span class="variable">.x</span>;</span><br><span class="line">        imageFrame<span class="variable">.origin</span><span class="variable">.x</span> = <span class="built_in">CGRectGetMaxX</span>(titleFrame) + <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 3. 重新赋值</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.titleLabel</span><span class="variable">.frame</span> = titleFrame;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.frame</span> = imageFrame;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写<code>setImage: forState:</code>和<code>setTitle: forState:</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写父类setImage方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setImage:(<span class="built_in">UIImage</span> *)image forState:(<span class="built_in">UIControlState</span>)state</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setImage:image forState:state];</span><br><span class="line">    <span class="comment">// 自动计算尺寸</span></span><br><span class="line">    [<span class="keyword">self</span> sizeToFit];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 重写父类setTitle方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setTitle:(<span class="built_in">NSString</span> *)title forState:(<span class="built_in">UIControlState</span>)state</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setTitle:title forState:state];</span><br><span class="line">    <span class="comment">// 自动计算尺寸</span></span><br><span class="line">    [<span class="keyword">self</span> sizeToFit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第二种_-_重写titleRectForContentRect:和imageRectForContentRect:方法来实现">第二种 - 重写<code>titleRectForContentRect:</code>和<code>imageRectForContentRect:</code>方法来实现</h3><ol>
<li><p>重写<code>titleRectForContentRect:</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回文字的位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)titleRectForContentRect:(<span class="built_in">CGRect</span>)contentRect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> titleX = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> titleY = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> titleW = [<span class="keyword">self</span><span class="variable">.currentTitle</span> boundingRectWithSize:<span class="built_in">CGSizeMake</span>(MAXFLOAT, MAXFLOAT)</span><br><span class="line">                                                     options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span></span><br><span class="line">                                                  attributes:@&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">17</span>]&#125;</span><br><span class="line">                                                     context:<span class="literal">nil</span>]<span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> titleH = contentRect<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(titleX, titleY, titleW, titleH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写<code>imageRectForContentRect:</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回图片位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)imageRectForContentRect:(<span class="built_in">CGRect</span>)contentRect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageW = <span class="number">16</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageH = contentRect<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageX = contentRect<span class="variable">.size</span><span class="variable">.width</span> - imageW;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageY = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(imageX, imageY, imageW, imageH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GCD的一些总结]]></title>
      <url>http://xionv.com/2015/07/21/demonayu/blog/33.GCD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="队列与任务">队列与任务</h2><ul>
<li>同步: 同步任务,不开新线程,会阻塞当前线程.</li>
<li>异步: 异步任务,开新线程,不会阻塞当前线程.</li>
<li>串行: 串行队列,串行是按顺序排队执行任务,不会出现资源抢夺的问题,所以它默认是线程安全的.</li>
<li>并行: 并行队列,多条线程同时执行任务,可能会导致多条线程抢夺同一块资源.所以它默认是线程不安全的,所以在一条线程访问一块资源时需要进行加锁处理;<br><img src="http://r6.loli.io/If22Iv.png" alt=""></li>
</ul>
<h3 id="主队列">主队列</h3><ul>
<li><p>主队列</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> main_queue= dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<ol>
<li>所有与UI界面相关的操作都在主队列中执行.</li>
<li>主队列只有一条主线程,所以它默认是串行的.</li>
<li>在主队列中执行异步函数并不会开新的线程,所有任务默认都是在主线程执行.</li>
<li><p>不要在主队列中执行同步函数,这样会产生死锁的问题.因为主队列默认只有一条主线程,如果在主队列添加一个同步任务,会马上执行这个同步任务.而主队列当前要执行的任务并没有结束,不肯放手.两个的优先级都很高,最终导致死锁.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在主线程执行一个同步函数 - 会发生死锁</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(main_queue, ^&#123;</span><br><span class="line">    <span class="comment">// 这句代码永远不会执行</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这句代码永远不会执行</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"方法执行完毕"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在主队列执行异步函数,那么异步函数要执行的任务会被排到队列的后面,只有当目前这个方法执行完毕后才会过来执行这个任务,如果有多个异步函数,那么任务会依次添加进队列并按顺序执行.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在主线程执行异步函数</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(main_queue, ^&#123;</span><br><span class="line">    <span class="comment">// 再执行这一句</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 先执行这一句</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"方法执行完毕"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="非主队列">非主队列</h3><ul>
<li><p>非主队列</p>
<ul>
<li><p>创建串行非主队列 (默认)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"my_queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并行非主队列</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> concurrent_queue = dispatch_queue_create(<span class="string">"my_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
</li>
<li><p>陷阱1</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在非主队列串行执行一个异步函数</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务开始: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="comment">// 执行异步函数</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</span><br><span class="line">        <span class="comment">/* 这句永远不会执行 */</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务1: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行同步函数</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</span><br><span class="line">        <span class="comment">/* 这句永远不会执行 */</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务2: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/* 这句永远不会执行 */</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务执行完毕"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"方法执行完毕"</span>);</span><br></pre></td></tr></table></figure>
<p>结果: 最后的这个线程会发生死锁.<br><br>分析: 非主队列串行执行异步函数, 这个队列只会开启一条新线程执行任务.<br><br>任务1是一个异步任务,不会阻塞当前线程,执行打它时,它会被挂起,等当前队列所有的同步任务执行完毕后再过来执行它.<br><br>任务2是一个同步任务,同步任务优先级很高,需要马上执行.但是外层的函数并没有执行完毕,不肯放手,所以导致了死锁.</p>
</li>
<li><p>陷阱2</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在非主队列并行执行一个异步函数</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务开始: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="comment">// 执行异步函数</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务1: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行同步函数</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="comment">// 当前任务睡2秒</span></span><br><span class="line">        sleep(<span class="number">2.0</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务2: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行异步函数</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务3: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务执行完毕"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"方法执行完毕"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后的执行顺序是: </p>
<ul>
<li>任务2 -&gt; 任务1 -&gt; 任务3 -&gt; 打印”任务执行完毕”.</li>
<li>任务1 -&gt; 任务2 -&gt; 打印”任务执行完毕” -&gt; 任务3.<br></li>
</ul>
</li>
<li>分析: <ul>
<li>非主队列并发执行异步函数, 可能会开多条线程执行任务.</li>
<li>任务1和任务2的运行优先级是一样的,只是任务1会开启一个新的线程来执行,而任务2是同步函数只会在当前线程执行,并且会阻塞当前线程.</li>
<li>任务3是一个异步函数,它排在任务2之后,而任务2是一个同步函数阻塞了当前线程,所以必须要等任务2执行完毕后才能执行.</li>
</ul>
</li>
<li>思考: <ul>
<li>为什么在并发队列中执行同步函数不会死锁?</li>
<li>在并发队列中执行同步函数是不是就能起到跟栅栏函数一样的作用?</li>
<li>在并发队列中,当前线程起着两个作用,一个是执行任务,另一个是分配线程执行任务.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="全局并发队列">全局并发队列</h3><ul>
<li>全局并发队列<ul>
<li>默认全局来管理并发,类似于自己创建并发队列,可以设置线程调度的优先级,但是一般情况下不建议这么做.因为可能会引发<code>优先级反转</code>.</li>
</ul>
</li>
</ul>
<h2 id="GCD的一些常用函数">GCD的一些常用函数</h2><ul>
<li>通过GCD, 开发者不用再直接跟线程打交道了, 只需要向队列中添加代码块即可, GCD 在后端管理着一个线程池. GCD不仅决定着你的代码块将在哪个线程被执行, 它还根据可用的系统资源对这些线程进行管理. 这样可以将开发者从线程管理的工作中解放出来, 通过集中的管理线程, 来缓解大量线程被创建的问题.</li>
<li>GCD 带来的另一个重要改变是, 作为开发者可以将工作考虑为一个队列, 而不是一堆线程, 这种并行的抽象模型更容易掌握和使用.</li>
</ul>
<h3 id="dispatch_after延迟函数">dispatch_after延迟函数</h3><ul>
<li><p>利用<code>dispatch_after</code>函数延时执行任务</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在主队列延迟2秒后提交任务(这里的时间单位是纳秒)</span></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"在主队列延迟2秒执行"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用<code>performSelector: withObject: afterDelay:</code>延时执行任务</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(run:) withObject:<span class="string">@"延时两秒运行中..."</span> afterDelay:<span class="number">2.0</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用<code>NSTimer</code>延时执行任务</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) userInfo:<span class="string">@"延时两秒运行中..."</span> repeats:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="dispatch_once一次性函数">dispatch_once一次性函数</h3><ul>
<li><p>一次性代码</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dispatch_once 保证代码在程序中只执行一次</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我只会执行一次"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用GCD实现单例</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防止外部文件引用变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> musicRadio;</span><br><span class="line"><span class="comment">// 单例模式的核心就是 重写alloc</span></span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    <span class="comment">// GCD实现单例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        musicRadio = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> musicRadio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用懒加载和同步锁实现单例</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> musicRadio;</span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加同步锁防止资源抢夺</span></span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (musicRadio == <span class="literal">nil</span>) &#123;</span><br><span class="line">        musicRadio = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> musicRadio;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 工厂方法</span></span><br><span class="line">+ (instancetype)shareMusicRadio</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 防止多次加锁</span></span><br><span class="line">    <span class="keyword">if</span> (musicRadio == <span class="literal">nil</span>) &#123; </span><br><span class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (musicRadio == <span class="literal">nil</span>) &#123; <span class="comment">// 防止多次init</span></span><br><span class="line">                musicRadio = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> musicRadio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考: <a href="http://xionv.com/2015/11/29/demonayu/blog/Singleton/">单例模式宏</a></p>
</li>
</ul>
<h3 id="dispatch_barrier栅栏函数">dispatch_barrier栅栏函数</h3><ul>
<li>栅栏函数作用: 在并发队列中实现阻塞.</li>
<li>要想执行完前面所有的任务再执行barrier必须满足两个条件: <ul>
<li>所有任务都是在同一个队列中.</li>
<li>队列不能是全局并行队列, 必须是自己创建的队列.</li>
</ul>
</li>
<li><p>在串行队列中执行同步栅栏函数会发生死锁</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</span><br><span class="line">    dispatch_barrier_sync(serial_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"会死锁!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面示例代码中, 只有等任务3完成后任务4和任务5才能执行.</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个并发的队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrent_queue = dispatch_queue_create(<span class="string">"my_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">// 执行异步函数</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务开始: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务1: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务2: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行栅栏函数</span></span><br><span class="line">    dispatch_barrier_async(concurrent_queue, ^&#123;</span><br><span class="line">        sleep(<span class="number">2.0</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务3: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务4: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务5: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务完毕"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="dispatch_apply迭代函数">dispatch_apply迭代函数</h3><ul>
<li><p>因为GCD的快速迭代是多线程并发的, 所以速度要快于普通的循环结构.</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1: 迭代次数</span></span><br><span class="line"><span class="comment">// 参数2: 执行的队列</span></span><br><span class="line"><span class="comment">// 参数3: 当前迭代的索引</span></span><br><span class="line">dispatch_apply(<span class="number">20</span>, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^(size_t index) &#123;</span><br><span class="line">    <span class="comment">//...需要迭代的代码, 迭代顺序并不确定</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意: 应该避免在串行队列中嵌套使用<code>dispatch_apply</code>, 会引发死锁.下面示例代码打印会永远停留在<code>第一层循环 - 0</code></p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"my_queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_apply(<span class="number">5</span>, serial_queue, ^(size_t i) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一层循环 - %ld"</span>, i);</span><br><span class="line">    dispatch_apply(<span class="number">5</span>, serial_queue, ^(size_t j) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二层循环 - %ld"</span>, j);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行完毕 - %ld"</span>, i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="dispatch_group队列组函数">dispatch_group队列组函数</h3><ul>
<li>很多时候我们需要等待一系列任务执行完成后, 再做一些收尾的工作. 在串行队列中很容易办到, 如果在并行队列中使用组函数也可以达到这样的效果.</li>
<li>组函数简单使用 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个队列组函数</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="comment">// 获得当前全局队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 执行组函数</span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 当所有组函数执行完毕后执行dispatch_group_notify</span></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当任务1和任务2执行完毕后通知执行任务3: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="暂停和恢复队列">暂停和恢复队列</h3><ul>
<li><p>暂停(挂起)队列</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_suspend(concurrent_queue);</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复队列</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_resume(concurrent_queue);</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意: dispatch_suspend并不会立即暂停正在运行的block, 而是在当前block执行完成后, 暂停后续的block执行.</p>
</li>
</ul>
<p>参考:</p>
<ul>
<li><a href="http://objccn.io/issue-2-1/" target="_blank" rel="external">并发编程：API 及挑战</a></li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md" target="_blank" rel="external">GCD高级用法</a></li>
<li><a href="http://tutuge.me/2015/04/03/something-about-gcd/" target="_blank" rel="external">GCD使用经验与技巧浅谈</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSURLConnection和NSURLSession]]></title>
      <url>http://xionv.com/2015/07/19/demonayu/blog/32.NSURLConnection%E5%92%8CNSURLSession%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<h2 id="NSURLConnection">NSURLConnection</h2><h3 id="基本使用">基本使用</h3><ul>
<li><p>有两种请求方式:</p>
<ul>
<li><p>使用block回调:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接使用类方法发送一个异步请求,然后用block回调</span></span><br><span class="line">[<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSError</span> * _Nullable connectionError) &#123;</span><br><span class="line">    <span class="comment">//... 处理返回结果</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用代理方法监听:</p>
<ol>
<li><p>发送一个请求并指定代理</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用代理监听有两种发送请求的方式 */</span></span><br><span class="line"><span class="comment">// 1. 发送请求指定代理,并且立即发送请求</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.connection</span> = [<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 当startImmediately为NO时,请求不会立即执行,而是要等待start方法</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.connection</span> = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</span><br><span class="line"><span class="comment">// 开始发送请求</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.connection</span> start];</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用代理方法来监听请求返回的结果</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"收到响应"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> - (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"收到数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> - (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"下载完成"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="trap1">trap1</h3><ul>
<li><p>在主队列中执行请求</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>分析: 上面这段代码分别执行了几个步骤:<ol>
<li>在当前队列(主队列)建立一个请求任务;</li>
<li>将请求任务放入当前队列线程的runloop,并且指定运行模式为默认模式;</li>
<li>开始发送一个异步下载请求.</li>
</ol>
</li>
<li><p>测试: 在主队列中发送请求,如果此时拖拽界面的控件,下载任务会暂停,停止拖拽后下载任务会自动恢复. 如果<code>指定代理方法在主队列调用</code>或者<code>设定任务在runloop中的调度方式</code>那么会产生不一样的结果.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定代理方法在主队列</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.connection</span> setDelegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</span><br><span class="line"><span class="comment">// 或者: 指定调度模式为 forMode:NSRunLoopCommonModes</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.connection</span> scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>
<p>此时如果拖拽界面并不会阻塞下载任务的执行.</p>
</li>
<li>猜测: 在主队列中发送connection请求是异步的,而且始终只有一条线程就是主线程在执行这个任务.</li>
<li>最后: 在本地使用NSURLConnection下载一个288M的视频文件大概耗时3s左右.如果在子线程进行下载大概耗时1s左右.</li>
</ul>
</li>
</ul>
<h3 id="trap2">trap2</h3><ul>
<li><p>在非主队列中执行发送请求和下载操作</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在全局队列中发送一个异步请求</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 直接开始发送请求</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.connection</span> = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:request delegate:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 在子线程中调用代理方法</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.connection</span> setDelegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 分析: 在上面的代码中, connection的代理方法不会被调用, 因为下载操作是一个持续性的操作, 需要保证执行任务的线程不会被释放,如果指定代理方法在子线程中调用,那么需要在该线程中开启一个runloop才能保证持续接收到返回的数据(原理与在主队列发送请求一样).</p>
</li>
<li><p>改进</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在全局队列中发送一个异步请求</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 发送一个请求并不马上执行</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.connection</span> = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</span><br><span class="line">    <span class="comment">// 在子线程中调用代理方法</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.connection</span> setDelegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">    <span class="comment">// 开始发送请求 - 注:如果是在子线程发送一个请求那么这个方法会默认在子线程开启一个runloop.</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.connection</span> start];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 分析: <code>start</code>方法会在子线程中开启一个runloop来持续接收事件源的输入.调用<code>start</code>方法时要保证至少有一个事件源来驱动runloop的运行.</p>
</li>
</ul>
<h3 id="大文件下载_+_断点续传">大文件下载 + 断点续传</h3><ul>
<li>在使用NSURLConnection进行大文件下载时,如果不进行手动处理的话会消耗大量内存直至程序崩溃.</li>
<li>要进行内存优化必须要使用代理方法来监听下载进度.</li>
<li>核心思想:边下载边存沙盒,拿到当前文件的信息然后拼接.</li>
<li><p>核心步骤:</p>
<ol>
<li><p>初始化一个可变的请求对象并设置请求头信息</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://abc.com/videos/video_01"</span>];</span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line"><span class="comment">// 使用一个全局变量 currentLength 来记录已经下载的字节数</span></span><br><span class="line"><span class="comment">// 设置请求头, 根据数据进度拼接请求, 来判断断点下载的开始范围 ** 断点续传核心代码</span></span><br><span class="line"><span class="built_in">NSString</span> *range = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"bytes=%lld-"</span>, <span class="keyword">self</span><span class="variable">.currentLength</span>];</span><br><span class="line">[request setValue:range forHTTPHeaderField:<span class="string">@"Range"</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>在代理方法<code>didReceiveResponse:</code>新建沙盒文件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 防止文件重复写入, 当已经有数据就不再创建新文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.currentLength</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 新建一个空的缓存文件</span></span><br><span class="line">    <span class="built_in">NSString</span> *cache = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">    <span class="built_in">NSString</span> *filePath = [cache stringByAppendingPathComponent:response<span class="variable">.suggestedFilename</span>];</span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] createFileAtPath:filePath contents:<span class="literal">nil</span> attributes:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// 定义一个句柄成员变量来记录已经下载文件的信息</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.handle</span> = [<span class="built_in">NSFileHandle</span> fileHandleForWritingAtPath:filePath];</span><br><span class="line">    <span class="comment">// 根据响应头获得文件总大小</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.totalLength</span> = response<span class="variable">.expectedContentLength</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在代理方法<code>didReceiveData:</code>拼接文件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将写入位置移到文件末尾</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.handle</span> seekToEndOfFile];</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.handle</span> writeData:data];</span><br><span class="line">    <span class="comment">// 记录已经下载文件大小</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.currentLength</span> += data<span class="variable">.length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载完成后需要处理的事情</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.currentLength</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.totalLength</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 文件下载完毕后释放文件句柄</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.handle</span> closeFile];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.handle</span> = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意: 断点续传暂停时要清空当前的下载操作</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)suspend &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.connection</span> cancel];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.connection</span> = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="NSURLSession">NSURLSession</h2><h3 id="基本使用-1">基本使用</h3><ul>
<li><p>NSURLSession的几种任务模式<br><img src="http://techdoc.fd.zol-img.com.cn/g4/M01/02/07/Cg-4WlKjd1eIB4piAAF0o6rDWYsAAOIzwON0NgAAXS7235.png" alt=""></p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类-不具备执行任务功能</span></span><br><span class="line"><span class="built_in">NSURLSessionTask</span></span><br><span class="line"><span class="comment">// 执行普通的GET/POST请求任务</span></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span></span><br><span class="line"><span class="comment">// 执行下载请求任务</span></span><br><span class="line"><span class="built_in">NSURLSessionDownloadTask</span></span><br><span class="line"><span class="comment">// 执行上传请求任务</span></span><br><span class="line"><span class="built_in">NSURLSessionUploadTask</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>NSURLSession工作模式</p>
<ul>
<li>一般模式(default): 工作模式类似于原来的NSURLConnection,可以使用缓存的Cache,Cookie,鉴权.</li>
<li>及时模式(ephemeral): 不使用缓存的Cache,Cookie,鉴权.</li>
<li>后台模式(background): 在后台完成上传下载,创建Configuration对象的时候需要给一个NSString的ID用于追踪完成工作的Session是哪一个.</li>
</ul>
</li>
<li><p>两种请求方式</p>
<ul>
<li><p>使用block回调:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 初始一个会话对象(session)</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"><span class="comment">// 2. 初始化一个data任务</span></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *dataTask = [session dataTaskWithURL:url completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//... 处理返回结果</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 3. 开始任务</span></span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用代理方法监听: </p>
<ol>
<li><p>发送一个请求并指定代理</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化session的工作模式</span></span><br><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *cgr = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line"><span class="comment">// 2. 初始化session并指定代理, 指定调用代理方法的线程</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:cgr delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</span><br><span class="line"><span class="comment">// 3. 初始化一个data任务</span></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *datatask = [session dataTaskWithURL:url];</span><br><span class="line"><span class="comment">// 4. 开始任务</span></span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用代理方法来监听请求返回的结果</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"收到响应"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> - (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"收到数据"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="大文件下载_+_断点续传-1">大文件下载 + 断点续传</h3><ul>
<li>NSURLSession已经默认实现大文件下载和断点续传.其原理也是沙盒缓存原理.</li>
<li><p>也就是说执行下面的操作并不会暴涨内存,系统已经在内部优化好了.</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span><span class="variable">.session</span> downloadTaskWithURL:url];</span><br></pre></td></tr></table></figure>
</li>
<li><p>在执行下载操作时系统默认会把下载的文件存放到沙盒的temp文件夹,如果不进行处理会马上将文件删掉.</p>
</li>
<li><p>核心步骤:</p>
<ol>
<li><p>暂停任务</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)suspend</span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// resumeData包含了继续下载的开始位置和下载的url等信息</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.task</span> cancelByProducingResumeData:^(<span class="built_in">NSData</span> *resumeData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, resumeData<span class="variable">.length</span>);</span><br><span class="line">        weakself<span class="variable">.resumeData</span> = resumeData;</span><br><span class="line">        <span class="comment">// 将task清空释放内存</span></span><br><span class="line">        weakself<span class="variable">.task</span> = <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复任务</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)resume</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 传入上次暂停下载返回的数据，恢复下载 从resumeData接着下载</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.task</span> = [<span class="keyword">self</span><span class="variable">.session</span> downloadTaskWithResumeData:<span class="keyword">self</span><span class="variable">.resumeData</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.task</span> resume];</span><br><span class="line">    <span class="comment">// 将恢复信息释放</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.resumeData</span> = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在代理方法<code>didFinishDownloadingToURL:</code>转移文件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标文件储存路径</span></span><br><span class="line"><span class="built_in">NSString</span> *caches = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line"><span class="built_in">NSString</span> *filePath = [caches stringByAppendingPathComponent:downloadTask<span class="variable">.response</span><span class="variable">.suggestedFilename</span>];</span><br><span class="line"><span class="comment">// 将下载好的文件移到目标路径 - 下载完成后的文件默认在tmp文件夹（location.path），需要转移到其他位置才能查看</span></span><br><span class="line"><span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">[mgr moveItemAtPath:location<span class="variable">.path</span> toPath:filePath error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="细节">细节</h3><ul>
<li><p>配置代理方法的执行队列</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化session并指定代理, 指定调用代理方法的队列为主队列</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:cgr delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 delegateQueue 为 <code>nil</code> 则等同于 <code>[[NSOperationQueue alloc] init]</code> 则不会把获得的数据返回给主线程 (无线程通信)</li>
<li>如果 delegateQueue 为 <code>[NSOperationQueue mainQueue]</code> 则会把获得的数据传给主线程 (有线程通信)</li>
</ul>
</li>
<li><p>在代理方法<code>totalBytesExpectedToWrite:</code>监听下载进度,打印当前的线程为主线程,与NSURLConnection一致.<strong>如果此时拖拽屏幕上的控件却并不会阻塞下载操作</strong>.为什么打印都在主线程,但是一个下载受影响一个不受影响? </p>
<ul>
<li>猜测: <strong>session的下载任务是开辟子线程异步执行的, 然后再将结果返回给主线程.</strong>并不是只有一条线程在处理这个操作,这里与connection有很大不同.并且测试出默认情况下用session下载同一个文件要比connection快,同时下载的时间却与connection开子线程异步下载的时间差不多.故有此猜测(仅仅是猜测).</li>
</ul>
</li>
</ul>
<h2 id="补充">补充</h2><p>还有很多不完善的地方以后慢慢添砖.<br><br>以上的结论有很多仅仅只是猜测,欢迎来打脸.</p>
<p>参考: <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/UsingNSURLSession.html#//apple_ref/doc/uid/TP40013509-SW1" target="_blank" rel="external">苹果官方文档</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSCache的介绍]]></title>
      <url>http://xionv.com/2015/07/14/demonayu/blog/31.NSCache%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这篇文章介绍了如何使用NSCache来替代NSDictionary进行数据缓存.</p>
</blockquote>
<p><a href="http://www.15yan.com/topic/yi-dong-kai-fa-na-dian-shi/45toOUzFGlr/" target="_blank" rel="external">NSCache介绍</a></p>
<p>借此说一下SDWebImage这个框架中<code>cleanDisk</code>与<code>clearDisk</code>的区别:<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//clean:删除过期缓存(缓存周期为1周),计算当前缓存文件的总大小,比较设置的最大缓存,如果超出的话,那么就继续删除(按照缓存文件创建的顺序),直到小于最大缓存为止</span></span><br><span class="line">[[SDWebImageManager sharedManager]<span class="variable">.imageCache</span> cleanDisk];</span><br><span class="line"><span class="comment">//clear:简单粗暴,直接删除然后重新创建</span></span><br><span class="line">[[SDWebImageManager sharedManager]<span class="variable">.imageCache</span> clearDisk];</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[新特性界面的两种搭建方法]]></title>
      <url>http://xionv.com/2015/06/04/demonayu/blog/30.%E6%96%B0%E7%89%B9%E6%80%A7%E7%95%8C%E9%9D%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="使用UIScrollView搭建">使用UIScrollView搭建</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"NewFeaturesViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"TabBarViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define kImageCount 4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NewFeaturesViewController</span>() &lt;<span class="title">UIScrollViewDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIScrollView</span> *scrollView;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIPageControl</span> *pageControl;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NewFeaturesViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载scrollView</span></span><br><span class="line">- (<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_scrollView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">UIScrollView</span> *scrollView = [[<span class="built_in">UIScrollView</span> alloc] init];</span><br><span class="line">        _scrollView = scrollView;</span><br><span class="line">        scrollView<span class="variable">.frame</span> = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>;</span><br><span class="line">        <span class="comment">// 取消回弹</span></span><br><span class="line">        scrollView<span class="variable">.bounces</span> = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">// 允许翻页</span></span><br><span class="line">        scrollView<span class="variable">.pagingEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">// 隐藏水平滚动条</span></span><br><span class="line">        scrollView<span class="variable">.showsHorizontalScrollIndicator</span> = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">// 设置滚动范围</span></span><br><span class="line">        scrollView<span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(kImageCount * <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置控制器为代理</span></span><br><span class="line">        scrollView<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">        <span class="comment">// 控制器View添加scrollView</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.view</span> addSubview:scrollView];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _scrollView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载pageControl</span></span><br><span class="line">- (<span class="built_in">UIPageControl</span> *)pageControl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_pageControl == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">UIPageControl</span> *pageControl = [[<span class="built_in">UIPageControl</span> alloc] init];</span><br><span class="line">        _pageControl = pageControl;</span><br><span class="line">        <span class="comment">// pageControl小圆点数量</span></span><br><span class="line">        pageControl<span class="variable">.numberOfPages</span> = kImageCount;</span><br><span class="line">        <span class="comment">/* pageControl比较特殊，可以不用设置宽高也能显示，因为小圆点为它的子控件, 但是不设置宽高就不能交互 */</span></span><br><span class="line">        <span class="comment">// 设置pageControl的位置</span></span><br><span class="line">        pageControl<span class="variable">.centerX</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span><span class="variable">.x</span>;</span><br><span class="line">        pageControl<span class="variable">.centerY</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span><span class="variable">.y</span> + <span class="number">250</span>;</span><br><span class="line">        <span class="comment">// 小圆点默认颜色</span></span><br><span class="line">        pageControl<span class="variable">.pageIndicatorTintColor</span> = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">        <span class="comment">// 小圆点选中颜色</span></span><br><span class="line">        pageControl<span class="variable">.currentPageIndicatorTintColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">        <span class="comment">// 控制器View添加pageControl</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.view</span> addSubview:pageControl];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _pageControl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kImageCount; i++) &#123;</span><br><span class="line">        <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.bounds</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"new_feature_%d"</span>, i + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">        imageView<span class="variable">.image</span> = image;</span><br><span class="line">        <span class="comment">// 设置性特性说明的x值</span></span><br><span class="line">        imageView<span class="variable">.x</span> = <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span> * i;</span><br><span class="line">        <span class="comment">// 添加新特性说明</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.scrollView</span> addSubview:imageView];</span><br><span class="line">        <span class="comment">// 当滑到最后一页时</span></span><br><span class="line">        <span class="keyword">if</span> (i == kImageCount - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置最后一页的内容</span></span><br><span class="line">            [<span class="keyword">self</span> setupLastImageView:imageView];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pageControl默认选中第一个原点</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.pageControl</span><span class="variable">.currentPage</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  设置最后一张图片</span><br><span class="line"> *</span><br><span class="line"> *  @param imageView 轮播器最后一张图片</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setupLastImageView:(<span class="built_in">UIImageView</span> *)imageView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建分享按钮</span></span><br><span class="line">    <span class="built_in">UIButton</span> *buttonShare = [[<span class="built_in">UIButton</span> alloc] init];</span><br><span class="line">    [buttonShare setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"new_feature_share_false"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [buttonShare setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"new_feature_share_true"</span>] forState:<span class="built_in">UIControlStateSelected</span>];</span><br><span class="line">    [buttonShare setTitle:<span class="string">@"分享给大家"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [buttonShare setTitleColor:[<span class="built_in">UIColor</span> grayColor] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    buttonShare<span class="variable">.titleLabel</span><span class="variable">.font</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">    <span class="comment">// 设置内边距 EdgeInsets理解为自切</span></span><br><span class="line">    buttonShare<span class="variable">.titleEdgeInsets</span> = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    buttonShare<span class="variable">.imageEdgeInsets</span> = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    buttonShare<span class="variable">.size</span> = <span class="built_in">CGSizeMake</span>(<span class="number">150</span>, <span class="number">30</span>);</span><br><span class="line">    buttonShare<span class="variable">.centerX</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centerX</span>;</span><br><span class="line">    buttonShare<span class="variable">.centerY</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centerY</span> * <span class="number">1.35</span>;</span><br><span class="line">    [buttonShare addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(clickShare:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建开启按钮</span></span><br><span class="line">    <span class="built_in">UIButton</span> *buttonOpen = [[<span class="built_in">UIButton</span> alloc] init];</span><br><span class="line">    [buttonOpen setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"new_feature_finish_button"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [buttonOpen setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"new_feature_finish_button_highlighted"</span>] forState:<span class="built_in">UIControlStateHighlighted</span>];</span><br><span class="line">    [buttonOpen setTitle:<span class="string">@"立即体验"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    buttonOpen<span class="variable">.size</span> = buttonOpen<span class="variable">.currentBackgroundImage</span><span class="variable">.size</span>;</span><br><span class="line">    buttonOpen<span class="variable">.centerX</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centerX</span>;</span><br><span class="line">    buttonOpen<span class="variable">.centerY</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centerY</span> * <span class="number">1.5</span>;</span><br><span class="line">    [buttonOpen addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(clickOpen) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    <span class="comment">// 设置imageView可交互</span></span><br><span class="line">    imageView<span class="variable">.userInteractionEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">    [imageView addSubview:buttonOpen];</span><br><span class="line">    [imageView addSubview:buttonShare];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)clickOpen</span><br><span class="line">&#123;</span><br><span class="line">    TabBarViewController *tabBarVC = [[TabBarViewController alloc] init];</span><br><span class="line">    <span class="comment">// 将跟控制器改为tabBarController，并销毁当前控制器</span></span><br><span class="line">    [<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.keyWindow</span><span class="variable">.rootViewController</span> = tabBarVC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)clickShare:(<span class="built_in">UIButton</span> *)button</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 状态取反</span></span><br><span class="line">    button<span class="variable">.selected</span> = !button<span class="variable">.isSelected</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当scrollView改变的时候，改变pageControl的currentPage</span></span><br><span class="line">    <span class="keyword">double</span> page = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span> / scrollView<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="comment">// (int)(page + 0.5)四舍五入法 准确定位page的圆点</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.pageControl</span><span class="variable">.currentPage</span> = (<span class="keyword">int</span>)(page + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="使用UICollectionView搭建">使用UICollectionView搭建</h2><p><strong>第一步:设置控制器的内容</strong><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"XVNewFeaturesController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"XVCollectionViewCell.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define kImagesCount 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XVNewFeaturesController</span> () &lt;<span class="title">UICollectionViewDataSource</span>&gt;</span></span><br><span class="line"><span class="comment">// 图片数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *images;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XVNewFeaturesController</span></span></span><br><span class="line"><span class="comment">// 懒加载图片数组</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)images</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_images == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 将图片存入数组</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *arrayM = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; kImagesCount; i++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"newFeatureImage%d"</span>, i];</span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">            [arrayM addObject:image];</span><br><span class="line">        &#125;</span><br><span class="line">        _images = arrayM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _images;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写构造方法在创建控制器的同时就设定好布局方式</span></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.设置collectionView的布局 - 布局设置是必须的</span></span><br><span class="line">    <span class="built_in">UICollectionViewFlowLayout</span> *layout = [[<span class="built_in">UICollectionViewFlowLayout</span> alloc] init];</span><br><span class="line">    <span class="comment">// 2.设置布局的最小行间距 - 注意:默认是有间距的,需要手动设置为0</span></span><br><span class="line">    layout<span class="variable">.minimumLineSpacing</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3.设置cell的大小</span></span><br><span class="line">    layout<span class="variable">.itemSize</span> = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span>;</span><br><span class="line">    <span class="comment">// 4.滚动方向</span></span><br><span class="line">    layout<span class="variable">.scrollDirection</span> = <span class="built_in">UICollectionViewScrollDirectionHorizontal</span>;</span><br><span class="line">    <span class="comment">// 5.完成初始化后调用父类方法</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> initWithCollectionViewLayout:layout];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化CollectionView设置 */</span></span><br><span class="line">    <span class="comment">// collectionView默认的背景色是黑色</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    <span class="comment">// 设置分页</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.pagingEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">// 取消滑块</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.showsHorizontalScrollIndicator</span> = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">// 禁用反弹</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.bounces</span> = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - UICollectionViewDataSource 数据源方法</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView numberOfItemsInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.images</span><span class="variable">.count</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用自定义cell</span></span><br><span class="line">    XVCollectionViewCell *cell = [XVCollectionViewCell cellWithCollectionView:collectionView forIndexPath:indexPath];</span><br><span class="line">    cell<span class="variable">.image</span> = <span class="keyword">self</span><span class="variable">.images</span>[indexPath<span class="variable">.row</span>];</span><br><span class="line">    <span class="comment">// 将当前的index和images总数传到cell中来判断是否是最后一页</span></span><br><span class="line">    [cell getIndexPath:indexPath andImagesCount:<span class="keyword">self</span><span class="variable">.images</span><span class="variable">.count</span>];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>第二步:自定义cell</strong><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"XVCollectionViewCell.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"XVTabBarController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XVCollectionViewCell</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIImageView</span> *imageV;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIButton</span> *button;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XVCollectionViewCell</span></span></span><br><span class="line"><span class="comment">// 实例化进入应用主界面的button</span></span><br><span class="line">- (<span class="built_in">UIButton</span> *)button</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_button == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">UIButton</span> *button = [[<span class="built_in">UIButton</span> alloc] init];</span><br><span class="line">        [button setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"startApp"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        [button sizeToFit];</span><br><span class="line">        button<span class="variable">.centerX</span> = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span>;</span><br><span class="line">        button<span class="variable">.centerY</span> = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span> * <span class="number">0.9</span>;</span><br><span class="line">        [button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(enterApp:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">        [<span class="keyword">self</span> addSubview:button];</span><br><span class="line">        _button = button;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写构造方法在初始化cell的时候就创建一个imageView用来显示新特性</span></span><br><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建显示新特新图片的imageView</span></span><br><span class="line">        <span class="built_in">UIImageView</span> *imageV = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="keyword">self</span><span class="variable">.bounds</span>];</span><br><span class="line">        [<span class="keyword">self</span> addSubview:imageV];</span><br><span class="line">        _imageV = imageV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写image的setter给imageV设置图片</span></span><br><span class="line">- (<span class="keyword">void</span>)setImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    _image = image;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageV</span><span class="variable">.image</span> = image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取索引来判断是否为最后一页</span></span><br><span class="line">- (<span class="keyword">void</span>)getIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath andImagesCount:(<span class="built_in">NSInteger</span>)imagesCount</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当滑动到最后一页时</span></span><br><span class="line">    <span class="keyword">if</span> (indexPath<span class="variable">.row</span> == imagesCount - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.button</span><span class="variable">.hidden</span> = <span class="literal">NO</span>; <span class="comment">// 显示button</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.button</span><span class="variable">.hidden</span> = <span class="literal">YES</span>; <span class="comment">// 隐藏button - 防止循环利用bug</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法快速创建cell</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *ID = <span class="string">@"cell"</span>;</span><br><span class="line">+ (instancetype)cellWithCollectionView:(<span class="built_in">UICollectionView</span> *)collectionView forIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    [collectionView registerClass:<span class="keyword">self</span> forCellWithReuseIdentifier:ID];</span><br><span class="line">    XVCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:ID forIndexPath:indexPath];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 监听方法</span></span><br><span class="line"><span class="comment">// 进入应用</span></span><br><span class="line">- (<span class="keyword">void</span>)enterApp:(<span class="built_in">UIButton</span> *)button</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 变更rootController</span></span><br><span class="line">    XVTabBarController *vc = [[XVTabBarController alloc] init];</span><br><span class="line">    [<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.keyWindow</span><span class="variable">.rootViewController</span> = vc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<h2 id="创建一个UIWindow的分类来控制是否显示新特性">创建一个UIWindow的分类来控制是否显示新特性</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"UIWindow+Extension.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"TabBarViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"NewFeaturesViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIWindow</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)switchRootViewController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.获得用户的偏好设置</span></span><br><span class="line">    <span class="built_in">NSUserDefaults</span> *user = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">    <span class="built_in">NSString</span> *keyVersion = <span class="string">@"CFBundleVersion"</span>;</span><br><span class="line">    <span class="comment">// 2.获得上一次打开的版本（存在沙盒内）</span></span><br><span class="line">    <span class="built_in">NSString</span> *lastVersion = [user valueForKeyPath:keyVersion];</span><br><span class="line">    <span class="comment">// 3.取出当前的版本号</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *info = [<span class="built_in">NSBundle</span> mainBundle]<span class="variable">.infoDictionary</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *currentVersion = info[keyVersion];</span><br><span class="line">    <span class="comment">// 4.当前版本号等于存于沙盒的版本号（上次打开时的版本）时则直接进入软件，否则显示新特性</span></span><br><span class="line">    <span class="keyword">if</span> ([currentVersion isEqualToString:lastVersion]) &#123;</span><br><span class="line">        TabBarViewController *tabBar = [[TabBarViewController alloc] init];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.rootViewController</span> = tabBar;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NewFeaturesViewController *new = [[NewFeaturesViewController alloc] init];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.rootViewController</span> = new;</span><br><span class="line">        <span class="comment">// 同步版本号</span></span><br><span class="line">        [user setValue:currentVersion forKeyPath:keyVersion];</span><br><span class="line">        [user synchronize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用运行时特性获取系统类的私有成员属性]]></title>
      <url>http://xionv.com/2015/05/08/demonayu/blog/29.%E5%88%A9%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%89%B9%E6%80%A7%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在iOS7以后苹果添加了一个边缘滑动返回的手势操作,我们通过修改这个手势操作来说明如何利用系统的私有成员属性来达到在项目中的要求.</p>
</blockquote>
<ul>
<li><p><code>interactivePopGestureRecognizer</code>这个api功能就是在NavigationController堆栈内的UIViewController可以支持右滑手势,轻轻在屏幕左边一滑,屏幕就会返回.<br>但是, 1.这个功能在自定义返回按钮后会失效; 2.它的作用范围在手机屏幕左侧边缘,如果要求全屏接受这个事件就需要自定义这个功能了.</p>
</li>
<li><p>通过打印<code>interactivePopGestureRecognizer</code>得知这个功能是通过<code>UIScreenEdgePanGestureRecognizer</code>这个手势来实现的.如果是手势就一定有<code>target</code>和<code>action</code>这两个成员属性,我们只要拿到<code>target</code>的真实类型.然后通过KVC就能”借用”系统实现方式来达到以上两个要求.</p>
</li>
<li><p>利用运行时获取所有的成员变量</p>
<ol>
<li><p>导入运行时头文件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用runtime函数获取获取类中的所有成员属性</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来接收数组元素个数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outcount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// UIGestureRecognizer是interactivePopGestureRecognizer的类型</span></span><br><span class="line">Ivar *ivars = class_copyIvarList([<span class="built_in">UIGestureRecognizer</span> class], &amp;outcount);</span><br><span class="line"><span class="comment">// Ivar：成员属性的意思;</span></span><br><span class="line"><span class="comment">// 第一个参数:表示获取哪个类中的成员属性;</span></span><br><span class="line"><span class="comment">// 第二个参数:表示这个类有多少成员属性,传入一个Int变量地址,会自动给这个变量赋值;</span></span><br><span class="line"><span class="comment">// 返回值Ivar*:指的是一个ivar数组,会把所有成员属性放在一个数组中,通过返回的数组就能全部获取到;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有的成员属性名</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历ivars获取目标类中每一个成员属性名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outcount; i++) &#123;</span><br><span class="line">    <span class="comment">// 打印所有的成员属性名</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, @(ivar_getName(ivars[i])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果: 第一个就是我们要拿到的成员属性.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_targets</span><br><span class="line">_delayedTouches</span><br><span class="line">_delayedPresses</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过KVC拿到其关键作用的<code>target</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿到打印结果,通过KVC拿到那个target</span></span><br><span class="line"><span class="built_in">NSArray</span> *targets = [<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span> valueForKeyPath:<span class="string">@"_targets"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, targets);</span><br><span class="line"><span class="keyword">id</span> target = [targets[<span class="number">0</span>] valueForKeyPath:<span class="string">@"target"</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个pan手势</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handleNavigationTransition:这个方法是通过打印结果得知系统内部会调用的方法,不用我们去实现.</span></span><br><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:target action:<span class="keyword">@selector</span>(handleNavigationTransition:)];</span><br><span class="line">pan<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addGestureRecognizer:pan];</span><br></pre></td></tr></table></figure>
</li>
<li><p>在根控制器禁用pan手势</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.childViewControllers</span><span class="variable">.count</span> &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>至此我们就已经修改完成了,是不是很暴力很直接!当然我本人是不支持这种方法的:1.它破坏了苹果的封装性.2它仍然有局限性,因为是利用系统的方法,如果有其他自定义要求不便于修改.</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSFileManager和NSFileHandle的常用方法]]></title>
      <url>http://xionv.com/2015/04/30/demonayu/blog/28.NSFileManager%E5%92%8CNSFileHandle%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="NSFileManager">NSFileManager</h2><ul>
<li><p>创建一个文件管理者对象</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件与目录的操作</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">createFileAtPath:    <span class="comment">// 创建文件</span></span><br><span class="line">copyItemAtPath:    <span class="comment">// 复制文件</span></span><br><span class="line">moveItemAtPath:    <span class="comment">// 移动文件</span></span><br><span class="line">removeItemFileAtPath:    <span class="comment">// 删除文件</span></span><br><span class="line">attributesOfItemAtPath:    <span class="comment">// 获取文件的属性</span></span><br><span class="line">setAttributes:    <span class="comment">// 更改属性</span></span><br><span class="line">currentDirectoryPath:    <span class="comment">// 获取当前的目录</span></span><br><span class="line">changeCurrentDirectoryPath:    <span class="comment">// 更改目录</span></span><br><span class="line">createDirectoryAtPath:    <span class="comment">//  创建目录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取文件和目录信息</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">contentsAtPath:    <span class="comment">// 获取文件中的信息</span></span><br><span class="line">enumeratorAtPath:    <span class="comment">// 枚举目录</span></span><br><span class="line">contentsOfDirectoryAtPath:    <span class="comment">// 列举目录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>判断文件</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">fileExistsAtPath:    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">isReadableFile:    <span class="comment">// 判断是否能进行读取操作</span></span><br><span class="line">isWritableFileAtPath:    <span class="comment">// 判断是否能进行写入操作</span></span><br><span class="line">isDeletableFileAtPath:    <span class="comment">// 判断是否可删除</span></span><br><span class="line">isExecutableFileAtPath:    <span class="comment">// 判断是否可以执行</span></span><br><span class="line">contentsEqualAtPath:    <span class="comment">// 判断是否相等</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>目录工具函数</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSUserName</span>()    <span class="comment">// 函数:返回登录名</span></span><br><span class="line"><span class="built_in">NSFullUserName</span>()    <span class="comment">// 函数:返回完整用户名</span></span><br><span class="line"><span class="built_in">NSHomeDirectory</span>()   <span class="comment">// 函数:返回路径</span></span><br><span class="line"><span class="built_in">NSHomeDirectoryForUser</span>()    <span class="comment">// 函数:返回用户的主目录</span></span><br><span class="line"><span class="built_in">NSTemporaryDirectory</span>()  <span class="comment">// 函数:返回临时文件的路径目录</span></span><br><span class="line">[fileList pathsMatchingExtensions:[<span class="built_in">NSArrayarrayWithObject</span>:<span class="string">@"jpg"</span>]];   <span class="comment">// 过滤数组中的文件类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常用路径工具方法</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)pathWithComponents:components        <span class="comment">// 根据components中元素构造有效路径</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)pathComponents        <span class="comment">// 析构路径,获取路径的各个部分</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)lastPathComponent        <span class="comment">// 提取路径的最后一个组成部分</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)pathExtension        <span class="comment">// 路径扩展名</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByAppendingPathComponent:path        <span class="comment">// 将path添加到现有路径末尾</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByAppendingPathExtension:ext        <span class="comment">// 将拓展名添加的路径最后一个组成部分</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByDeletingPathComponent        <span class="comment">// 删除路径的最后一个部分</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByDeletingPathExtension        <span class="comment">// 删除路径的最后一个部分 的扩展名</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByExpandingTildeInPath        <span class="comment">// 将路径中的代字符扩展成用户主目录(~)或指定用户主目录(~user)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByResolvingSymlinksInPath        <span class="comment">// 尝试解析路径中的符号链接</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByStandardizingPath        <span class="comment">// 通过尝试解析~、..、.、和符号链接来标准化路径</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="NSFileHandle">NSFileHandle</h2><ul>
<li>文件读取 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">init:    <span class="comment">// 初始化文件读写对象</span></span><br><span class="line">fileHandleForReadingAtPath:    <span class="comment">// 读取时打开文件</span></span><br><span class="line">fileHandleForWritingAtPath:    <span class="comment">// 写入时打开文件</span></span><br><span class="line">fileHandleForUpdatingAtPath:    <span class="comment">// 更新时打开文件</span></span><br><span class="line">writeData:    <span class="comment">// 数据写入文件</span></span><br><span class="line">readDataToEndOfFile:    <span class="comment">// 读取数据</span></span><br><span class="line">readDataOfLength:    <span class="comment">// 读取固定大小的内容</span></span><br><span class="line">offsetInFile:    <span class="comment">// 获取当前偏移量</span></span><br><span class="line">seekToFileOffset:    <span class="comment">// 设置当前的偏移量</span></span><br><span class="line">seekToEndOfFile:    <span class="comment">// 将偏移量定位到文件尾</span></span><br><span class="line">truncateFileAtOffset:    <span class="comment">// 设置字节</span></span><br><span class="line">availableData:    <span class="comment">// 返回可用数据</span></span><br><span class="line">closeFile:    <span class="comment">// 关闭文件</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="NSProcessInfo类:设置或检索正在运行的应用程序的各种类型信息">NSProcessInfo类:设置或检索正在运行的应用程序的各种类型信息</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSProcessInfo</span> *)processInfo        <span class="comment">// 返回当前进程的信息</span></span><br><span class="line">- (<span class="built_in">NSArray</span>*)arguments        <span class="comment">// 以NSString对象数字的形式返回当前进程的参数</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)environment        <span class="comment">//  返回变量/值对词典。描述当前的环境变量</span></span><br><span class="line">- (<span class="keyword">int</span>)processIdentity        <span class="comment">// 返回进程标识</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)processName        <span class="comment">// 返回进程名称</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)globallyUniqueString        <span class="comment">// 每次调用该方法都会返回不同的单值字符串，可以用这个字符串生成单值临时文件名</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)hostname        <span class="comment">// 返回主机系统的名称</span></span><br><span class="line">- (<span class="keyword">unsigned</span> <span class="keyword">int</span>)operatingSystem        <span class="comment">// 返回表示操作系统的数字</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)operatingSystemName        <span class="comment">// 返回操作系统名称</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)operatingSystemVersionString        <span class="comment">// 返回操作系统当前版本</span></span><br><span class="line">- (<span class="keyword">void</span>)setProcessName:(<span class="built_in">NSString</span> *)name        <span class="comment">// 将当前进程名称设置为name</span></span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TableVIew单元格多图下载]]></title>
      <url>http://xionv.com/2015/04/02/demonayu/blog/27.TableVIew%E5%8D%95%E5%85%83%E6%A0%BC%E5%A4%9A%E5%9B%BE%E4%B8%8B%E8%BD%BD/</url>
      <content type="html"><![CDATA[<h2 id="考虑因素">考虑因素</h2><ul>
<li>单元格的多图下载要考虑到:<ul>
<li>必须要在子线程进行下载</li>
<li>防止重复下载</li>
<li>数据缓存</li>
</ul>
</li>
</ul>
<h2 id="实现思路">实现思路</h2><p><img src="http://r5.loli.io/bIRVfm.png" alt=""></p>
<h2 id="实现方法">实现方法</h2><ul>
<li><p>将cache路径写成宏</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#define cachePath(url) [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).lastObject stringByAppendingPathComponent:[url lastPathComponent]]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>cellForRowAtIndexPath:</code>方法中判断图片是否存在</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取出对应的模型</span></span><br><span class="line">XVModel *item = <span class="keyword">self</span><span class="variable">.items</span>[indexPath<span class="variable">.row</span>];</span><br><span class="line">cell<span class="variable">.textLabel</span><span class="variable">.text</span> = item<span class="variable">.title</span>;</span><br><span class="line">cell<span class="variable">.detailTextLabel</span><span class="variable">.text</span> = item<span class="variable">.subTitle</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1&gt; 先从内存缓存中取</span></span><br><span class="line"><span class="comment">// 根据url取出图片</span></span><br><span class="line"><span class="built_in">UIImage</span> *memoryImage = <span class="keyword">self</span><span class="variable">.images</span>[item<span class="variable">.icon</span>];</span><br><span class="line"><span class="keyword">if</span> (memoryImage) &#123; <span class="comment">// 当内存中有图片时</span></span><br><span class="line">    cell<span class="variable">.imageView</span><span class="variable">.image</span> = memoryImage;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 当内存中没有图片时</span></span><br><span class="line">    <span class="comment">// 2&gt; 再从沙盒中取 - 每一张图片都是一个文件 文件名为url名</span></span><br><span class="line">    <span class="built_in">UIImage</span> *diskImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:cachePath(item<span class="variable">.icon</span>)];</span><br><span class="line">    <span class="keyword">if</span> (diskImage) &#123; <span class="comment">// 沙盒中有图片时</span></span><br><span class="line">        cell<span class="variable">.imageView</span><span class="variable">.image</span> = diskImage;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当沙盒中没有对应的图片时</span></span><br><span class="line">        <span class="comment">// 设置占位图片</span></span><br><span class="line">        cell<span class="variable">.imageView</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder3"</span>];</span><br><span class="line">        <span class="comment">// 3&gt; 从网络上下载</span></span><br><span class="line">        [<span class="keyword">self</span> downloadImageWithUrlStr:item<span class="variable">.icon</span> indexPath:indexPath];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现异步下载</p>
<ul>
<li>为了保证一张图片只下载一次,需要判断当前url是否有下载任务,如果没有才需要创建下载任务.</li>
<li>如何才能判断当前的url是否有下载任务呢?利用字典把url作为key绑定下载操作来判断.<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)downloadImageWithUrlStr:(<span class="built_in">NSString</span> *)urlStr indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出字典中url对应的下载任务</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *operation = <span class="keyword">self</span><span class="variable">.operations</span>[urlStr];</span><br><span class="line">    <span class="comment">// 如果当前url有下载任务 - 就不创建任务</span></span><br><span class="line">    <span class="keyword">if</span> (!operation) &#123; <span class="comment">// 没有下载任务</span></span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">        <span class="comment">// 创建异步任务 - 将下载图片的操作放入到子线程中 - (解决异步下载的问题)</span></span><br><span class="line">        operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">            <span class="comment">// 将字符串转成url</span></span><br><span class="line">            <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlStr];</span><br><span class="line">            <span class="comment">// 从url获取数据</span></span><br><span class="line">            <span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">            <span class="comment">// 将二进制数据转成图片</span></span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 返回主线程刷新数据</span></span><br><span class="line">            [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">                <span class="comment">// 如果下载成功将图片存入字典 - 字典不能存空</span></span><br><span class="line">                <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                    <span class="comment">// 1)将下载好的图片添加进图片字典中 url为key</span></span><br><span class="line">                    [weakself<span class="variable">.images</span> setObject:image forKey:urlStr];</span><br><span class="line">                    <span class="comment">// 刷新表格</span></span><br><span class="line">                    [weakself<span class="variable">.tableView</span> reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class="built_in">UITableViewRowAnimationFade</span>];</span><br><span class="line">                    <span class="comment">// 2)将image写入沙盒</span></span><br><span class="line">                    <span class="comment">// 将图片转成二进制数据</span></span><br><span class="line">                    <span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line">                    <span class="comment">// 写入沙盒</span></span><br><span class="line">                    [data writeToFile:cachePath(urlStr) atomically:<span class="literal">YES</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 下载完毕后将任务从字典中移除 - 如果下载失败将任务移除后还有机会下载,如果不移除,这个key就会一直存在永远也不能再次下载了</span></span><br><span class="line">                <span class="comment">// 在主线程中移除是为了保证下载操作已经执行完毕</span></span><br><span class="line">                [weakself<span class="variable">.operations</span> removeObjectForKey:urlStr];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将任务添加到队列</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.queue</span> addOperation:operation];</span><br><span class="line">    <span class="comment">// 将下载任务写入到字典里(解决重复下载问题)</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.operations</span> setObject:operation forKey:urlStr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[渐变图层,复制图层和形状图层的简单用法]]></title>
      <url>http://xionv.com/2015/03/14/demonayu/blog/26.%E6%B8%90%E5%8F%98%E5%9B%BE%E5%B1%82,%E5%A4%8D%E5%88%B6%E5%9B%BE%E5%B1%82%E5%92%8C%E5%BD%A2%E7%8A%B6%E5%9B%BE%E5%B1%82%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="渐变图层">渐变图层</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">/* 创建一个imageView控件 */</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *imageV = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image"</span>]];</span><br><span class="line">    imageV<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    imageV<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:imageV];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> addGradientLayerToView:imageV];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 添加渐变图层 */</span></span><br><span class="line">- (<span class="keyword">void</span>)addGradientLayerToView:(<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建一个渐变图层 */</span></span><br><span class="line">    <span class="built_in">CAGradientLayer</span> *gradient = [<span class="built_in">CAGradientLayer</span> layer];</span><br><span class="line">    <span class="comment">// 设置图层frame</span></span><br><span class="line">    gradient<span class="variable">.frame</span> = view<span class="variable">.bounds</span>;</span><br><span class="line">    <span class="comment">// 渐变颜色(用(id)强转成OC对象)</span></span><br><span class="line">    gradient<span class="variable">.colors</span> = @[(<span class="keyword">id</span>)[<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>, (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> blueColor]<span class="variable">.CGColor</span>];</span><br><span class="line">    <span class="comment">// 渐变范围(取值范围是0~1, 差值越大表示渐变范围越大)</span></span><br><span class="line">    gradient<span class="variable">.locations</span> = @[@<span class="number">0</span>, @<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 渐变方向(下面代码表示左上角到右下角的渐变)</span></span><br><span class="line">    gradient<span class="variable">.startPoint</span> = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    gradient<span class="variable">.endPoint</span> = <span class="built_in">CGPointMake</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 不透明度</span></span><br><span class="line">    gradient<span class="variable">.opacity</span> = <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给控件添加渐变图层</span></span><br><span class="line">    [view<span class="variable">.layer</span> addSublayer:gradient];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复制图层">复制图层</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 添加复制图层 */</span></span><br><span class="line">- (<span class="keyword">void</span>)addReplicatorLayerToView:(<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建一个复制层 */</span></span><br><span class="line">    <span class="built_in">CAReplicatorLayer</span> *replicator = [<span class="built_in">CAReplicatorLayer</span> layer];</span><br><span class="line">    <span class="comment">// 设置图层frame</span></span><br><span class="line">    replicator<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 设置背景颜色</span></span><br><span class="line">    replicator<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> blueColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    <span class="comment">// 添加图层</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:replicator];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子层1</span></span><br><span class="line">    <span class="built_in">CALayer</span> *sublayer1 = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    sublayer1<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">    sublayer1<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    [replicator addSublayer:sublayer1];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子层2</span></span><br><span class="line">    <span class="built_in">CALayer</span> *sublayer2 = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    sublayer2<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">70</span>, <span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">    sublayer2<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> greenColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    [replicator addSublayer:sublayer2];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制层是复制里面的子层,而不是复制层本身</span></span><br><span class="line">    <span class="comment">// 设置要复制图层中子层的个数(数量包括自己本身的)</span></span><br><span class="line">    replicator<span class="variable">.instanceCount</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 子层形变(基于上一次子层的形变)</span></span><br><span class="line">    replicator<span class="variable">.instanceTransform</span> = <span class="built_in">CATransform3DMakeTranslation</span>(<span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="形状图层">形状图层</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 添加形状图层 */</span></span><br><span class="line">- (<span class="keyword">void</span>)addShapeLayerToView:(<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 绘制一个圆形路径 */</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建一个形状图层 */</span></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *shape = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    <span class="comment">// 设置路径(将路径装换成形状图层)</span></span><br><span class="line">    shape<span class="variable">.path</span> = path<span class="variable">.CGPath</span>;</span><br><span class="line">    <span class="comment">// 设置填充色</span></span><br><span class="line">    shape<span class="variable">.fillColor</span> = [<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    <span class="comment">// 设置描边色</span></span><br><span class="line">    shape<span class="variable">.strokeColor</span> = [<span class="built_in">UIColor</span> blackColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    <span class="comment">// 设置线宽</span></span><br><span class="line">    shape<span class="variable">.lineWidth</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 描边起始点 (取值范围是0~1)</span></span><br><span class="line">    shape<span class="variable">.strokeStart</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 描边结束点 (取值范围是0~1)</span></span><br><span class="line">    shape<span class="variable">.strokeEnd</span> = <span class="number">0.75</span>;</span><br><span class="line">    <span class="comment">// 添加图层</span></span><br><span class="line">    [view<span class="variable">.layer</span> addSublayer:shape];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义view时重写父类类方法来修改view的初始层">自定义view时重写父类类方法来修改view的初始层</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回当前View当中layer的类型</span></span><br><span class="line">+ (Class)layerClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将初始层修改为复制层</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">CAReplicatorLayer</span> class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[核心动画与UIView动画的对比]]></title>
      <url>http://xionv.com/2015/02/18/demonayu/blog/25.%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E4%B8%8E%E6%98%BE%E7%A4%BA%E5%8A%A8%E7%94%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h2 id="CALayer">CALayer</h2><ul>
<li>CALayer简介<ul>
<li>CALayer我们又称它叫做层.</li>
<li>在每个UIView内部都有一个layer这样一个属性.</li>
<li>UIView之所以能够显示,就是因为它里面有这个一个层,才具有显示的功能.</li>
<li>我们通过操作CALayer对象,可以很方便地调整UIView的一些外观属性.比如给UIView设置阴影,圆角,边框等等…</li>
<li>所进行的核心动画在层里完成</li>
</ul>
</li>
<li><p>设置CALayer属性</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)add<span class="built_in">CALayer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自定义一个图层</span></span><br><span class="line">    <span class="built_in">CALayer</span> *layer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    <span class="comment">// 设置图层的宽高</span></span><br><span class="line">    layer<span class="variable">.bounds</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 图层位置</span></span><br><span class="line">    layer<span class="variable">.position</span> = <span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 图层的锚点(它决定CALayer身上哪一个点会在position属性所指的位置,默认为(0.5, 0.5)</span></span><br><span class="line">    layer<span class="variable">.anchorPoint</span> = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 图层的背景颜色</span></span><br><span class="line">    layer<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    <span class="comment">// 设置图层的圆角</span></span><br><span class="line">    layer<span class="variable">.cornerRadius</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 相当于Clip</span></span><br><span class="line">    layer<span class="variable">.masksToBounds</span> = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">// 设置图层边框宽度</span></span><br><span class="line">    layer<span class="variable">.borderWidth</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 设置图层边框颜色</span></span><br><span class="line">    layer<span class="variable">.borderColor</span> = [<span class="built_in">UIColor</span> whiteColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    <span class="comment">// 设置图层显示内容</span></span><br><span class="line">    layer<span class="variable">.contents</span> = (__bridge <span class="keyword">id</span>)([<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image"</span>]<span class="variable">.CGImage</span>);</span><br><span class="line">    <span class="comment">// 将自定义图层加载到父图层</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:layer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>注意</strong>: UIImageView当中Image并不是直接添加在层上面的.而是添加在layer当中的<code>contents</code>里.我们设置层的所有属性它只作用在层上面.对contents里面的东西并不起作用.所以如果直接只设置<code>cornerRadius</code>我们是看不到图片的圆角效果的.想要让图片有圆角的效果,需要设置<code>masksToBounds</code>属性设为YES,它会把超过根层以外的东西都给裁剪掉.<br> <strong>PS1</strong>: 为什么要使用CGImageRef、CGColorRef?         为了保证可移植性,QuartzCore不能使用UIImage、UIColor,只能使用CGImageRef、CGColorRef.<br> <strong>PS2</strong>: 所有的动画都是基于锚点做参照来进行的.</p>
</li>
<li><p>CALayer的<code>CATransform3D</code>属性 (只有旋转的时候才可以看出3D的效果).</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x,y,z 分别代表x,y,z轴.</span></span><br><span class="line"><span class="comment">// 旋转: </span></span><br><span class="line"><span class="built_in">CATransform3DMakeRotation</span>(M_PI, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 平移:</span></span><br><span class="line"><span class="built_in">CATransform3DMakeTranslation</span>(x,y,z);</span><br><span class="line"><span class="comment">// 缩放:</span></span><br><span class="line"><span class="built_in">CATransform3DMakeScale</span>(x,y,z);</span><br></pre></td></tr></table></figure>
<p> <strong>CATransform3D的键值</strong><br><img src="http://r6.loli.io/NNvIvy.png" alt="CATransform3D Key Paths"></p>
</li>
</ul>
<h2 id="隐式动画">隐式动画</h2><ul>
<li>什么是隐式动画 <br><ul>
<li>在了解隐式动画前先了解什么是根层和非根层:<ul>
<li>根层: UIView内部自动关联着的那个layer我们称它是根层.</li>
<li>非根层: 自己手动创建的层,称为非根层.</li>
</ul>
</li>
<li>隐式动画就是当对非根层的部分属性进行修改时,它会自动的产生一些动画的效果.我们称这个默认产生的动画为隐式动画.</li>
<li>给根层添加的动画叫做核心动画.隐式动画是系统默认给非根层添加的动画,核心动画是程序员自己手动来添加的,其实隐式动画就是核心动画.</li>
</ul>
</li>
<li>如何取消隐式动画<ul>
<li>隐式动画的底层是包装成一个事务(<code>CATransaction</code>)来进行的.<ul>
<li>事物: 很多操作绑定在一起,当这些操作执行完毕后,才去执行下一个操作.</li>
</ul>
</li>
<li>手动在事物中关闭动画<code>[CATransaction setDisableActions:YES];</code>  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    <span class="built_in">CGPoint</span> point = [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 开启事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">        <span class="comment">// 动画时长</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">0.1</span>];</span><br><span class="line">        <span class="comment">// 取消隐式动画 (默认有)</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 修改图层属性</span></span><br><span class="line">    <span class="built_in">CGFloat</span> r = arc4random_uniform(<span class="number">256</span>) / <span class="number">255.0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> g = arc4random_uniform(<span class="number">256</span>) / <span class="number">255.0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> b = arc4random_uniform(<span class="number">256</span>) / <span class="number">255.0</span>;</span><br><span class="line">    <span class="comment">// 修改背景颜色</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.layer</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> colorWithRed:r green:g blue:b alpha:<span class="number">1</span>]<span class="variable">.CGColor</span>;</span><br><span class="line">    <span class="comment">// 修改圆角度数</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.layer</span><span class="variable">.cornerRadius</span> = arc4random_uniform(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 修改位置</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.layer</span><span class="variable">.position</span> = point;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 提交事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="核心动画">核心动画</h2><p><img src="http://r5.loli.io/YryMbm.png" alt="核心动画的继承结构"></p>
<blockquote>
<p>核心动画中所有类都遵守CAMediaTiming协议</p>
</blockquote>
<ul>
<li><p><strong>核心动画的继承结构</strong></p>
<ul>
<li>CAAnaimation是个抽象类,不具备动画效果,必须用它的子类才有动画效果,其中:<ul>
<li>CAAnimationGroup是个动画组,可以同时进行缩放,旋转;</li>
<li>CATransition是转场动画,界面之间跳转都可以用转场动画;</li>
</ul>
</li>
<li>CAPropertyAnimation也是个抽象类,本身不具备动画效果,只有调用其子类才有动画,其中:<ul>
<li>CABasicAnimation基本动画，做一些简单效果;</li>
<li>CAKeyframeAnimation帧动画，做一些连续的流畅的动画;</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基础核心动画</strong></p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建基本核心动画</span></span><br><span class="line"><span class="comment">// 旋转</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *rotation = [<span class="built_in">CABasicAnimation</span> animation];</span><br><span class="line"><span class="comment">// 直接通过KVC来更改键值</span></span><br><span class="line">rotation<span class="variable">.keyPath</span> = <span class="string">@"transform.rotation"</span>;</span><br><span class="line">rotation<span class="variable">.toValue</span> = @M_PI_2;</span><br><span class="line"><span class="comment">// 位移</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *position = [<span class="built_in">CABasicAnimation</span> animation];</span><br><span class="line">position<span class="variable">.keyPath</span> = <span class="string">@"position"</span>;</span><br><span class="line">position<span class="variable">.toValue</span> = [<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">200</span>)];</span><br><span class="line"><span class="comment">// 缩放</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *scale = [<span class="built_in">CABasicAnimation</span> animation];</span><br><span class="line">scale<span class="variable">.keyPath</span> = <span class="string">@"transform.scale"</span>;</span><br><span class="line">scale<span class="variable">.toValue</span> = @<span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个动画组(组合动画)</span></span><br><span class="line"><span class="built_in">CAAnimationGroup</span> *group = [<span class="built_in">CAAnimationGroup</span> animation];</span><br><span class="line"><span class="comment">// 将动画添加到动画组</span></span><br><span class="line">group<span class="variable">.animations</span> = @[rotation, position, scale];</span><br><span class="line"><span class="comment">// 动画时间</span></span><br><span class="line">group<span class="variable">.duration</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 取消反弹</span></span><br><span class="line">group<span class="variable">.removedOnCompletion</span> = <span class="literal">NO</span>;</span><br><span class="line"><span class="comment">// 保存动画最前面的效果</span></span><br><span class="line">group<span class="variable">.fillMode</span> = k<span class="built_in">CAFillModeForwards</span>;</span><br><span class="line"><span class="comment">// 给控件图层添加动画</span></span><br><span class="line">[image<span class="variable">.layer</span> addAnimation:group forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p> 使用动画组的好处: 不需要每次都去添加动画,设置动画完成时的属性.只需要把要执行的动画,添加到动画组的animations数组当中即可.最后把组动画添加到层上面,就会自动执行数组当中的动画.动画完成时设置的属性也只需要设置一次.</p>
</li>
<li><p><strong>关键帧动画</strong></p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建关键帧动画对象</span></span><br><span class="line"><span class="built_in">CAKeyframeAnimation</span> *frameAnim = [<span class="built_in">CAKeyframeAnimation</span> animation];</span><br><span class="line"><span class="comment">// 2.绘制一个路径</span></span><br><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line"><span class="comment">// 3.设置动画参数</span></span><br><span class="line">group<span class="variable">.duration</span> = <span class="number">1</span>;</span><br><span class="line">group<span class="variable">.removedOnCompletion</span> = <span class="literal">NO</span>;</span><br><span class="line">group<span class="variable">.fillMode</span> = k<span class="built_in">CAFillModeForwards</span>;</span><br><span class="line"><span class="comment">// 4.给控件添加动画</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.layer</span> addAnimation:frameAnim forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转场动画</strong></p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 转场动画要和转场代码写在同一个方法当中才有动画效果.</span></span><br><span class="line">    <span class="comment">// 1.1 设定转场条件</span></span><br><span class="line">    _i++;</span><br><span class="line">    <span class="keyword">if</span> (_i &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        _i = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.2 添加转场代码 - 替换图片</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageV</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, _i]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.1 添加一个转场动画</span></span><br><span class="line">    <span class="built_in">CATransition</span> *anim = [<span class="built_in">CATransition</span> animation];</span><br><span class="line">    <span class="comment">// 2.2 设置转场样式</span></span><br><span class="line">    anim<span class="variable">.type</span> = <span class="string">@"cube"</span>;</span><br><span class="line">    <span class="comment">// 2.3 动画参数</span></span><br><span class="line">    <span class="comment">//设置动画的开始位置</span></span><br><span class="line">    anim<span class="variable">.startProgress</span> = <span class="number">0.5</span>;</span><br><span class="line">	<span class="comment">//设置动画的结束位置</span></span><br><span class="line">    anim<span class="variable">.endProgress</span>  =<span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">// 2.3 添加转场动画</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.imageV</span><span class="variable">.layer</span> addAnimation:anim forKey:<span class="literal">nil</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>转场动画过渡效果</strong><br><img src="http://r5.loli.io/iyUn22.png" alt="转场动画过渡效果"></p>
</li>
<li><p>核心动画的代理方法 - 它所使用的是非正式协议(其实就是个分类)</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动画开始</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim;</span><br><span class="line"><span class="comment">// 动画结束</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag;</span><br></pre></td></tr></table></figure>
</li>
<li><p>暂停动画和恢复动画</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂停动画</span></span><br><span class="line">- (<span class="keyword">void</span>)pauseLayer:(<span class="built_in">CALayer</span>*)layer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFTimeInterval</span> pausedTime = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// 让CALayer的时间停止走动</span></span><br><span class="line">    layer<span class="variable">.speed</span> = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 让CALayer的时间停留在pausedTime这个时刻</span></span><br><span class="line">    layer<span class="variable">.timeOffset</span> = pausedTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复动画</span></span><br><span class="line">- (<span class="keyword">void</span>)resumeLayer:(<span class="built_in">CALayer</span>*)layer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFTimeInterval</span> pausedTime = layer<span class="variable">.timeOffset</span>;</span><br><span class="line">    <span class="comment">// 1. 让CALayer的时间继续行走</span></span><br><span class="line">    layer<span class="variable">.speed</span> = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 2. 取消上次记录的停留时刻</span></span><br><span class="line">    layer<span class="variable">.timeOffset</span> = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 3. 取消上次设置的时间</span></span><br><span class="line">    layer<span class="variable">.beginTime</span> = <span class="number">0.0</span>;    </span><br><span class="line">    <span class="comment">// 4. 计算暂停的时间(这里也可以用CACurrentMediaTime()-pausedTime)</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> timeSincePause = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>] - pausedTime;</span><br><span class="line">    <span class="comment">// 5. 设置相对于父坐标系的开始时间(往后退timeSincePause)</span></span><br><span class="line">    layer<span class="variable">.beginTime</span> = timeSincePause;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>补充两个控制动画的属性: <figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="header">fillMode属性值（要想fillMode有效，最好设置removedOnCompletion = NO）</span><br><span class="line">--------------</span></span><br><span class="line">kCAFillModeRemoved: 这个是默认值,也就是说当动画开始前和动画结束后,动画对layer都没有影响,动画结束后,layer会恢复到之前的状态;</span><br><span class="line">kCAFillModeForwards: 当动画结束后,layer会一直保持着动画最后的状态;</span><br><span class="line">kCAFillModeBackwards: 在动画开始前,只需要将动画加入了一个layer,layer便立即进入动画的初始状态并等待动画开始;</span><br><span class="line">kCAFillModeBoth: 这个其实就是上面两个的合成.动画加入后开始之前,layer便处于动画初始状态,动画结束后layer保持动画最后的状态.</span><br><span class="line"></span><br><span class="line"><span class="header">速度控制函数(CAMediaTimingFunction) </span><br><span class="line">--------------</span></span><br><span class="line">kCAMediaTimingFunctionLinear(线性): 匀速,给你一个相对静态的感觉;</span><br><span class="line">kCAMediaTimingFunctionEaseIn(渐进): 动画缓慢进入,然后加速离开;</span><br><span class="line">kCAMediaTimingFunctionEaseOut(渐出): 动画全速进入,然后减速的到达目的地;</span><br><span class="line">kCAMediaTimingFunctionEaseInEaseOut(渐进渐出): 动画缓慢的进入,中间加速，然后减速的到达目的地。这个是默认的动画行为.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="UIView动画与核心动画对比?">UIView动画与核心动画对比?</h2><ul>
<li>UIView动画和核心动画区别?<ul>
<li>核心动画只能添加到CALayer(图层);</li>
<li>核心动画一切都是假象,并不会改变真实的值;</li>
</ul>
</li>
<li>什么时候使用UIView的动画?<ul>
<li>如果需要与用户交互就使用UIView的动画;</li>
<li>不需要与用户交互可以使用核心动画;</li>
</ul>
</li>
<li>什么场景使用核心动画最多?<ul>
<li>在转场动画中,核心动画的类型比较多;</li>
<li>根据一个路径做动画,只能用核心动画（帧动画）;</li>
<li>动画组: 同时做多个动画;</li>
</ul>
</li>
<li>UIView和CALayer该怎样选择?<ul>
<li>对比CALayer,UIView多了一个事件处理的功能.也就是说CALayer不能处理用户的触摸事件,而UIView可以,如果显示出来的东西需要跟用户进行交互的话,用UIView;如果不需要跟用户进行交互,用UIView或者CALayer都可以.CALayer的性能会高一些,因为它少了事件处理的功能,更加轻量级.</li>
</ul>
</li>
<li>猜想：<ul>
<li>View持有CALayer用于显示，View中大部分用于显示的属性都是有layer映射过来的。是否Layer 的 delegate 在这里是 View，当其属性改变、动画产生时，View 能够得到通知。也就是说，UIView的动画只是对核心动画的一层封装，在动画完成后也同时改变了View的一些属性。UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。</li>
</ul>
</li>
</ul>
<h3 id="使用UIView动画函数实现转场动画">使用UIView动画函数实现转场动画</h3> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 单视图 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)transitionWithView:(<span class="built_in">UIView</span> *)view duration:(<span class="built_in">NSTimeInterval</span>)duration options:(<span class="built_in">UIViewAnimationOptions</span>)options animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion;</span><br><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"><span class="comment">// duration：动画的持续时间</span></span><br><span class="line"><span class="comment">// view：需要进行转场动画的视图</span></span><br><span class="line"><span class="comment">// options：转场动画的类型</span></span><br><span class="line"><span class="comment">// animations：将改变视图属性的代码放在这个block中</span></span><br><span class="line"><span class="comment">// completion：动画结束后，会自动调用这个block</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双视图 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)transitionFromView:(<span class="built_in">UIView</span> *)fromView toView:(<span class="built_in">UIView</span> *)toView duration:(<span class="built_in">NSTimeInterval</span>)duration options:(<span class="built_in">UIViewAnimationOptions</span>)options completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion;</span><br><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"><span class="comment">// duration：动画的持续时间</span></span><br><span class="line"><span class="comment">// options：转场动画的类型</span></span><br><span class="line"><span class="comment">// animations：将改变视图属性的代码放在这个block中</span></span><br><span class="line"><span class="comment">// completion：动画结束后，会自动调用这个block</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[image与color之间互转]]></title>
      <url>http://xionv.com/2015/01/26/demonayu/blog/24.image%E4%B8%8Ecolor%E4%B9%8B%E9%97%B4%E4%BA%92%E8%BD%AC/</url>
      <content type="html"><![CDATA[<ul>
<li>颜色转图片, 集成到UIImage分类  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithColor:(<span class="built_in">UIColor</span> *)color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 描述矩形</span></span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">1.0</span>f);</span><br><span class="line">    <span class="comment">// 开启位图上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(rect<span class="variable">.size</span>);</span><br><span class="line">    <span class="comment">// 获取位图上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">// 使用color演示填充上下文</span></span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, color<span class="variable">.CGColor</span>);</span><br><span class="line">    <span class="comment">// 渲染上下文</span></span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(context, rect);</span><br><span class="line">    <span class="comment">// 从上下文中获取图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *theImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="comment">// 结束上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> theImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>图片转颜色  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> colorWithPatternImage:image];</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[长按截屏和图片裁剪]]></title>
      <url>http://xionv.com/2015/01/25/demonayu/blog/23.%E9%95%BF%E6%8C%89%E6%88%AA%E5%B1%8F%E5%92%8C%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA/</url>
      <content type="html"><![CDATA[<h3 id="长按截屏">长按截屏</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)longPress:(<span class="built_in">UILongPressGestureRecognizer</span> *)longPress</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注意这个longPress会调用两次,一次是触发时,一次是结束时, 所以这里需要对状态进行一次判定,避免两次触发</span></span><br><span class="line">    <span class="keyword">if</span> (longPress<span class="variable">.state</span> == <span class="built_in">UIGestureRecognizerStateBegan</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过设置首尾式动画来达到屏幕闪一下的效果</span></span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.2</span> animations:^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.alpha</span> = <span class="number">0.6</span>;</span><br><span class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">            [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span> animations:^&#123;</span><br><span class="line">                <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.alpha</span> = <span class="number">1</span>;</span><br><span class="line">            &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                <span class="comment">// 开启一个全屏位图上下文</span></span><br><span class="line">                <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>([<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span>, <span class="literal">YES</span>, <span class="number">0.0</span> );</span><br><span class="line">                <span class="comment">// 获取当前上下文</span></span><br><span class="line">                <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">                <span class="comment">// 渲染图层到上下文</span></span><br><span class="line">                [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> renderInContext:ctx];</span><br><span class="line">                <span class="comment">// 将当前上下文中的内容转成图片</span></span><br><span class="line">                <span class="built_in">UIImage</span> *capture = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">                <span class="comment">// 关闭上下文</span></span><br><span class="line">                <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">                <span class="comment">// 将图片输出</span></span><br><span class="line">                <span class="built_in">NSData</span> *imgData = <span class="built_in">UIImagePNGRepresentation</span>(capture);</span><br><span class="line">                [imgData writeToFile:<span class="string">@"/Users/Xion/Desktop/image.png"</span> atomically:<span class="literal">YES</span>];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图片裁剪">图片裁剪</h3><blockquote>
<p>为UIimage增加一个分类类方法,在实例化图片时就对其进行裁剪</p>
</blockquote>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="preprocessor">#import <span class="title">"UIImage+ClipImage.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">ClipImage</span>)</span></span><br><span class="line">+ (instancetype)imageNamed:(<span class="built_in">NSString</span> *)name withClipShape:(ClipShape)shape;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageNamed:name];</span><br><span class="line">    <span class="comment">// 开启一个上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(image<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 设置为模具</span></span><br><span class="line">    <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">        <span class="keyword">case</span> ClipShapeWithCircle: &#123; <span class="comment">// 圆</span></span><br><span class="line">            <span class="built_in">CGFloat</span> radius = image<span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span>;</span><br><span class="line">            <span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(radius, radius);</span><br><span class="line">            <span class="built_in">UIBezierPath</span> *circlePath = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:radius startAngle:<span class="number">0</span> endAngle:M_PI * <span class="number">2</span> clockwise:<span class="literal">YES</span>];</span><br><span class="line">            <span class="comment">// 设置裁剪区</span></span><br><span class="line">            [circlePath addClip];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ClipShapeWithtriangle: &#123; <span class="comment">// 三角形</span></span><br><span class="line">            <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">            <span class="built_in">CGPoint</span> startP = <span class="built_in">CGPointMake</span>(image<span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">            [path moveToPoint:startP];</span><br><span class="line">            [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, image<span class="variable">.size</span><span class="variable">.height</span>)];</span><br><span class="line">            [path addLineToPoint:<span class="built_in">CGPointMake</span>(image<span class="variable">.size</span><span class="variable">.width</span>, image<span class="variable">.size</span><span class="variable">.height</span>)];</span><br><span class="line">            <span class="comment">// 关闭路径</span></span><br><span class="line">            [path closePath];</span><br><span class="line">            [path addClip];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ClipShapeWithRhombus: &#123; <span class="comment">// 菱形</span></span><br><span class="line">            <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">            <span class="built_in">CGPoint</span> startP = <span class="built_in">CGPointMake</span>(image<span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">            [path moveToPoint:startP];</span><br><span class="line">            [path addLineToPoint:<span class="built_in">CGPointMake</span>(image<span class="variable">.size</span><span class="variable">.width</span>, image<span class="variable">.size</span><span class="variable">.height</span> * <span class="number">0.5</span>)];</span><br><span class="line">            [path addLineToPoint:<span class="built_in">CGPointMake</span>(image<span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span>, image<span class="variable">.size</span><span class="variable">.height</span>)];</span><br><span class="line">            [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, image<span class="variable">.size</span><span class="variable">.height</span> * <span class="number">0.5</span>)];</span><br><span class="line">            [path closePath];</span><br><span class="line">            [path addClip];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画出裁剪范围</span></span><br><span class="line">    [image drawAtPoint:<span class="built_in">CGPointZero</span>];</span><br><span class="line">    <span class="comment">// 将当前上下文的内容转成图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="comment">// 关闭上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> newImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用手势识别来简化事件处理]]></title>
      <url>http://xionv.com/2015/01/25/demonayu/blog/22.%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="UIGestureRecognizer手势识别">UIGestureRecognizer手势识别</h2><ul>
<li>UIGestureRecognizer是一个抽象类,定义了所有手势的基本行为,使用它的子类才能处理具体的手势.</li>
<li>利用UIGestureRecognizer,能轻松识别用户在某个view上面做的一些常见手势.</li>
<li>手势有以下几种:<ul>
<li>UITapGestureRecognizer(敲击)</li>
<li>UIPinchGestureRecognizer(捏合，用于缩放)</li>
<li>UIPanGestureRecognizer(拖拽)</li>
<li>UISwipeGestureRecognizer(轻扫)</li>
<li>UIRotationGestureRecognizer(旋转)</li>
<li>UILongPressGestureRecognizer(长按)</li>
</ul>
</li>
<li><p>手势使用方法:</p>
<ul>
<li><p>创建手势</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个拖动手势</span></span><br><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pan:)];</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加手势</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addGestureRecognizer:pan];</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现手势方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)pan:(<span class="built_in">UIPanGestureRecognizer</span> *)pan &#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>拖动的状态</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(pan<span class="variable">.state</span> == <span class="built_in">UIGestureRecognizerStateBegan</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"开始"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pan<span class="variable">.state</span> == <span class="built_in">UIGestureRecognizerStateChanged</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"移动"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pan<span class="variable">.state</span> == <span class="built_in">UIGestureRecognizerStateEnded</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"移开"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拖动状态复位</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复位 - 因为setTranslation会基于上一次的改变</span></span><br><span class="line">[pan setTranslation:<span class="built_in">CGPointZero</span> inView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>手势常用的代理方法</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否允许接收手指点击</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否允许同时支持多个手势 - 默认为NO</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[事件处理]]></title>
      <url>http://xionv.com/2015/01/13/demonayu/blog/21.%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="事件的产生和传递">事件的产生和传递</h2><ul>
<li>iOS当中常用的事件:<ul>
<li>触摸事件</li>
<li>加速计事件</li>
<li>远程控制事件</li>
</ul>
</li>
<li><p>处理事件的常用方法:</p>
<ul>
<li><p>触摸事件:</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加速计事件:</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">   - (<span class="keyword">void</span>)motionBegan:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)motionEnded:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)motionCancelled:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程控制事件:</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>事件是怎么传递的?</p>
<ul>
<li>比如当发生一个触摸事件后,系统会将该事件加入到一个由UIApplication管理的事件队列中.</li>
<li>UIApplication会从事件队列中取出最前面的事件,并将事件分发下去以便处理.</li>
<li>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件.</li>
<li><strong>触摸事件的传递是从父控件传递到子控件的, 如果一个父控件不能接收事件,那么它里面的了子控件也不能够接收事件.</strong></li>
</ul>
</li>
<li>一个控件什么情况下不能够接收事件.<ul>
<li>不能与用户交互的时候<code>userInteractionEnabled = NO</code>.(注意:UIImageView默认是不可交互的)</li>
<li>隐藏的时候<code>Hidden = YES</code>.</li>
<li>颜色为全透明的时候<code>alpha = 0</code>.</li>
</ul>
</li>
</ul>
<h2 id="事件响应">事件响应</h2><ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程 后，会找到最合适的视图控件来处理这个事件,找到最合适的视图控件后,就会调用控件的touches方法来作具体的事件处理那这些touches方法的默认做法是将事件顺着响应者链条向上传递,将事件交给上一个响应者进行处理.</li>
<li>什么是响应者对象和响应者链条: <ul>
<li>继承了UIResponds的对象我们称它为响应者对象</li>
<li>UIApplication、UIViewController、UIView都继承自UIResponder,因此它们都是响应者对象，都能够接收并处理事件</li>
<li>响应者链条是由多个响应者对象连接起来的链条.</li>
</ul>
</li>
<li><p>响应者链的事件传递过程</p>
<ol>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图<ul>
<li>如果当前的View是控制器的View,那么控制器就是上一个响应者.</li>
<li>如果当前的View不是控制器的View,那么它的父控件就是上一个响应者.</li>
</ul>
</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃<br><img src="http://r5.loli.io/UR77V3.png" alt="响应者链条示意图"></li>
</ol>
</li>
<li><p>如何寻找最合适的view</p>
<ol>
<li>先判断自己是否能够接收触摸事件,如果能再继续往下判断,</li>
<li>再判断触摸的当前点在不在自己的身上.</li>
<li>如果在自己身上,它会从后往前遍历子控件,遍历出每一个子控件后,重复前面的两个步骤.</li>
<li>如果没有符合条件的子控件,那么它自己就是最适合的View.<br><img src="http://r6.loli.io/j26faq.png" alt=""></li>
</ol>
</li>
</ul>
<h2 id="事件传递的完整过程">事件传递的完整过程</h2><ol>
<li>以触摸事件为例,先将事件对象由上往下传递(由父控件传递给子控件),找到最合适的控件来处理这个事件.</li>
<li>调用最合适控件的<code>touches…</code>方法.</li>
<li>如果调用了<code>[super touches….]</code>就会将事件顺着响应者链条往上传递,传递给上一个响应者.</li>
<li>接着就会调用上一个响应者的<code>touches…</code>方法.</li>
</ol>
<h3 id="hitTest方法与pointInside方法">hitTest方法与pointInside方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用:寻找最适合的View.</span></span><br><span class="line"><span class="comment">// 参数:当前手指所在的点;产生的事件</span></span><br><span class="line"><span class="comment">// 返回值:返回谁, 谁就是最适合的View.</span></span><br><span class="line"><span class="comment">// 什么时候用调用:只要一个事件,传递给一个控件时,就会调用这个控件的hitTest方法</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用:判断point在不在方法调用者上</span></span><br><span class="line"><span class="comment">// point:必须是方法调用者的坐标系</span></span><br><span class="line"><span class="comment">// 什么时候调用:hitTest方法底层会调用这个方法,判断点在不在控件上.</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>模拟<code>hitTest:withEvent:</code>方法的底层实现(寻找最合适view)  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.判断自己能否接收事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.hidden</span> == <span class="literal">YES</span> || <span class="keyword">self</span><span class="variable">.alpha</span> &lt;= <span class="number">0.01</span> || <span class="keyword">self</span><span class="variable">.userInteractionEnabled</span> == <span class="literal">NO</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.触摸点是否在自己身上</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> pointInside:point withEvent:event]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.从后往前遍历子控件,看自己的子控制器是否是最适合的View.</span></span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)<span class="keyword">self</span><span class="variable">.subviews</span><span class="variable">.count</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">UIView</span> *childV = <span class="keyword">self</span><span class="variable">.subviews</span>[i];</span><br><span class="line">        <span class="comment">//判断自己子控件是否是最适合的view</span></span><br><span class="line">        <span class="comment">//point点必须得要跟方法调用者在同一个坐标系上.</span></span><br><span class="line">        <span class="comment">//把当前点转换成子控件坐标系上面的点.</span></span><br><span class="line">        <span class="built_in">CGPoint</span> childViewP = [<span class="keyword">self</span> convertPoint:point toView:childV];</span><br><span class="line">        <span class="built_in">UIView</span> *fitView = [childV hitTest:childViewP withEvent:event];</span><br><span class="line">        <span class="keyword">if</span> (fitView) &#123;</span><br><span class="line">            <span class="keyword">return</span> fitView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有比它更适合的View.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="监听UIView的触摸事件来实现拖拽:">监听UIView的触摸事件来实现拖拽:</h3><ul>
<li>想要监听UIViiew的触摸事件,首先第一步要自定义UIView,因为只有实现了UIResponder的事件方法才能够监听事件.</li>
<li><p>一次完整的触摸过程，会经历3个状态：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 1. 触摸开始</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 2. 触摸移动</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 3. 触摸结束</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 触摸取消（可能会经历,比如突然来电,手机自动关机）</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure>
<ul>
<li>一次完整的触摸过程中，只会产生一个事件对象，4个触摸方法都是同一个event参数.</li>
<li>如果两根手指同时触摸一个view，那么view只会调用一次<code>touchesBegan:withEvent:</code>方法，touches参数中装着2个UITouch对象.</li>
<li>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次<code>touchesBegan:withEvent:</code>方法，并且每次调用时的touches参数中只包含一个UITouch对象.</li>
</ul>
</li>
<li>举例: 实现UIview的拖拽<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 拿到这个点</span></span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    <span class="comment">// 获得这个点的当前位置</span></span><br><span class="line">    <span class="built_in">CGPoint</span> currentP = [touch locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 获得这个点之前的位置</span></span><br><span class="line">    <span class="built_in">CGPoint</span> previousP = [touch previousLocationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 计算出偏移量 - 要移动的距离</span></span><br><span class="line">    <span class="built_in">CGFloat</span> distanceX = currentP<span class="variable">.x</span> - previousP<span class="variable">.x</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> distanceY = currentP<span class="variable">.y</span> - previousP<span class="variable">.y</span> ;</span><br><span class="line">    <span class="comment">// 改变view状态</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformTranslate</span>(<span class="keyword">self</span><span class="variable">.transform</span>, distanceX, distanceY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>使用手势识别来简化事件处理: <a href="http://xionv.com/2015/12/25/demonayu/blog/30.手势识别基本使用/">手势识别基本使用</a>.</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSArray和NSDictionary控制台中文打印]]></title>
      <url>http://xionv.com/2014/12/22/demonayu/blog/20.NSArray%E5%92%8CNSDictionary%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%87%E6%89%93%E5%8D%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>使用方法: 在项目中新建一个.m文件将代码拷贝到文件中即可.</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSDictionary</span> (<span class="title">Log</span>)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)descriptionWithLocale:(<span class="keyword">id</span>)locale</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    [str appendString:<span class="string">@"&#123;\n"</span>];</span><br><span class="line">    <span class="comment">// 遍历字典的所有键值对</span></span><br><span class="line">    [<span class="keyword">self</span> enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        [str appendFormat:<span class="string">@"\t%@ = %@,\n"</span>, key, obj];</span><br><span class="line">    &#125;];</span><br><span class="line">    [str appendString:<span class="string">@"&#125;"</span>];</span><br><span class="line">    <span class="comment">// 查出最后一个,的范围</span></span><br><span class="line">    <span class="built_in">NSRange</span> range = [str rangeOfString:<span class="string">@","</span> options:<span class="built_in">NSBackwardsSearch</span>];</span><br><span class="line">    <span class="comment">// 删掉最后一个,</span></span><br><span class="line">    [str deleteCharactersInRange:range];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSArray</span> (<span class="title">Log</span>)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)descriptionWithLocale:(<span class="keyword">id</span>)locale</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    [str appendString:<span class="string">@"[\n"</span>];</span><br><span class="line">    <span class="comment">// 遍历数组的所有元素</span></span><br><span class="line">    [<span class="keyword">self</span> enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        [str appendFormat:<span class="string">@"%@,\n"</span>, obj];</span><br><span class="line">    &#125;];</span><br><span class="line">    [str appendString:<span class="string">@"]"</span>];</span><br><span class="line">    <span class="comment">// 查出最后一个,的范围</span></span><br><span class="line">    <span class="built_in">NSRange</span> range = [str rangeOfString:<span class="string">@","</span> options:<span class="built_in">NSBackwardsSearch</span>];</span><br><span class="line">    <span class="comment">// 删掉最后一个,</span></span><br><span class="line">    [str deleteCharactersInRange:range];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSFileManager计算文件夹大小]]></title>
      <url>http://xionv.com/2014/12/21/demonayu/blog/19.NSFileManager%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F/</url>
      <content type="html"><![CDATA[<h1 id="计算文件夹大小">计算文件夹大小</h1><ul>
<li><p>给NSString添加一个计算文件夹大小的分类, 以字节输出</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件大小</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)sizeOfFile</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个文件管理者</span></span><br><span class="line">    <span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> fileSize = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> isDir = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (![mgr fileExistsAtPath:<span class="keyword">self</span> isDirectory:&amp;isDir]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果文件不存在直接退出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDir) &#123; <span class="comment">// 如果是文件夹</span></span><br><span class="line">        <span class="comment">// 取出所有子文件</span></span><br><span class="line">        <span class="built_in">NSArray</span> *subpaths = [mgr subpathsAtPath:<span class="keyword">self</span>];</span><br><span class="line">        <span class="comment">// 遍历所有子文件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *subpath <span class="keyword">in</span> subpaths) &#123;</span><br><span class="line">            <span class="comment">// 拼接拿到文件的全路径</span></span><br><span class="line">            <span class="built_in">NSString</span> *fullSubPath = [<span class="keyword">self</span> stringByAppendingPathComponent:subpath];</span><br><span class="line">            <span class="comment">// 判断是否是文件夹</span></span><br><span class="line">            <span class="built_in">BOOL</span> isDirectory = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">if</span> ([mgr fileExistsAtPath:fullSubPath isDirectory:&amp;isDirectory]) &#123; <span class="comment">// 这个文件夹/文件存在</span></span><br><span class="line">            <span class="keyword">if</span> (isDirectory == <span class="literal">NO</span>) &#123;  <span class="comment">// 是文件</span></span><br><span class="line">                fileSize += [[mgr attributesOfItemAtPath:fullSubPath error:<span class="literal">nil</span>][<span class="built_in">NSFileSize</span>] integerValue];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是文件</span></span><br><span class="line">        fileSize = [[mgr attributesOfItemAtPath:<span class="keyword">self</span> error:<span class="literal">nil</span>][<span class="built_in">NSFileSize</span>] integerValue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fileSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将字节单位转化为兆  </p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * (^fileSize)(<span class="built_in">NSUInteger</span>) = ^(<span class="built_in">NSUInteger</span> size) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *sizeStr = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 拿到图片缓存, 将字节转为兆</span></span><br><span class="line">    <span class="keyword">float</span> cacheSize = size / <span class="number">1000</span>;</span><br><span class="line">    sizeStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%d KB"</span>, (<span class="keyword">int</span>)cacheSize];</span><br><span class="line">    <span class="keyword">if</span> (((<span class="keyword">int</span>)cacheSize / <span class="number">1000</span>)) &#123;</span><br><span class="line">        cacheSize /= <span class="number">1000</span>;</span><br><span class="line">        sizeStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%.1f M"</span>, cacheSize];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cacheSize) &#123;</span><br><span class="line">        sizeStr = <span class="string">@"没有缓存"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sizeStr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="NSFileManager一些常用方法">NSFileManager一些常用方法</h1><ul>
<li><strong>判断一个文件或者文件夹是否存在</strong><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> flag = [manager fileExistsAtPath:<span class="string">@"/Users/apple/Desktop/abc.txt"</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>判断一个文件是否存在, 并且判断它是否是一个文件夹</strong></p>
<ul>
<li>注意: 该方法的返回值是说明传入的路径对应的文件或文件夹是否存在</li>
<li>第二个参数是用于保存判断结果的, 如果是一个目录, 那么就会赋值为YES, 如果不是就赋值为NO</li>
<li><p>BOOL dir = NO;</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> flag = [manager fileExistsAtPath:<span class="string">@"/Users/apple/Desktop/abc.txt"</span> isDirectory:&amp;dir];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>获取文件或文件夹的属性</strong></p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *info = [manager attributesOfItemAtPath:<span class="string">@"/Users/apple/Desktop/abc.txt"</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取文件夹中所有的文件</strong></p>
<ul>
<li>contentsOfDirectoryAtPath方法有一个弊端, 只能获取当前文件夹下所有的文件, 不能获取子文件夹下面的文件</li>
<li><p>subpathsOfDirectoryAtPath方法能够获取当前文件夹下的所有子文件和孙子文件.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *res = [manager contentsOfDirectoryAtPath:<span class="string">@"/Users/apple/Desktop/video"</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *res = [manager subpathsOfDirectoryAtPath:<span class="string">@"/Users/apple/Desktop/video"</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>创建文件夹</strong></p>
<ul>
<li>createDirectoryAtPath: 告诉系统文件夹需要创建到什么位置</li>
<li>withIntermediateDirectories: 如果指定的文件中有一些文件夹不存在, 是否自动创建不存在的文件夹</li>
<li>attributes: 指定创建出来的文件夹的属性</li>
<li>error: 是否创建成功, 如果失败会给传入的参数赋值</li>
<li><p>注意: 该方法只能用于创建文件夹, 不能用于创建文件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> flag = [manager createDirectoryAtPath:<span class="string">@"/Users/apple/Desktop/abc"</span> withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>创建文件</strong></p>
<ul>
<li>createFileAtPath: 指定文件创建出来的位置</li>
<li>contents : 文件中的内容</li>
<li>attributes: 创建出来的文件的属性</li>
<li>NSData : 二进制数据</li>
<li>注意: 该方法只能用于创建文件, 不能用于创建文件夹</li>
<li><p>NSString *str = @“我叫野原新之助”;</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *data = [str dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">[manager createFileAtPath:<span class="string">@"/Users/apple/Desktop/abc.txt"</span> contents:data attributes:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[copy深浅的规律]]></title>
      <url>http://xionv.com/2014/12/19/demonayu/blog/18.copy%E6%B7%B1%E6%B5%85%E7%9A%84%E8%A7%84%E5%BE%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>只有源对象和副本对象都不可变时，才是浅复制，其它都是深复制.</p>
</blockquote>
<ul>
<li>浅复制（浅拷贝，指针拷贝，shallow copy）<ul>
<li>源对象和副本对象是同一个对象</li>
<li>源对象（副本对象）引用计数器+1,相当于做一次retain操作</li>
<li>本质是：没有产生新的对象</li>
<li>原对象引用计数器+1</li>
<li>必须对原对象进行释放</li>
</ul>
</li>
</ul>
<ul>
<li>深复制（深拷贝，内容拷贝，deep copy）<ul>
<li>源对象和副本对象是不同的两个对象</li>
<li>源对象引用计数器不变,副本对象计数器为1（因为是新产生的）</li>
<li>本质是：产生了新的对象</li>
<li>必须释放新对象</li>
</ul>
</li>
</ul>
<p><img src="http://r.loli.io/ee63aa.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重写可变数组的[removeObject:]方法]]></title>
      <url>http://xionv.com/2014/10/18/demonayu/blog/17.%E9%87%8D%E5%86%99%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84removeObject:%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<ul>
<li><p>可变数组删除元素的原理:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSMutableArray</span> removeObject:obj];</span><br></pre></td></tr></table></figure>
<p>可变数组在调用<code>removeObject:</code>方法的时候会先去根类<code>NSObject</code>中调用<code>isEqual:</code>方法来遍历数组中所有对象的地址,来比对需要删除对象的地址,如果一样返回YES,如果不同返回NO.<br>我们可以根据这个特性在子类中重写<code>isEqual:</code>方法来达到只要对象的某一个属性值一样就能删除掉这个对象的目的.</p>
</li>
</ul>
<ul>
<li><p>系统默认的做法</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isEqual:(Book *)other</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == ohter) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在子类中重写方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isEqual:(Book *)other</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 比对两个对象的name属性值是否一样</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.name</span> isEqualToString:other<span class="variable">.name</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TableView顶部图片下拉放大]]></title>
      <url>http://xionv.com/2014/09/13/demonayu/blog/16.TableView%E9%A1%B6%E9%83%A8%E5%9B%BE%E7%89%87%E4%B8%8B%E6%8B%89%E6%94%BE%E5%A4%A7demo/</url>
      <content type="html"><![CDATA[<h2 id="实现tableView顶部图片下拉放大功能">实现tableView顶部图片下拉放大功能</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITableView</span> *tableView;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIImageView</span> *photoView;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"><span class="built_in">CGFloat</span> photoViewWH;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 设定图片的宽高</span></span><br><span class="line">    photoViewWH = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="comment">// 设置tableView内边距</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.contentInset</span> = <span class="built_in">UIEdgeInsetsMake</span>(photoViewWH * <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">UIImageView</span> *photoView = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">    <span class="comment">// 设置图片的位置,保证图片正好在tableView的上面不被覆盖</span></span><br><span class="line">    photoView<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, -photoViewWH, photoViewWH, photoViewWH);</span><br><span class="line">    photoView<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"photo"</span>];</span><br><span class="line">    <span class="comment">// 设置图片在photoView中的填充样式,ScaleAspectFill样式可以在图片size变大时,对图片等比例进行拉伸</span></span><br><span class="line">    photoView<span class="variable">.contentMode</span> = <span class="built_in">UIViewContentModeScaleAspectFill</span>;</span><br><span class="line">    <span class="comment">// 将photoView插入到tableView的最底层</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.tableView</span> insertSubview:photoView atIndex:<span class="number">0</span>];</span><br><span class="line">    _photoView = photoView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - UITableViewDataSource</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *ID = <span class="string">@"cell"</span>;</span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:ID];</span><br><span class="line">    <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</span><br><span class="line">        cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:ID];</span><br><span class="line">    &#125;</span><br><span class="line">    cell<span class="variable">.textLabel</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"测试数据&gt;&gt;&gt;%ld"</span>, indexPath<span class="variable">.row</span>];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - UIScrollViewDelegate</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当tableView的偏移量的y值小于photoView高度的一半时,则不改变photoView的frame.因为偏移量是负数所以这里用加号</span></span><br><span class="line">    <span class="keyword">if</span> (photoViewWH * <span class="number">0.5</span> + scrollView<span class="variable">.contentOffset</span><span class="variable">.y</span> &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取出photoView的frame修改高度后重新赋值</span></span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.photoView</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.size</span><span class="variable">.height</span> =  frame<span class="variable">.size</span><span class="variable">.height</span> * <span class="number">0.5</span> - scrollView<span class="variable">.contentOffset</span><span class="variable">.y</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.photoView</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WebView代理方法拦截网络请求]]></title>
      <url>http://xionv.com/2014/07/26/demonayu/blog/15.WebView%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
      <content type="html"><![CDATA[<h4 id="拦截请求的一个重要代理方法">拦截请求的一个重要代理方法</h4><p>这个代理方法是原生与网页之间的路由，通过这个方法可以拦截来自网页的请求。以下是截取出 URL 中想要的字符串来来进行 OAuth 认证。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拦截网络请求</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.取得请求路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *urlStr = request<span class="variable">.URL</span><span class="variable">.absoluteString</span>;</span><br><span class="line">    <span class="comment">// 2.获取到是否有 code= 关键字</span></span><br><span class="line">    <span class="built_in">NSRange</span> range = [urlStr rangeOfString:<span class="string">@"code="</span>];</span><br><span class="line">    <span class="keyword">if</span> (range<span class="variable">.length</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.截取code的值</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> fromIndex = range<span class="variable">.location</span> + range<span class="variable">.length</span>;</span><br><span class="line">        <span class="built_in">NSString</span> *code = [urlStr substringFromIndex:fromIndex];</span><br><span class="line">        <span class="comment">// 4.发送一个post请求，来获取到access_token</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *param = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        param[<span class="string">@"client_id"</span>] = client_id;</span><br><span class="line">        param[<span class="string">@"client_secret"</span>] = client_secret;</span><br><span class="line">        param[<span class="string">@"grant_type"</span>] = <span class="string">@"authorization_code"</span>;</span><br><span class="line">        param[<span class="string">@"code"</span>] = code;</span><br><span class="line">        param[<span class="string">@"redirect_uri"</span>] = redirect_uri;</span><br><span class="line">        [HTTPTool POST:<span class="string">@"https://api.weibo.com/oauth2/access_token"</span> parameters:param success:^(<span class="keyword">id</span> JSON) &#123;</span><br><span class="line">            <span class="comment">// 将返回值转成模型并归档</span></span><br><span class="line">            AccountData *account = [AccountData accountDataWithDict:JSON];</span><br><span class="line">            [AccountTool accountSave:account];</span><br><span class="line">        &#125; failure:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UITableViewCell自定义布局子控件]]></title>
      <url>http://xionv.com/2014/07/03/demonayu/blog/14.UITableViewCell%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80%E5%AD%90%E6%8E%A7%E4%BB%B6/</url>
      <content type="html"><![CDATA[<blockquote>
<p>TableView自定义cell的子控件布局有两种实现方式: 第一种是用传统的纯代码Frame设置; 第二种是用storyboard来设置.</p>
</blockquote>
<h2 id="Frame实现自定义cell布局">Frame实现自定义cell布局</h2><p><strong>两个重要的setter方法:</strong></p>
<ul>
<li><p>在cellView重写StatusesFrame的setter方法给中cellView的每个子控件赋值</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setStatusesFrame:(XVStatusesFrame *)statusesFrame</span><br><span class="line">&#123;</span><br><span class="line">    _statusesFrame = statusesFrame;</span><br><span class="line">    XVStatuses *status = statusesFrame<span class="variable">.status</span>;</span><br><span class="line">    <span class="comment">// 给子控件赋值</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.nameLabel</span><span class="variable">.text</span> = status<span class="variable">.name</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.text_Label</span><span class="variable">.text</span> = status<span class="variable">.text</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.iconView</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:status<span class="variable">.icon</span>];</span><br><span class="line">    <span class="comment">// 判断是否有图片</span></span><br><span class="line">    <span class="keyword">if</span> (status<span class="variable">.picture</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pictureView</span><span class="variable">.hidden</span> = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pictureView</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:status<span class="variable">.picture</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pictureView</span><span class="variable">.hidden</span> = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是vip</span></span><br><span class="line">    <span class="keyword">if</span> (status<span class="variable">.isVip</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.vipView</span><span class="variable">.hidden</span> = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.vipView</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"vip"</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.nameLabel</span><span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.vipView</span><span class="variable">.hidden</span> = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.nameLabel</span><span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置子控件位置</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.nameLabel</span><span class="variable">.frame</span> = statusesFrame<span class="variable">.nameLabelF</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.text_Label</span><span class="variable">.frame</span> = statusesFrame<span class="variable">.text_LabelF</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.iconView</span><span class="variable">.frame</span> = statusesFrame<span class="variable">.iconViewF</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.pictureView</span><span class="variable">.frame</span> = statusesFrame<span class="variable">.pictureViewF</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.vipView</span><span class="variable">.frame</span> = statusesFrame<span class="variable">.vipViewF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在StatusesFrame模型中重写Status的setter方法,根据传进来的数据来算出各个子控件的frame,并返回给控制器来设置每个cell的高度</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setStatus:(XVStatuses *)status</span><br><span class="line">&#123;</span><br><span class="line">    _status = status;</span><br><span class="line">    <span class="comment">// 根据文字来计算UILabel的rect</span></span><br><span class="line">    <span class="built_in">CGSize</span> (^fontSize)(<span class="built_in">NSString</span>*, <span class="built_in">CGFloat</span>, <span class="built_in">CGFloat</span>) = ^(<span class="built_in">NSString</span> *text, <span class="built_in">CGFloat</span> fontSize, <span class="built_in">CGFloat</span> maxWidth) &#123;</span><br><span class="line">        <span class="keyword">return</span> [text boundingRectWithSize:<span class="built_in">CGSizeMake</span>(maxWidth, MAXFLOAT)</span><br><span class="line">                                  options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span></span><br><span class="line">                               attributes:@&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> systemFontOfSize:fontSize]&#125;</span><br><span class="line">                                  context:<span class="literal">nil</span>]<span class="variable">.size</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// icon的位置</span></span><br><span class="line">    <span class="built_in">CGFloat</span> iconViewW = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> iconViewH = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> iconViewX = margin;</span><br><span class="line">    <span class="built_in">CGFloat</span> iconViewY = margin;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.iconViewF</span> = <span class="built_in">CGRectMake</span>(iconViewX, iconViewY, iconViewW, iconViewH);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// name的位置</span></span><br><span class="line">    <span class="built_in">CGSize</span> nameSize = fontSize(status<span class="variable">.name</span>, nameFontSize, MAXFLOAT);</span><br><span class="line">    <span class="built_in">CGFloat</span> nameLabelW = nameSize<span class="variable">.width</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> nameLabelH = nameSize<span class="variable">.height</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> nameLabelX = <span class="built_in">CGRectGetMaxX</span>(<span class="keyword">self</span><span class="variable">.iconViewF</span>) + margin;</span><br><span class="line">    <span class="built_in">CGFloat</span> nameLabelY = margin;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.nameLabelF</span> = <span class="built_in">CGRectMake</span>(nameLabelX, nameLabelY, nameLabelW, nameLabelH);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// vip的位置</span></span><br><span class="line">    <span class="built_in">CGFloat</span> vipViewW = <span class="number">14</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> vipViewH = nameLabelH;</span><br><span class="line">    <span class="built_in">CGFloat</span> vipViewX = <span class="built_in">CGRectGetMaxX</span>(<span class="keyword">self</span><span class="variable">.nameLabelF</span>) + margin;</span><br><span class="line">    <span class="built_in">CGFloat</span> vipViewY = margin;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.vipViewF</span> = <span class="built_in">CGRectMake</span>(vipViewX, vipViewY, vipViewW, vipViewH);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// text位置</span></span><br><span class="line">    <span class="built_in">CGFloat</span> text_LabelW = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span> - <span class="number">2</span> * margin;</span><br><span class="line">    <span class="built_in">CGFloat</span> text_LabelH = fontSize(status<span class="variable">.text</span>, textFontSize, text_LabelW)<span class="variable">.height</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> text_LabelX = margin;</span><br><span class="line">    <span class="built_in">CGFloat</span> text_LabelY = <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span><span class="variable">.iconViewF</span>) + margin;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.text_LabelF</span> = <span class="built_in">CGRectMake</span>(text_LabelX, text_LabelY, text_LabelW, text_LabelH);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.status</span><span class="variable">.picture</span><span class="variable">.length</span>) &#123;</span><br><span class="line">        <span class="comment">// picture位置</span></span><br><span class="line">        <span class="built_in">CGFloat</span> pictureVieW = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> pictureVieH = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> pictureVieX = margin;</span><br><span class="line">        <span class="built_in">CGFloat</span> pictureVieY = <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span><span class="variable">.text_LabelF</span>) + margin;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pictureViewF</span> = <span class="built_in">CGRectMake</span>(pictureVieX, pictureVieY, pictureVieW, pictureVieH);</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.statusHeight</span> = <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span><span class="variable">.pictureViewF</span>) + margin;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.statusHeight</span> = <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span><span class="variable">.text_LabelF</span>) + margin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在代理方法中返回当前每个cell的高度</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    XVStatusesFrame *frame = <span class="keyword">self</span><span class="variable">.statusFrame</span>[indexPath<span class="variable">.row</span>];</span><br><span class="line">    <span class="keyword">return</span> frame<span class="variable">.statusHeight</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Storyboard实现自定义cell的布局">Storyboard实现自定义cell的布局</h2><ul>
<li>首先在使用storyboard布局单元格前先了解一下苹果在iOS8推出的<code>Self Sizing Cells</code>功能.<ul>
<li><code>Self Sizing Cells</code>是为了解放程序员以往苦逼的计算不等高cell尺寸而推出的新功能, 它可以动态的计算tableView每一行cell的高度.</li>
<li><code>Self Sizing Cells</code>依赖于<code>Auto Layout</code>.</li>
</ul>
</li>
<li><p>举一个例子来展示如何使用:</p>
<ol>
<li>在storyboard中拖一个UITableView, 采用系统默认的设置, prototype cell数量设为1.<br><img src="http://r5.loli.io/7vAJj2.png" alt=""></li>
<li>为cell中的每一个控件摆好位置并设置束缚<br><img src="http://r5.loli.io/3EvQvm.png" alt=""></li>
<li><p><strong>设置tableView的<code>rowHeight</code>属性为<code>UITableViewAutomaticDimension</code></strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置自动计算高度</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.rowHeight</span> = <span class="built_in">UITableViewAutomaticDimension</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置tableView的<code>estimatedRowHeight</code>估计高度为<code>44</code>(这个值可以根据自己需要修改)</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 估算高度</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.estimatedRowHeight</span> = <span class="number">44</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后给cell中的每一个子控件赋值就能显示出来了, 不用做任何计算.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setStatus:(XVStatuses *)status</span><br><span class="line">&#123;</span><br><span class="line">    _status = status;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.nameLabel</span><span class="variable">.text</span> = status<span class="variable">.name</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.text_Label</span><span class="variable">.text</span> = status<span class="variable">.text</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.iconView</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:status<span class="variable">.icon</span>];</span><br><span class="line">    <span class="comment">// 判断是否有图片</span></span><br><span class="line">    <span class="keyword">if</span> (status<span class="variable">.picture</span><span class="variable">.length</span> ) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pictureView</span><span class="variable">.hidden</span> = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">// 根据控制束缚的值来控制控件的尺寸</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pictureHeight</span><span class="variable">.constant</span> = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pictureBottom</span><span class="variable">.constant</span> = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pictureView</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:status<span class="variable">.picture</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pictureHeight</span><span class="variable">.constant</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pictureBottom</span><span class="variable">.constant</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pictureView</span><span class="variable">.hidden</span> = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是vip</span></span><br><span class="line">    <span class="keyword">if</span> (status<span class="variable">.vip</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.vipView</span><span class="variable">.hidden</span> = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.vipView</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"vip"</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.nameLabel</span><span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.vipView</span><span class="variable">.hidden</span> = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.nameLabel</span><span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>注意: cell的高度是通过改变约束的长度来控制的.这里利用约束的优先级特性不能达到要求, 因为即使pictureView隐藏了但它身上的约束仍然生效. 如果要让低优先级的约束生效,必须要移除高优先级的控件或其上面的约束,但是这样在显示下一个cell的时候又需要重新添加约束.</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SQLite在iOS中的使用(下)]]></title>
      <url>http://xionv.com/2014/06/21/demonayu/blog/13.SQLite%E5%9C%A8iOS%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8(%E4%B8%8B)/</url>
      <content type="html"><![CDATA[<h2 id="使用数据库存储任意对象">使用数据库存储任意对象</h2><blockquote>
<p>使用FMDB框架来操作数据库</p>
</blockquote>
<ol>
<li><p>新建一个模型类,有name和price两个属性, 并导入FMDB头文件 </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"Shop.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"FMDB.h"</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在加载类的时候创建数据库</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个FMDatabase类的对象</span></span><br><span class="line"><span class="keyword">static</span> FMDatabase *_db;</span><br><span class="line"><span class="comment">// 第一次使用类时</span></span><br><span class="line">+ (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.数据库路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>)<span class="variable">.lastObject</span> stringByAppendingPathComponent:<span class="string">@"shop.sqlite"</span>];</span><br><span class="line">    <span class="comment">// 2.链接数据库</span></span><br><span class="line">    _db = [FMDatabase databaseWithPath:path];</span><br><span class="line">    <span class="comment">// 3.打开数据库</span></span><br><span class="line">    [_db open];</span><br><span class="line">    <span class="comment">// 4.建表</span></span><br><span class="line">    [_db executeUpdate:<span class="string">@"CREATE TABLE IF NOT EXISTS t_shop (id integer PRIMARY KEY, shop blob NOT NULL)"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加增/删/查方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入数据, 直接传入shop对象</span></span><br><span class="line">+ (<span class="keyword">void</span>)insertObject:(<span class="keyword">id</span>)object</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将对象转成NSData数据</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:shop];</span><br><span class="line">    <span class="comment">// 将data存进数据库</span></span><br><span class="line">    [_db executeUpdateWithFormat:<span class="string">@"INSERT INTO t_shop (shop) VALUES (%@);"</span>, data];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除所有数据</span></span><br><span class="line">+ (<span class="keyword">void</span>)deleteAll</span><br><span class="line">&#123;</span><br><span class="line">    [_db executeUpdateWithFormat:<span class="string">@"DELETE FROM t_shop;"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取出数据</span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)shops</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    FMResultSet *set = [_db executeQuery:<span class="string">@"SELECT * FROM t_shop;"</span>];</span><br><span class="line">    <span class="keyword">while</span> (set<span class="variable">.next</span>) &#123;</span><br><span class="line">        <span class="comment">// 取出二进制数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [set dataForColumn:<span class="string">@"shop"</span>];</span><br><span class="line">        <span class="comment">// 将二进制数据还原成对象</span></span><br><span class="line">        Shop *shop = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:data];</span><br><span class="line">        <span class="comment">// 将还原出来的对象存进数组</span></span><br><span class="line">        [array addObject:shop];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在shop.h中遵守 &lt; NSCoding &gt; 协议,并在shop.m中实现 encodeWithCoder: 和 initWithCoder:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder</span><br><span class="line">&#123;</span><br><span class="line">    [aCoder encodeObject:<span class="keyword">self</span><span class="variable">.name</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">    [aCoder encodeFloat:<span class="keyword">self</span><span class="variable">.price</span> forKey:<span class="string">@"price"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.name</span> = [aDecoder decodeObjectForKey:<span class="string">@"name"</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.price</span> = [aDecoder decodeFloatForKey:<span class="string">@"price"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在控制器中直接调用模型方法就可以从数据库中得到数据了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存入对象</span></span><br><span class="line">- (<span class="keyword">void</span>)save</span><br><span class="line">&#123;</span><br><span class="line">    Shop *shop = [[Shop alloc] init];</span><br><span class="line">    shop<span class="variable">.name</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"电脑"</span>];</span><br><span class="line">    shop<span class="variable">.price</span> = <span class="number">1999.9</span>;</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    [Shop insertObject:shop];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取</span></span><br><span class="line">- (<span class="keyword">void</span>)read</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *array = [Shop shops];</span><br><span class="line">    <span class="keyword">for</span> (Shop *shop <span class="keyword">in</span> array) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, shop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line">- (<span class="keyword">void</span>)delete</span><br><span class="line">&#123;</span><br><span class="line">    [Shop deleteAll];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SQLite在iOS中的使用(上)]]></title>
      <url>http://xionv.com/2014/06/18/demonayu/blog/12.%E5%9C%A8iOS%E4%B8%AD%E4%BD%BF%E7%94%A8SQLite(%E4%B8%8A)/</url>
      <content type="html"><![CDATA[<h1 id="1-_什么是SQLite">1. 什么是SQLite</h1><ul>
<li>SQLite是一款轻型的嵌入式数据库, 它属于关系数据库</li>
<li>它的处理速度非常快,它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了.</li>
</ul>
<h2 id="如何使用SQLite">如何使用SQLite</h2><ol>
<li><p>在iOS中要使用SQLite,必须先导入libsqlite3.dylib库.<br>如图:<br><img src="http://r6.loli.io/j2mIvy.png" alt=""></p>
</li>
<li><p>新建一个模型类, 并导入头文件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;sqlite3.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在实现方法中定义一个全局的静态变量</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span></span></span><br><span class="line"><span class="comment">// 定义一个sqlite3类型的结构体指针(数据库对象)</span></span><br><span class="line"><span class="keyword">static</span> sqlite3 *_db;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>链接数据库, 创建表</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首次调用这个类的时候链接数据库</span></span><br><span class="line">+ (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1&gt; 获取沙盒路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>)<span class="variable">.lastObject</span> stringByAppendingPathComponent:<span class="string">@"computer.sqlite"</span>];</span><br><span class="line">    <span class="comment">// 2&gt; 根据路径打开数据库(相当于执行connection),传入数据库对象的地址,如果打开成功创建表.</span></span><br><span class="line">    <span class="keyword">int</span> result = sqlite3_open(path<span class="variable">.UTF8String</span>, &amp;_db); </span><br><span class="line">    <span class="keyword">if</span> (result != SQLITE_OK) &#123; <span class="comment">// 打开数据库失败</span></span><br><span class="line">        <span class="comment">// 关闭数据库</span></span><br><span class="line">        sqlite3_close(_db);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"打开数据库失败"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 打开数据库成功</span></span><br><span class="line">        <span class="keyword">char</span> *err; <span class="comment">// 创表失败的错误信息</span></span><br><span class="line">        <span class="comment">// 定义sql语句</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *sql = <span class="string">"CREATE TABLE IF NOT EXISTS t_computer (ID INTEGER PRIMARY KEY, name TEXT, price REAL);"</span>; </span><br><span class="line">        <span class="comment">// 3&gt; 执行sql语句,在数据库(_db)中建表</span></span><br><span class="line">        <span class="keyword">if</span> (sqlite3_exec(_db, sql, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;err) != SQLITE_OK) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"创表失败---%s"</span>, err); <span class="comment">// 打印错误信息</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"创表成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义类方法来快速实现数据库的增\删\改\查</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增 - 传一个名字和价格增加一条记录</span></span><br><span class="line">+ (<span class="keyword">void</span>)insertDataWithName:(<span class="built_in">NSString</span> *)name price:(<span class="keyword">float</span>)price</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义sql语句</span></span><br><span class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"INSERT INTO t_computer (name, price) VALUES ('%@', '%f');"</span>, name, price];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sql = str<span class="variable">.UTF8String</span>;</span><br><span class="line">    <span class="comment">// 执行sql语句</span></span><br><span class="line">    sqlite3_exec(_db, sql, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删 - 传入名字删除对应名字的记录</span></span><br><span class="line">+ (<span class="keyword">void</span>)deletedDataWithName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"DELETE FROM t_computer WHERE name = '%@';"</span>, name];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sql = str<span class="variable">.UTF8String</span>;</span><br><span class="line">    sqlite3_exec(_db, sql, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改 - 修改对应名字的价格</span></span><br><span class="line">+ (<span class="keyword">void</span>)updatePrice:(<span class="keyword">float</span>)price forName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"UPDATE t_computer SET price = '%f' WHERE name = '%@';"</span>, price, name];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sql = str<span class="variable">.UTF8String</span>;</span><br><span class="line">    sqlite3_exec(_db, sql, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查 - 取出数据库中所有的数据并将每一个字段转成模型的属性值存入数组返回出去</span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)computers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个可变数组来接收模型</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *arrayM = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="comment">// 定义sql语句</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sql = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"SELECT * FROM t_computer;"</span>]<span class="variable">.UTF8String</span>;</span><br><span class="line">    <span class="comment">// 用来接收数据库查询的所有内容</span></span><br><span class="line">    sqlite3_stmt *stmt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 如果查询到数据</span></span><br><span class="line">    <span class="keyword">if</span> (sqlite3_prepare_v2(_db, sql, -<span class="number">1</span>, &amp;stmt, <span class="literal">nil</span>) == SQLITE_OK) &#123;</span><br><span class="line">        <span class="comment">// 传入所有查询结果(stmt),逐步检索每一条记录,一直往下查找,直到SQLITE_ROW为null</span></span><br><span class="line">        <span class="keyword">while</span> (sqlite3_step(stmt) == SQLITE_ROW) &#123;</span><br><span class="line">            XVComputers *computer = [[XVComputers alloc] init];</span><br><span class="line">            <span class="comment">// 取出查找的值并赋给模型</span></span><br><span class="line">            computer<span class="variable">.name</span> = [<span class="built_in">NSString</span> stringWithUTF8String:(<span class="keyword">char</span> *)sqlite3_column_text(stmt, <span class="number">1</span>)];</span><br><span class="line">            computer<span class="variable">.price</span> = sqlite3_column_double(stmt, <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 将赋值后的对象放进数组</span></span><br><span class="line">            [arrayM addObject:computer];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="2-_FMDB">2. FMDB</h1><ul>
<li>什么是FMDB<ul>
<li>FMDB是iOS平台的SQLite数据库框架</li>
<li>FMDB以OC的方式封装了SQLite的C语言API</li>
</ul>
</li>
<li>FMDB的优点<ul>
<li>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</li>
<li>对比苹果自带的Core Data框架，更加轻量级和灵活</li>
<li>提供了多线程安全的数据库操作方法，有效地防止数据混乱</li>
</ul>
</li>
<li>项目地址: <a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">FMDB</a></li>
</ul>
<h2 id="如何使用FMDB">如何使用FMDB</h2><ol>
<li><p>在Xcode中导入libsqlite3.dylib动态链接库</p>
</li>
<li><p>新建一个模型类导入框架的头文件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"FMDB.h"</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在实现方法中定义一个全局的静态变量</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span></span></span><br><span class="line"><span class="comment">// 创建一个FMDatabase对象</span></span><br><span class="line"><span class="keyword">static</span> FMDatabase *_db;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>链接数据库,建表</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> + (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>)<span class="variable">.lastObject</span> stringByAppendingPathComponent:<span class="string">@"cmpt.sqlite"</span>];</span><br><span class="line">    <span class="comment">// 链接数据库</span></span><br><span class="line">    _db = [FMDatabase databaseWithPath:path];</span><br><span class="line">    <span class="comment">// 打开数据库</span></span><br><span class="line">    [_db open];</span><br><span class="line">    <span class="comment">// 建表</span></span><br><span class="line">    [_db executeUpdate:<span class="string">@"CREATE TABLE IF NOT EXISTS t_cmpt (id INTEGER PRIMARY KEY, name TEXT, price REAL);"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现增\删\改\查  </p>
<ul>
<li><em>框架中的增删改都是用的 executeUpdate 方法</em></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">+ (<span class="keyword">void</span>)insertName:(<span class="built_in">NSString</span> *)name price:(<span class="keyword">float</span>)price</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注意在这个框架中sql语句中的字符串占位符不需要加单引号</span></span><br><span class="line">    [_db executeUpdateWithFormat:<span class="string">@"INSERT INTO t_cmpt (name, price) VALUES (%@, %f)"</span>, name, price];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 删除数据</span></span><br><span class="line">+ (<span class="keyword">void</span>)deleteAll</span><br><span class="line">&#123;</span><br><span class="line">    [_db executeUpdateWithFormat:<span class="string">@"DELETE FROM t_cmpt"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><em>查询使用的是 executeQuery 方法</em></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询数据并返回模型数组</span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)computers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回一个查询到的结果集</span></span><br><span class="line">    FMResultSet *set = [_db executeQuery:<span class="string">@"SELECT * FROM t_cmpt;"</span>];</span><br><span class="line">    <span class="comment">// 创建一个可变数组来存放模型</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *arrM = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="comment">// 在集中往下查询每一条记录</span></span><br><span class="line">    <span class="keyword">while</span> ([set next]) &#123;</span><br><span class="line">        XVComputers *computer = [[XVComputers alloc] init];</span><br><span class="line">        computer<span class="variable">.name</span> = [set stringForColumn:<span class="string">@"name"</span>];</span><br><span class="line">        computer<span class="variable">.price</span> = [set stringForColumn:<span class="string">@"price"</span>]<span class="variable">.floatValue</span>;</span><br><span class="line">        [arrM addObject:computer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="FMDatabaseQueue">FMDatabaseQueue</h3><ul>
<li>FMDatabase这个类是线程不安全的，如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题.</li>
<li><p>为了保证线程安全，FMDB提供方便快捷的FMDatabaseQueue类.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个FMDatabaseQueue队列</span></span><br><span class="line"><span class="built_in">NSString</span> *path = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>)<span class="variable">.lastObject</span> stringByAppendingPathComponent:<span class="string">@"cmpt.sqlite"</span>];</span><br><span class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:path];</span><br><span class="line"><span class="comment">// 执行队列</span></span><br><span class="line">[queue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    [db executeUpdate:<span class="string">@"INSERT INTO t_cpmt (name) VALUES (?)"</span>, <span class="string">@"惠普"</span>];</span><br><span class="line">    [db executeUpdate:<span class="string">@"INSERT INTO t_cpmt (name) VALUES (?)"</span>, <span class="string">@"戴尔"</span>];</span><br><span class="line">    [db executeUpdate:<span class="string">@"INSERT INTO t_cpmt (name) VALUES (?)"</span>, <span class="string">@"华硕"</span>];</span><br><span class="line">    <span class="comment">// 取数据</span></span><br><span class="line">    FMResultSet *set = [db executeQuery:<span class="string">@"select * from t_cpmt"</span>];</span><br><span class="line">    <span class="keyword">while</span> ([set next]) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[直接修改对象frame结构体中的成员属性]]></title>
      <url>http://xionv.com/2014/04/16/demonayu/blog/11.%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%B1%A1frame%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在iOS中系统默认不能直接修改结构体成员属性的值, 通过添加分类来实现这个功能.</p>
</blockquote>
<ul>
<li>头文件(.h)  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">Extension</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> x;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> y;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> centerX;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> centerY;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> width;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> height;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> size;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGPoint</span> origin;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>实现文件(.m)  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"UIView+Extension.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">Extension</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setX:(<span class="built_in">CGFloat</span>)x</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.origin</span><span class="variable">.x</span> = x;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setY:(<span class="built_in">CGFloat</span>)y</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.origin</span><span class="variable">.y</span> = y;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)x</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.origin</span><span class="variable">.x</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)y</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.origin</span><span class="variable">.y</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCenterX:(<span class="built_in">CGFloat</span>)centerX</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> center = <span class="keyword">self</span><span class="variable">.center</span>;</span><br><span class="line">    center<span class="variable">.x</span> = centerX;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.center</span> = center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCenterY:(<span class="built_in">CGFloat</span>)centerY</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> center = <span class="keyword">self</span><span class="variable">.center</span>;</span><br><span class="line">    center<span class="variable">.y</span> = centerY;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.center</span> = center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)centerX</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.center</span><span class="variable">.x</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)centerY</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.center</span><span class="variable">.y</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWidth:(<span class="built_in">CGFloat</span>)width</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.size</span><span class="variable">.width</span> = width;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setHeight:(<span class="built_in">CGFloat</span>)height</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.size</span><span class="variable">.height</span> = height;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)height</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)width</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setSize:(<span class="built_in">CGSize</span>)size</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.size</span> = size;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGSize</span>)size</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setOrigin:(<span class="built_in">CGPoint</span>)origin</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.origin</span> = origin;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGPoint</span>)origin</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.origin</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AutoLayout的简单使用]]></title>
      <url>http://xionv.com/2014/04/15/demonayu/blog/10.AutoLayout%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="AutoResizing">AutoResizing</h2><ul>
<li>AutoResizing可以用作屏幕适配,但只能设置自身与父控件之间的相对关系,局限性很大.</li>
<li>AutoResizing是UIView的一个成员属性.</li>
<li>AutoResizing可用于控件关系简单的轻量的屏幕适配.</li>
<li>AutoResizing与AutoLayout是互斥的.<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scrollView的宽高可伸缩, 意思就是scrollView的宽高与父控件宽高始终一致</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.autoresizingMask</span> = <span class="built_in">UIViewAutoresizingFlexibleWidth</span> | <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line"><span class="comment">// pageController的顶部间隙与宽高可伸缩, 意思就是把控件固定在父控件底部, 宽度随父控件的宽度而变化</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.pageController</span><span class="variable">.autoresizingMask</span> = <span class="built_in">UIViewAutoresizingFlexibleTopMargin</span> | <span class="built_in">UIViewAutoresizingFlexibleWidth</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="AutoLayout">AutoLayout</h2><ul>
<li><p>Autolayout是一种“自动布局”技术，专门用来布局UI界面.</p>
</li>
<li><p>Autolayout的2个核心概念</p>
<ul>
<li>约束:通过给控件添加约束,来决定控件的位置和尺寸</li>
<li>参照:在添加约束时,是依照谁来添加(可以是父控件或者兄弟控件)</li>
</ul>
</li>
<li><p>添加约束的规则</p>
<ul>
<li>对于有层次关系的两个view之间的约束关系，添加到层次较高的父view上<br><img src="http://r5.loli.io/IfYNvy.png" alt=""></li>
<li>对于两个同层级view之间的约束关系，添加到它们的父view上<br><img src="http://r6.loli.io/QnyMNn.png" alt=""></li>
<li>对于两个不同层级view之间的约束关系，添加到他们最近的共同父view上<br><img src="http://r5.loli.io/zi2U3u.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="StoryBorad_中实现AutoLayout">StoryBorad 中实现AutoLayout</h2><ul>
<li>添加新的约束<br><img src="http://r6.loli.io/2qYZZ3.png" alt=""></li>
<li>设置对齐<br><img src="http://r6.loli.io/YBJjEj.png" alt=""></li>
<li>更新frame和约束<br><img src="http://r5.loli.io/6Zjaa2.png" alt=""></li>
<li><p>修改单个约束属性<br><img src="http://r.loli.io/VZnymq.png" alt=""></p>
</li>
<li><p>Autolayout的警告和错误</p>
<ul>
<li><p>警告</p>
<ul>
<li>控件的frame不匹配所添加的约束,比如约束控件的宽度为100, 而控件现在的宽度是110.</li>
</ul>
</li>
<li><p>错误</p>
<ul>
<li>缺乏必要的约束, 比如只约束了宽度和高度, 没有约束具体的位置.</li>
<li>两个约束冲突, 比如1个约束控件的宽度为100, 1个约束控件的宽度为110.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="代码实现AutoLayout">代码实现AutoLayout</h2><ul>
<li><em>如果使用了自动布局就不用再给view设置frame</em></li>
<li><p><em>使用AutoLayout要先禁止autoresizing功能，设置view的下面属性为NO</em></p>
</li>
<li><p>创建约束对象的常用方法</p>
<ul>
<li>view1 ：要约束的控件</li>
<li>attr1 ：约束的类型（做怎样的约束）</li>
<li>relation ：与参照控件之间的关系</li>
<li>view2 ：参照的控件</li>
<li>attr2 ：约束的类型（做怎样的约束）</li>
<li>multiplier ：乘数</li>
<li>c ：常量<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)constraintWithItem:(<span class="keyword">id</span>)view1 attribute:(<span class="built_in">NSLayoutAttribute</span>)attr1 relatedBy:(<span class="built_in">NSLayoutRelation</span>)relation toItem:(<span class="keyword">id</span>)view2 attribute:(<span class="built_in">NSLayoutAttribute</span>)attr2 multiplier:(<span class="built_in">CGFloat</span>)multiplier constant:(<span class="built_in">CGFloat</span>)c;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>示例: 给一个view添加约束</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建红色的view添加到控制器中</span></span><br><span class="line"><span class="built_in">UIView</span> *redView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">redView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"><span class="comment">// 禁止autoresizing自动转为autolayout的约束</span></span><br><span class="line">redView<span class="variable">.translatesAutoresizingMaskIntoConstraints</span> = <span class="literal">NO</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:redView];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.添加约束 - 利用NSLayoutConstraint类创建具体的约束对象</span></span><br><span class="line"><span class="comment">// 宽度约束</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *wLc = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:redView attribute:<span class="built_in">NSLayoutAttributeWidth</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="literal">nil</span> attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span> multiplier:<span class="number">0.0</span> constant:<span class="number">100</span>];</span><br><span class="line">[redView addConstraint:wLc];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高度约束</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *hLc = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:redView attribute:<span class="built_in">NSLayoutAttributeHeight</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="literal">nil</span> attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span> multiplier:<span class="number">0.0</span> constant:<span class="number">100</span>];</span><br><span class="line">[redView addConstraint:hLc];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边约束</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *rightLc = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:redView attribute:<span class="built_in">NSLayoutAttributeRight</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span><span class="variable">.view</span> attribute:<span class="built_in">NSLayoutAttributeRight</span> multiplier:<span class="number">1.0</span> constant:-<span class="number">20</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addConstraint:rightLc];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底部约束</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *bottomLc = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:redView attribute:<span class="built_in">NSLayoutAttributeBottom</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span><span class="variable">.view</span> attribute:<span class="built_in">NSLayoutAttributeBottom</span> multiplier:<span class="number">1.0</span> constant:-<span class="number">20</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addConstraint:bottomLc];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="VFL语言实现autolayout">VFL语言实现autolayout</h3><ul>
<li><p>VFL全称是Visual Format Language, 翻译过来是“可视化格式语言”,  它是苹果公司为了简化Autolayout的编码而推出的抽象语言.</p>
</li>
<li><p>使用VFL来创建约束数组</p>
<ul>
<li>format ：VFL语句</li>
<li>opts ：约束类型</li>
<li>metrics ：VFL语句中用到的具体数值</li>
<li>views ：VFL语句中用到的控件 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)constraintsWithVisualFormat:(<span class="built_in">NSString</span> *)format options:(<span class="built_in">NSLayoutFormatOptions</span>)opts metrics:(<span class="built_in">NSDictionary</span> *)metrics views:(<span class="built_in">NSDictionary</span> *)views;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>示例: 给一个view添加约束</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1.创建红色的view添加到控制器中</span></span><br><span class="line"><span class="built_in">UIView</span> *redView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">redView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"><span class="comment">// 禁止autoresizing自动转为autolayout的约束</span></span><br><span class="line">redView<span class="variable">.translatesAutoresizingMaskIntoConstraints</span> = <span class="literal">NO</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:redView];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.设置约束</span></span><br><span class="line"> <span class="comment">// 束缚规则</span></span><br><span class="line"> <span class="comment">// 水平方向</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *views = @&#123;<span class="string">@"redView"</span> : redView&#125;;</span><br><span class="line"><span class="built_in">NSDictionary</span> *metrics = @&#123;<span class="string">@"space"</span> : @<span class="number">30</span>&#125;;</span><br><span class="line"> <span class="comment">// 要执行的VFL语言 - 这句话表示:水平方向上，redView与父控件左右边缘的距离</span></span><br><span class="line"><span class="built_in">NSString</span> *vfl_h = <span class="string">@"H:|-space-[redView]-space-|"</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *hLcs = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:vfl_h options:kNilOptions metrics:metrics views:views];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addConstraints:hLcs];</span><br><span class="line"> <span class="comment">// 垂直方向</span></span><br><span class="line"> <span class="comment">// 垂直方向上，redView与父控件底部边缘的距离</span></span><br><span class="line"><span class="built_in">NSString</span> *vfl_v = <span class="string">@"V:[redView(40)]-space-|"</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *vLcs = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:vfl_v options:kNilOptions metrics:metrics views:views];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addConstraints:vLcs];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> PS : 创建一个字典（内部包含VFL语句中用到的控件）的快捷宏定义<br> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDictionaryOfVariableBindings</span>(...)</span><br></pre></td></tr></table></figure></p>
<h2 id="Masonry框架的简单使用">Masonry框架的简单使用</h2><ul>
<li>目前最流行的Autolayout第三方框架, 用优雅的代码方式编写Autolayout, 省去了苹果官方恶心的Autolayout代码, 大大提高了开发效率</li>
<li>项目地址: <a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">Masonry</a></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//define this constant if you want to use Masonry without the 'mas_' prefix</span></span><br><span class="line"><span class="preprocessor">#define MAS_SHORTHAND</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//define this constant if you want to enable auto-boxing for default syntax</span></span><br><span class="line"><span class="preprocessor">#define MAS_SHORTHAND_GLOBALS</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"><span class="comment">// 导入框架头文件</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"Masonry.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIView</span> *blueView;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">/* 添加三个View */</span></span><br><span class="line">    <span class="built_in">UIView</span> *redView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    redView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:redView];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *blueView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    blueView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> blueColor];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:blueView];</span><br><span class="line">    _blueView = blueView;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *greenView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    greenView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:greenView];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给redView添加约束</span></span><br><span class="line">    [redView makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        <span class="comment">// 设置宽高</span></span><br><span class="line">        make<span class="variable">.width</span><span class="variable">.height</span><span class="variable">.equalTo</span>(<span class="number">100</span>); <span class="comment">// 不写参照,默认参照为父控件</span></span><br><span class="line">        <span class="comment">// 设置左边约束偏移量</span></span><br><span class="line">        make<span class="variable">.left</span><span class="variable">.equalTo</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 设置底部约束偏移量</span></span><br><span class="line">        make<span class="variable">.bottom</span><span class="variable">.equalTo</span>(-<span class="number">20</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 给blueView添加约束</span></span><br><span class="line">    [blueView makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make<span class="variable">.width</span><span class="variable">.height</span><span class="variable">.equalTo</span>(redView);</span><br><span class="line">        make<span class="variable">.left</span><span class="variable">.equalTo</span>(redView<span class="variable">.right</span>)<span class="variable">.offset</span>(<span class="number">20</span>); <span class="comment">// 以redView为参照</span></span><br><span class="line">        make<span class="variable">.bottom</span><span class="variable">.equalTo</span>(redView);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 给greenView添加约束</span></span><br><span class="line">    [greenView makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make<span class="variable">.width</span><span class="variable">.height</span><span class="variable">.equalTo</span>(redView);</span><br><span class="line">        make<span class="variable">.left</span><span class="variable">.equalTo</span>(blueView<span class="variable">.right</span>)<span class="variable">.offset</span>(<span class="number">20</span>); <span class="comment">// 以blueView为参照</span></span><br><span class="line">        make<span class="variable">.bottom</span><span class="variable">.equalTo</span>(redView);</span><br><span class="line">        <span class="comment">// 设置优先级 - 当优先级较高的约束失效后优先级低的约束生效</span></span><br><span class="line">        make<span class="variable">.left</span><span class="variable">.equalTo</span>(redView<span class="variable">.right</span>)<span class="variable">.offset</span>(<span class="number">20</span>)<span class="variable">.priorityLow</span>();</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 移除blueView使greenView的另一条约束生效</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.blueView</span> removeFromSuperview];</span><br><span class="line">    <span class="comment">// 执行动画</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span> animations:^&#123;</span><br><span class="line">        <span class="comment">// 强制刷新控件</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.view</span> layoutIfNeeded];</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 更新约束</span></span><br><span class="line">    <span class="comment">// [self.greenView updateConstraints:^(MASConstraintMaker *make) &#123;</span></span><br><span class="line">    <span class="comment">//    make.left.equalTo(self.redView.right).offset(20);</span></span><br><span class="line">    <span class="comment">// &#125;];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS: AutoLayout 关于更新约束的几个方法</p>
<ul>
<li>setNeedsLayout: 告知页面需要更新,但是不会立刻开始更新,执行后会立刻调用layoutSubviews.</li>
<li><strong>layoutIfNeeded: 告知页面布局立刻更新.所以一般都会和setNeedsLayout一起使用.如果希望立刻生成新的frame需要调用此方法,利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效.</strong></li>
<li>layoutSubviews: 系统重写布局.</li>
<li>setNeedsUpdateConstraints: 告知需要更新约束,但是不会立刻开始.</li>
<li>updateConstraintsIfNeeded: 告知立刻更新约束.</li>
<li>updateConstraints:系统更新约束.</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[简单的首尾式动画]]></title>
      <url>http://xionv.com/2014/03/18/demonayu/blog/09.%E9%A6%96%E5%B0%BE%E5%BC%8F%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在iOS的中实现首尾式动画是一件很简单的事情, 只需要几行代码搞定.</p>
</blockquote>
<h2 id="1-_实现渐变动画">1. 实现渐变动画</h2><ul>
<li><p>在控制器中新建一个监听手势点击的方法.</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在方法中添加一个UIView, 当然UIImageView,UILabel都可以, 只要继承自UIView就OK.</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子控件的初始状态</span></span><br><span class="line"><span class="built_in">UIView</span> *animationView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>)];</span><br><span class="line">animationView<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line"><span class="comment">// 初始化view的alpha为0.0,它是一个实型,可以理解成透明度,当控件alpha的为0时是全透明,不可见且不可交互.</span></span><br><span class="line"><span class="comment">// 使用alpha可以实现渐隐的动画效果</span></span><br><span class="line">animationView<span class="variable">.alpha</span> = <span class="number">0.0</span>;</span><br><span class="line">animationView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"><span class="comment">// 将控件添加进父控件</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:animationView];</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现动画效果</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 开始动画</span></span><br><span class="line">[<span class="built_in">UIView</span> beginAnimations:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 2. 动画时长</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> time = <span class="number">2.0</span>;</span><br><span class="line">[<span class="built_in">UIView</span> setAnimationDuration:time];</span><br><span class="line"><span class="comment">// 3. 需要动画执行完毕后控件的状态</span></span><br><span class="line">animationView<span class="variable">.bounds</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">// 改变alpha值实现渐隐效果</span></span><br><span class="line">animationView<span class="variable">.alpha</span> = <span class="number">0.8</span>;</span><br><span class="line"><span class="comment">// 4. 提交动画</span></span><br><span class="line">[<span class="built_in">UIView</span> commitAnimations];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样我们新创建的控件会伴有动画效果显示出来并且一直待在父控件上.</p>
<ul>
<li>用block来是实现动画效果  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">2.0</span> animations:^&#123; </span><br><span class="line">    <span class="comment">// 控件的最终状态</span></span><br><span class="line">    animationView<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    animationView<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line">    animationView<span class="variable">.alpha</span> = <span class="number">0.0</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-_实现首尾式动画">2. 实现首尾式动画</h2><ul>
<li>实现提示框(hub)那种类型的首尾式动画效果 (显示后立即消失). </li>
<li>block嵌套实现首尾式动画</li>
<li><p>将上面实现动画的代码替换成下面的代码:</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// delay: 表示动画需要延时多少秒后执行</span></span><br><span class="line"><span class="comment">// options: 可以选择动画在执行过程中方式(比如先快后慢等等)</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">2.0</span> delay:<span class="number">0</span> options:<span class="built_in">UIViewAnimationOptionCurveEaseInOut</span> animations:^&#123;</span><br><span class="line">    <span class="comment">// 第一阶段动画执行完毕后的控件状态</span></span><br><span class="line">    animationView<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">    animationView<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line">    animationView<span class="variable">.alpha</span> = <span class="number">0.8</span>;</span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished) &#123; <span class="comment">// 第一阶段动画执行完毕后</span></span><br><span class="line">    <span class="comment">// 控件的最终状态</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">2.0</span> animations:^&#123; <span class="comment">// 第二阶段动画并显示控件最终状态</span></span><br><span class="line">        animationView<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">        animationView<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line">        animationView<span class="variable">.alpha</span> = <span class="number">0.0</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个子控件会在两秒钟内放大并显示,然后在两秒钟后缩小消失.</p>
</li>
</ul>
<hr>
<blockquote>
<p>ps: 首尾式动画是显式动画.<br>pps: 能够实现动画的属性基本都是实型,像BOOL类型的属性就不能用来显示动画效果.<br>ppps: 每个UIView都是由图层来显示图像的, 也就是说每个UIView中都有一个CALayer成员变量,来显示图像, 而且这个成员变量是不可交互的, 改变自定义图层的属性, 可以触发隐式动画.</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[了解一下KVC和KVO]]></title>
      <url>http://xionv.com/2014/03/16/demonayu/blog/08.KVC%E5%92%8CKVO/</url>
      <content type="html"><![CDATA[<h2 id="KVC">KVC</h2><h3 id="KVC的一般使用">KVC的一般使用</h3><ul>
<li>全称：Key Value Coding（键值编码）</li>
<li><p>赋值</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 能修改私有成员变量</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">void</span>)setValuesForKeysWithDictionary:(<span class="built_in">NSDictionary</span> *)keyedValues;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取值</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 能取得私有成员变量的值</span></span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span> *)keys;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="KVC的底层原理">KVC的底层原理</h3><ul>
<li><p>KVC的本质就是调用成员属性的setter和getter方法.</p>
</li>
<li><p><code>setValuesForKeysWithDictionary:</code>方法的底层实现  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历字典给对应模型的成员属性赋值(key值就是成员属性名)</span></span><br><span class="line">  [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull obj, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">      [item setValue:obj forKeyPath:key];</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>setValue:forKeyPath:</code>的底层实现:</p>
<ol>
<li>调用key对应成员属性名的setter方法;</li>
<li>如果找不到,找带下划线(_)的成员属性名,然后给这个成员属性直接赋值.</li>
<li>如果找不到,找与key名完全相同的成员属性名,然后直接赋值.</li>
<li>如果都找不到,则程序崩溃,报错找不到对应的成员属性.</li>
</ol>
<p>ps: 可以利用KVC的实现原理来重写赋值过程</p>
</li>
<li><p>容器操作符:KVC还提供了一些复杂的函数操作符,比如:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@"aba"</span>,<span class="string">@"cbc"</span>,<span class="string">@"dvd"</span>];</span><br><span class="line"><span class="built_in">NSUInteger</span> totalLenth = [[array valueForKeyPath:<span class="string">@"@sum.length"</span>] intValue];</span><br></pre></td></tr></table></figure>
<p>其中key值里面包含的<code>@sum</code>就是一个操作符, 能够对指定的属性(length)求和.类似数据操作的还有:<code>@avg</code>平均值, <code>@count</code> 总数, <code>@max</code>最大, <code>@min</code>最小.注:以上这些操作符只能用于集合(如:NSArray).</p>
</li>
</ul>
<h2 id="KVO">KVO</h2><h3 id="KVO的一般使用">KVO的一般使用</h3><ul>
<li>全称：Key Value Observing（键值监听）</li>
<li>作用：监听模型的属性值改变</li>
<li><p>步骤</p>
<ul>
<li><p>添加监听器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用b对象来监听a对象name属性的改变</span></span><br><span class="line">[a addObserver:b forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="string">@"test"</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>在监听器中实现监听方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change     context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@ %@ %@"</span>, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>举例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1&gt; 在控制器中创建和初始化成员变量</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.person</span> = [[Person alloc] initWithName:<span class="string">@"Xion"</span> age:<span class="number">23</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2&gt; 添加观察者 self.person将控制器添加为监听自己的观察者,来观察age属性的改变</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.person</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:<span class="number">0</span> context:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加一个button操作来修改成员变量的值</span></span><br><span class="line">- (<span class="keyword">void</span>)buttonClick</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 改变成员变量属性值</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.person</span><span class="variable">.age</span> += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3&gt; 控制器监听值的改变</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当监听的值为age, 且监听的对象为self.person</span></span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"age"</span>] &amp;&amp; object == <span class="keyword">self</span><span class="variable">.person</span>) &#123;</span><br><span class="line">        <span class="comment">// 更新显示</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.label</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@现在的年龄是%lu"</span>, _person<span class="variable">.name</span>, _person<span class="variable">.age</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="KVO的底层原理">KVO的底层原理</h3><ul>
<li>一句话概括: 系统利用runtime动态添加一个被监听类(以NSKVONotifying_开头)的子类, 在该子类中重写需要被监听key值的setter方法,在内部调用<code>willChangeValueForKey:</code> <code>didChangeValueForKey:</code>方法来监听key值得变化.</li>
<li>ps:苹果不希望这个机制暴露在外部.除了setters,这个动态生成的子类同时也重写了<code>-class</code>方法,依旧返回原先的class!如果不仔细看的话,被KVO过的object看起来和原先的object没什么两样.</li>
<li>参考建议: <a href="http://limboy.me/ios/2013/08/05/internal-implementation-of-kvo.html" target="_blank" rel="external">(译)KVO的内部实现</a>, <a href="http://blog.sunnyxx.com/2014/03/09/objc_kvo_secret/" target="_blank" rel="external">objc kvo简单探索</a>.</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用NSValue来包装结构体]]></title>
      <url>http://xionv.com/2014/03/14/demonayu/blog/07.%E5%88%A9%E7%94%A8NSValue%E6%9D%A5%E5%8C%85%E8%A3%85%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>NSValue可以包装任意值,可以用NSValue将结构体包装后,加入NSArray\NSDictionary中.</p>
</blockquote>
<ul>
<li><p>利用NSValue包装常用结构体</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGPoint</span> point = <span class="built_in">NSMakePoint</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">NSValue</span> *value = [<span class="built_in">NSValue</span> valueWithPoint:point];</span><br><span class="line"><span class="built_in">NSArray</span> *arr = @[value];</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用NSValue包装自定义结构体</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">&#125;Person;</span><br><span class="line"></span><br><span class="line">Person p = &#123;<span class="number">24</span>, <span class="string">"XiaoMing"</span>, <span class="number">183</span>&#125;;</span><br><span class="line"><span class="comment">// valueWithBytes: 接收一个指针, 传递需要包装的结构体的地址.</span></span><br><span class="line"><span class="comment">// objCType: 需要包装的数据类型</span></span><br><span class="line"><span class="built_in">NSValue</span> *pValue = [<span class="built_in">NSValue</span> valueWithBytes:&amp;p objCType:@encode(Person)];</span><br><span class="line"><span class="built_in">NSArray</span> *arr = @[pValue];</span><br><span class="line"><span class="comment">// 从NSValue中取出自定义的结构体变量</span></span><br><span class="line">Person res;</span><br><span class="line">[pValue getValue:&amp;res];</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见的结构体包装方法</p>
<ul>
<li><p>将结构体包装成NSValue对象</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSValue</span> *)valueWithPoint:(<span class="built_in">NSPoint</span>)point;</span><br><span class="line">+ (<span class="built_in">NSValue</span> *)valueWithSize:(<span class="built_in">NSSize</span>)size;</span><br><span class="line">+ (<span class="built_in">NSValue</span> *)valueWithRect:(<span class="built_in">NSRect</span>)rect;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从NSValue中取出包装的结构体</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSPoint</span>)pointValue;</span><br><span class="line">- (<span class="built_in">NSSize</span>)sizeValue;</span><br><span class="line">- (<span class="built_in">NSRect</span>)rectValue;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>NSValue包装任意数据类型</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// value参数 : 所包装数据的地址</span></span><br><span class="line"><span class="comment">// type参数 : 用来描述这个数据类型的字符串, 用@encode指令来生成</span></span><br><span class="line">+ (<span class="built_in">NSValue</span> *)valueWithBytes:(<span class="keyword">const</span> <span class="keyword">void</span> *)value objCType:(<span class="keyword">const</span> <span class="keyword">char</span> *)type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从NSValue中取出所包装的数据</span></span><br><span class="line">- (<span class="keyword">void</span>)getValue:(<span class="keyword">void</span> *)value;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一个应用程序的启动流程]]></title>
      <url>http://xionv.com/2014/03/07/demonayu/blog/06.%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="应用程序完整启动流程">应用程序完整启动流程</h2><ol>
<li>执行Main函数.</li>
<li><p>在main函数中调用UIApplicationMain函数. </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建UIApplication对象,并设置UIApplicationMain对象的代理.</p>
<ul>
<li>UIApplicationMain的第三个参数就是UIApplication的名称,如果指定为nil,它会默认为UIApplication.(nil == @”UIApplication”);</li>
<li>UIApplicationMain的第四个参数为UIApplication的代理.</li>
</ul>
</li>
<li><p>开启一个主运行循环,保证应用程序不退出.  </p>
</li>
<li>加载info.plist程序配置文件.判断info.plist文件当中的key:[Main storyboard file base name]<br>有没有指定storyboard文件,如果有就去加载storyboard文件,如果没有,那么应用程序加载完毕.</li>
</ol>
<h3 id="UIApplication">UIApplication</h3><ul>
<li>UIApplication类提供了对运行在iOS设备上的app集中控制和调度的机制.每一个app有且只有一个UIApplication或者其子类的实例.当程序启动的时候,会调用UIApplicationMain函数,在这个函数中会创建一个UIApplication类的单例,这个单例在整个iOS系统中就是app的抽象.之后你就能够通过shareApplication方法来调用该单例.</li>
<li>UIApplication对象的主要工作是处理用户事件的路由.它也会给UIcontrol对象分发动作消息.另外,UIApplication还维护了当前App打开的窗口的列表.所以,你通过它能够取到你App中任何一个View.</li>
<li>这个app实例还实现了一个delegate,接受各种各样程序运行时的事件,比如: 程序启动、低内存警告、程序崩溃等等.</li>
<li>程序还能通过openURL: 方法来接受和处理一个邮件或者图片文件.比如一个以Email开头的URL将能够唤起Email程序来展示这个邮件.</li>
<li><p>UIApplication的编程接口让你能够管理一些硬件指定的行为.比如: </p>
<ul>
<li>控制App来响应设备方向变化</li>
<li>暂时终止接受触摸事件</li>
<li>打开或者关闭接近用户脸部的感应</li>
<li>注册远程消息通知</li>
<li>打开或者关闭undo-redo UI</li>
<li>决定你的程序是否能够支持某一类的URL</li>
<li>扩展程序能力,让app能够在后台运行</li>
<li>发布或者取消本地通知</li>
<li>接受运程控制事件</li>
<li>执行程序级别的复位操作</li>
</ul>
</li>
<li><p>UIApplication必须实现UIApplicationDelegate协议来实现他的一些协议.</p>
</li>
</ul>
<h4 id="UIApplication的一些功能具体使用">UIApplication的一些功能具体使用</h4><ul>
<li><p>设置应用的监听权限</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前iOS版本号</span></span><br><span class="line"><span class="keyword">float</span> sysVersion = [[<span class="built_in">UIDevice</span> currentDevice] systemVersion]<span class="variable">.floatValue</span>;</span><br><span class="line"><span class="comment">// iOS8以后必须要获取通知权限才能显示applicationIconBadgeNumber</span></span><br><span class="line"><span class="keyword">if</span> (sysVersion &gt;= <span class="number">8.0</span>) &#123;</span><br><span class="line">    <span class="built_in">UIUserNotificationType</span> type = <span class="built_in">UIUserNotificationTypeBadge</span> | <span class="built_in">UIUserNotificationTypeAlert</span> | <span class="built_in">UIUserNotificationTypeSound</span>;</span><br><span class="line">    <span class="built_in">UIUserNotificationSettings</span> *setting = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:type categories:<span class="literal">nil</span>];</span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:setting];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>网络提醒(连接网络提示)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">application<span class="variable">.networkActivityIndicatorVisible</span> = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置状态栏</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐藏状态栏</span></span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] setStatusBarHidden:<span class="literal">YES</span> withAnimation:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 状态栏样式</span></span><br><span class="line">application<span class="variable">.statusBarStyle</span> = <span class="built_in">UIStatusBarStyleLightContent</span>;</span><br></pre></td></tr></table></figure>
<p> 应用程序的状态栏默认是控制器来管理, 但是通常在开发当中都设置为应用程序来统一管理状态栏. 在info.plist当中进行配置:<code>View controller-based status bar appearance : NO</code></p>
</li>
<li>跳转页面<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开网页</span></span><br><span class="line">[application openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.baidu.com"</span>]];</span><br><span class="line"><span class="comment">// 跳转到打电话</span></span><br><span class="line">[application openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"tel://10000"</span>]];</span><br><span class="line"><span class="comment">// 跳转到发短信</span></span><br><span class="line">[application openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"sms://10000"</span>]];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="应用程序的生命周期">应用程序的生命周期</h2><ul>
<li><p>应用程序启动完成</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"应用程序启动了"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"UIApplication调用了我"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用程序即将失去焦点</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我退出了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用程序完全进入后台</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"进入后台"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用程序即将进入前台</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我回来了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用程序重新获得焦点</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我刷新了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用程序即将关闭</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我拜拜了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="应用程序显示流程">应用程序显示流程</h2><ol>
<li>创建一个窗口 (UIWindow, 系统已经默认创建这个成员属性, 需要手动初始化)</li>
<li>创建根控制器 (rootViewController)</li>
<li>给窗口设置根控制器 (window.rootViewController)</li>
<li><p>显示窗口(makeKeyAndVisible).<br>makeKeyAndVisible方法 : 把窗口设置为应用程序的主窗口. 窗口默认是隐藏的,当调用该方法后, 会设置窗口的hidden = no, 并把这个窗口设置为主窗口并显示.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 1.创建UIWindow</span></span><br><span class="line">   <span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[[<span class="built_in">UIScreen</span> mainScreen] bounds]];</span><br><span class="line">   <span class="keyword">self</span><span class="variable">.window</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">   <span class="comment">// 2.初始化根控制器</span></span><br><span class="line">   ViewController *vc = [[ViewController alloc] init];</span><br><span class="line">   <span class="comment">// 3.设置窗口根控制器</span></span><br><span class="line">   <span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = vc;</span><br><span class="line">   <span class="comment">// 4.把UIWindow 设为当前窗口</span></span><br><span class="line">   [<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps: window的显示与根控制器中view的显示互不影响. view在window的上面.</p>
</li>
</ol>
<h3 id="控制器view的显示流程">控制器view的显示流程</h3><ol>
<li><p>先判断控制器是不是从storyboard中加载. </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIViewController</span> *vc = [[<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:<span class="literal">nil</span>] instantiateInitialViewController];</span><br></pre></td></tr></table></figure>
</li>
<li><p>再判断是不是从xib中加载</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIViewController</span> *vc = [[<span class="built_in">UIViewController</span> alloc] initWithNibName:<span class="string">@"VC"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 1&gt; initWithNibName:如果指定了名称,那么它就会去加载指定名称的Xib.</span></span><br><span class="line"><span class="comment">//  MyViewController *vc =  [[MyViewController alloc] initWithNibName:@"VC" bundle:nil];</span></span><br><span class="line"><span class="comment">// 2&gt; 如果没有指定名称.指定为nil,那么它就会去先加载跟它相同名称的Xib.</span></span><br><span class="line"><span class="comment">//  MyViewController *vc =  [[MyViewController alloc] initWithNibName:nil bundle:nil];</span></span><br><span class="line"><span class="comment">// 3&gt; 如果没有跟它名称相同的Xib,那么它就会去加载去掉Controller后跟它名称相同的Xib</span></span><br></pre></td></tr></table></figure>
<p>ps: 控制器的<code>init</code>方法默认会调用<code>initWithNibName:</code>方法.</p>
</li>
</ol>
<ol>
<li><p>如果都不是,控制器会调用loadView方法,创建一个空的UIView.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当控制器被使用的时候,控制器会调用loadView方法.loadView --&gt; viewDidLoad</span></span><br><span class="line">- (<span class="keyword">void</span>)loadView</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">self</span><span class="variable">.view</span> = [[<span class="built_in">UIView</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>附:在Xcode6以后配置pch文件<br><img src="http://r.loli.io/AzaUje.png" alt=""></p>
<p>在pch文件中配置调试模式时运行XWLog(…)代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef DEBUG</span></span><br><span class="line"><span class="preprocessor">#define XWLog(...) NSLog(__VA_ARGS__)</span></span><br><span class="line"><span class="preprocessor">#else</span></span><br><span class="line"><span class="preprocessor">#define XWLog(...)</span></span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure>
<p>ps: 在宏当中<code>...</code>表示可变参数.在函数中表示可变参数用:<code>__VA_ARGS__</code>.</p>
<p>拓展阅读: <a href="http://www.jianshu.com/p/aa50e5350852?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=writer_share&amp;utm_source=weibo" target="_blank" rel="external">iOS应用程序的生命周期</a>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[监听事件的4种方式]]></title>
      <url>http://xionv.com/2014/02/16/demonayu/blog/05.%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="OC中监听事件的4种方法">OC中监听事件的4种方法</h3><ul>
<li>通知（NSNotificationCenter\NSNotification）<ul>
<li>任何对象之间都可以传递消息</li>
<li>1个对象可以发通知给多个对象</li>
<li>1个对象可以接受多个对象发出的通知</li>
<li>要求:必须得保证通知的名字在发出和监听时是一致的</li>
</ul>
</li>
<li>KVO<ul>
<li>仅仅是能监听对象属性的改变（灵活度不如通知和代理）</li>
<li>只能作用在单个文件</li>
</ul>
</li>
<li>代理 <ul>
<li>协议就是接口, 提供方法的声明来给代理去实现.</li>
<li>1个对象只能设置一个代理(假设这个对象只有1个代理属性)</li>
<li>1个对象能成为多个对象的代理</li>
</ul>
</li>
<li>target<ul>
<li>继承UIControl的类都能使用addTarget方法来监听事件</li>
<li>必须在控件创建时就添加监听行为</li>
<li>一个对象只能监听一个事件点击</li>
<li>只能作用在单个文件</li>
</ul>
</li>
</ul>
<h3 id="如何选择?">如何选择?</h3><ul>
<li><code>target</code>用于监听控件的点击/长按等触发事件</li>
<li><code>通知</code>适用于层级很深或者两个没有关联的类之间的事件监听</li>
<li><code>KVO</code>适用于监听对象某个属性的改变</li>
<li><code>代理</code>比<code>通知</code>规范,建议使用<code>代理</code>多于<code>通知</code>,能使用代理尽量使用代理</li>
</ul>
<h3 id="监听方式的核心代码">监听方式的核心代码</h3><ul>
<li><p><strong>通知</strong><br>notificationName: 通知内容(key)<br>object: 通知发布者<br>userInfo: 发布者附带的信息 </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布通知</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:key object:object userInfo:userInfo];</span><br></pre></td></tr></table></figure>
<p>observer: 监听者<br>selector: 监听后执行的方法<br>name: 通知内容(key)<br>object: 通知发布者</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加监听者</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:observer selector:<span class="keyword">@selector</span>(selector:) name:name object:object];</span><br></pre></td></tr></table></figure>
<p>注意: 有添加就要有移除, 一般移除监听写在dealloc方法中  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除监听</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>KVO</strong><br>object: 被监听者<br>observer: 监听者<br>keyPath: 被监听者的属性<br>options: 监听模式(内容)<br>context: 上下文   </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加监听</span></span><br><span class="line">[object addObserver:observer forKeyPath:keyPath options:options context:context];</span><br></pre></td></tr></table></figure>
<p>keyPath: 被监听的属性<br>object: 被监听的对象<br>change: 被监听属性值的改变情况(字典)<br>context: 上下文</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 实现监听方法</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 监听当_per这个成员变量的age这个属性发生改变时</span></span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"age"</span>] &amp;&amp; object == _person) &#123;</span><br><span class="line">        <span class="comment">// 给控制器的成员变量赋新值</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.label</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@现在的年龄是%lu"</span>, _person<span class="variable">.name</span>, _person<span class="variable">.age</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>代理</strong><br>@required: 代理方法必须实现(默认)<br>@optional: 代理方法选择实现  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义协议</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span>  <span class="title">XVFooterBarDelegate</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)footbarValueChanged:(XVFooterBar *)footbar;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加代理</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;XVFooterBarDelegate&gt; delegate;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">  - (<span class="keyword">void</span>)cleanBuy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加代理的事件监听</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.delegate</span> respondsToSelector:<span class="keyword">@selector</span>(footbarValueChanged:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.delegate</span> footbarValueChanged:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 在代理的类中实现代理方法</span></span><br><span class="line">  - (<span class="keyword">void</span>)footbarValueChanged:(XVFooterBar *)footbar</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><strong>target</strong><br>target: 监听者<br>action: 要执行的方法<br>controlEvents:触发事件    <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加监听</span></span><br><span class="line">- (<span class="keyword">void</span>)addTarget:(nullable <span class="keyword">id</span>)target action:(SEL)action forControlEvents:(<span class="built_in">UIControlEvents</span>)controlEvents;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TableView中MVC模式的简单应用]]></title>
      <url>http://xionv.com/2014/01/13/demonayu/blog/04.%E6%A8%A1%E5%9E%8B%E6%8E%A7%E5%88%B6View%E7%9A%84%E6%98%BE%E7%A4%BAdemo/</url>
      <content type="html"><![CDATA[<h3 id="模型视图控制器之间:">模型视图控制器之间:</h3><ul>
<li>模型与视图互不干涉, 由控制器来处理模型, 然后将模型传给视图显示.</li>
<li>模型决定视图的显示内容而不是控制器, 控制器负责修改模型和传递模型.</li>
<li>人机之间的交互由控制器完成</li>
<li>视图和模型互不干扰.  </li>
<li>作用: 便于代码的管理和阅读</li>
</ul>
<p> <img src="http://r5.loli.io/yIfmQ3.png" alt=""></p>
<hr>
<ul>
<li><p>用控制器来管理模型和视图, 通过修改模型来改变显示内容. 以tableView自定义cell为例:</p>
<ol>
<li><p>自定义一个cell (View)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写构造方法</span></span><br><span class="line">- (instancetype)initWithStyle:(<span class="built_in">UITableViewCellStyle</span>)style reuseIdentifier:(<span class="built_in">NSString</span> *)reuseIdentifier</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithStyle:style reuseIdentifier:reuseIdentifier];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *checkImg = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">    checkImg<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"check"</span>];</span><br><span class="line">    checkImg<span class="variable">.hidden</span> = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> addSubview:checkImg];</span><br><span class="line">    _checkImg = checkImg;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速创建一个cell</span></span><br><span class="line">+ (instancetype)cellWithTable:(<span class="built_in">UITableView</span> *)tableView</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *ID = <span class="string">@"cell"</span>;</span><br><span class="line">XVWineCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];</span><br><span class="line">    <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</span><br><span class="line">        cell = [[XVWineCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleSubtitle</span> reuseIdentifier:ID];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在控制器中实现数据源协议, 将自定义cell作为tableView的cell显示, 并将模型传递给cell (Controller)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">   - (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    XVWineCell *cell = [XVWineCell cellWithTable:tableView];</span><br><span class="line">    cell<span class="variable">.wine</span> = <span class="keyword">self</span><span class="variable">.wine</span>[indexPath<span class="variable">.row</span>];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在自定义cell类中重写模型属性的setter方法,给cell中的子控件赋值 (Model)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">   - (<span class="keyword">void</span>)setWine:(XVWine *)wine</span><br><span class="line">&#123;</span><br><span class="line">    _wine = wine;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:wine<span class="variable">.image</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.textLabel</span><span class="variable">.text</span> = wine<span class="variable">.name</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.detailTextLabel</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"￥%@"</span>, wine<span class="variable">.money</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.detailTextLabel</span><span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在控制器中修改模型数据刷新tableView, 这时会来到控制器的数据源方法将所有的cell重新赋予修改后的模型的值,cell的显示内容改变. (Controller)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 添加数据</span></span><br><span class="line">    - (<span class="keyword">void</span>)addWine</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 新建一个模型</span></span><br><span class="line">    XVWine *wine = [[XVWine alloc] init];</span><br><span class="line">    wine<span class="variable">.image</span> = <span class="string">@"newWine"</span>;</span><br><span class="line">    wine<span class="variable">.name</span> = <span class="string">@"新酒"</span>;</span><br><span class="line">    wine<span class="variable">.money</span> = <span class="string">@"999"</span>;</span><br><span class="line">    <span class="comment">// 将新模型添加进数组</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.wine</span> addObject:wine];</span><br><span class="line">    <span class="comment">// cell对应的模型数组的最后一位</span></span><br><span class="line">    <span class="built_in">NSIndexPath</span> *indexPath = [<span class="built_in">NSIndexPath</span> indexPathForRow:(<span class="keyword">self</span><span class="variable">.wine</span><span class="variable">.count</span> - <span class="number">1</span>) inSection:<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 刷新表格</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.tableView</span> insertRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class="built_in">UITableViewRowAnimationAutomatic</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TableView自定义header]]></title>
      <url>http://xionv.com/2014/01/09/demonayu/blog/03.TableView%E8%87%AA%E5%AE%9A%E4%B9%89header/</url>
      <content type="html"><![CDATA[<h3 id="自定义tableView的header,_利用转换坐标系来达到header的停留与跟随">自定义tableView的header, 利用转换坐标系来达到header的停留与跟随</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define toolbarH 44</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">UITableViewDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UITableView</span> *tableView;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIView</span> *toolbar;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建tableView</span></span><br><span class="line">    <span class="built_in">UITableView</span> *tableView = [[<span class="built_in">UITableView</span> alloc] init];</span><br><span class="line">    tableView<span class="variable">.frame</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span>;</span><br><span class="line">    <span class="comment">// 设置tableView的内边距的top位置为toolbar的高</span></span><br><span class="line">    tableView<span class="variable">.contentInset</span> = <span class="built_in">UIEdgeInsetsMake</span>(toolbarH, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    tableView<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:tableView];</span><br><span class="line">    _tableView = tableView;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建toolbar</span></span><br><span class="line">    <span class="built_in">CGFloat</span> toolbarW = <span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="built_in">UIView</span> *toolbar = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    toolbar<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, -toolbarH, toolbarW, toolbarH);</span><br><span class="line">    toolbar<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.tableView</span> addSubview:toolbar];</span><br><span class="line">    _toolbar = toolbar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - UIScrollViewDelegate</span></span><br><span class="line"><span class="comment">// 模拟tableView plain模式的header停留</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 存放新Y值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> newY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (toolbarH + scrollView<span class="variable">.contentOffset</span><span class="variable">.y</span> &gt; <span class="number">0</span>) &#123; <span class="comment">// 向上拖拽偏移量减少 - 转换坐标系</span></span><br><span class="line">        <span class="comment">// 转换坐标系</span></span><br><span class="line">        <span class="built_in">UIWindow</span> *window = [<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.windows</span><span class="variable">.lastObject</span>;</span><br><span class="line">        [window addSubview:<span class="keyword">self</span><span class="variable">.toolbar</span>];</span><br><span class="line">        newY = [<span class="keyword">self</span><span class="variable">.tableView</span> convertRect:<span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.bounds</span> toView:window]<span class="variable">.origin</span><span class="variable">.y</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 向下拖拽时偏移量增加 - toolBar跟随tableView</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.tableView</span> addSubview:<span class="keyword">self</span><span class="variable">.toolbar</span>];</span><br><span class="line">        newY = -toolbarH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新frame</span></span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.toolbar</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.origin</span><span class="variable">.y</span> = newY;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.toolbar</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UIScrollView实现定时滚动分页]]></title>
      <url>http://xionv.com/2013/11/23/demonayu/blog/02.UIScrollView%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5/</url>
      <content type="html"><![CDATA[<h2 id="通过使用UIScrollView控件来实现定时滚动分页">通过使用UIScrollView控件来实现定时滚动分页</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片个数</span></span><br><span class="line"><span class="preprocessor">#define imageViewCount 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">UIScrollViewDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIScrollView</span> *scrollView;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIPageControl</span> *pageContorl;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 设置scrollView的一些属性</span></span><br><span class="line">    <span class="comment">// scrollView的滚动范围</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span> * imageViewCount, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 禁用水平和垂直滑块</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.showsHorizontalScrollIndicator</span> = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.showsVerticalScrollIndicator</span> = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">// 禁用弹簧效果</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.bounces</span> = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">// 初始化图片分页</span></span><br><span class="line">    [<span class="keyword">self</span> setupPageView];</span><br><span class="line">    <span class="comment">// 初始化分页指示器</span></span><br><span class="line">    [<span class="keyword">self</span> setupPageControl];</span><br><span class="line">    <span class="comment">// 开始计时器</span></span><br><span class="line">    [<span class="keyword">self</span> startTiming];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置分页</span></span><br><span class="line">- (<span class="keyword">void</span>)setupPageView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGSize</span> scrollViewSize = <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.bounds</span><span class="variable">.size</span>;</span><br><span class="line">    <span class="comment">// 在scrollView中添加子控件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imageViewCount; i++) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"img_%02d"</span>, i + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">        imageView<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">        <span class="built_in">CGFloat</span> imageViewX = scrollViewSize<span class="variable">.width</span> * i;</span><br><span class="line">        <span class="built_in">CGFloat</span> imageViewY = <span class="number">0</span>;</span><br><span class="line">        imageView<span class="variable">.frame</span> = (<span class="built_in">CGRect</span>)&#123;&#123;imageViewX, imageViewY&#125;, scrollViewSize&#125;;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.scrollView</span> addSubview:imageView];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置分页指示器</span></span><br><span class="line">- (<span class="keyword">void</span>)setupPageControl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIPageControl</span> *pageContorl = [[<span class="built_in">UIPageControl</span> alloc] init];</span><br><span class="line">    <span class="comment">// 单页的时候隐藏</span></span><br><span class="line">    pageContorl<span class="variable">.hidesForSinglePage</span> = <span class="literal">YES</span>;</span><br><span class="line">    pageContorl<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line">    <span class="comment">// 注意: 在Xcode6以后 _currentPageImage 和 _pageImage这两个私有属性已经不可见了</span></span><br><span class="line">    <span class="comment">// 通过KVC设置指示器图片</span></span><br><span class="line">    [pageContorl setValue:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"current"</span>] forKeyPath:<span class="string">@"_currentPageImage"</span>];</span><br><span class="line">    [pageContorl setValue:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"other"</span>] forKeyPath:<span class="string">@"_pageImage"</span>];</span><br><span class="line">    <span class="comment">// 设置页码个数</span></span><br><span class="line">    pageContorl<span class="variable">.numberOfPages</span> = imageViewCount;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:pageContorl];</span><br><span class="line">    _pageContorl = pageContorl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始计时器</span></span><br><span class="line">- (<span class="keyword">void</span>)startTiming</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化定时器</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.timer</span> = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(pageChanged:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    <span class="comment">// 将计时添加进事件循环</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:<span class="keyword">self</span><span class="variable">.timer</span> forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止计时器</span></span><br><span class="line">- (<span class="keyword">void</span>)endTiming</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.timer</span> invalidate];</span><br><span class="line"><span class="comment">//    self.timer = nil; // 清空指针 - 这句可以不用写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 监听方法</span></span><br><span class="line"><span class="comment">// 定时器滚动页面</span></span><br><span class="line">- (<span class="keyword">void</span>)pageChanged:(<span class="built_in">NSTimer</span> *)timer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 根据当前页码数乘上scrollView的宽度来算出偏移量</span></span><br><span class="line">    <span class="built_in">CGFloat</span> x = ((<span class="keyword">self</span><span class="variable">.pageContorl</span><span class="variable">.currentPage</span> + <span class="number">1</span>) % imageViewCount) * <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="comment">// 这句是定时滚动页面的核心 ***</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.scrollView</span> setContentOffset:(<span class="built_in">CGPoint</span>)&#123;x,<span class="number">0</span>&#125; animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - UIScrollViewDelegate</span></span><br><span class="line"><span class="comment">// 监听scrollView的滚动</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// scrollView内偏移量 / scrollView的宽 = 当前页面 --- 四舍五入</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.pageContorl</span><span class="variable">.currentPage</span> = <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.contentOffset</span><span class="variable">.x</span> / <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span> + <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当拖拽scrollView时停止计时</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> endTiming];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当停止拖拽时开始计时</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> startTiming];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字典转模型]]></title>
      <url>http://xionv.com/2013/11/05/demonayu/blog/01.%E5%AD%97%E5%85%B8%E8%BD%AC%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="为什么要将字典转成模型?">为什么要将字典转成模型?</h2><ul>
<li>字典和模型都是用来存储数据的 .  </li>
<li>字典 : 通过字符串类型的key取值.编写这些key时,编译器不会有任何友善提示,需要手动敲写.手动敲写字符串key,容易写错,而且如果写错,编译器不会有任何警告和报错,容易造成设错数据或者取错数据,增加bug几率.</li>
<li>模型类 : 即用来存放数据的类,继承自NSObject.所谓模型,其实就是数据模型,专门用来存放数据的对象.模型设置数据和取出数据都是通过它的属性,属性名如果写错,编译器会马上报错,因此保证了数据的正确性,而且这种方式更加的贴近面向对象的思想,更加符合苹果官方推荐的MVC编程模式.</li>
</ul>
<h2 id="字典转模型的两种常用赋值方法">字典转模型的两种常用赋值方法</h2><ul>
<li>如果是要自己快速创建一个模型最好先提供一个方便创建模型的类工厂方法,当然也可以只提供一个类工厂方法,然后定义这个模型对外的成员属性接口用于外部对象访问这个模型存储的数据.</li>
</ul>
<h4 id="第一种_:_直接取出字典键值赋值给模型成员属性">第一种 : 直接取出字典键值赋值给模型成员属性</h4><ul>
<li>如果成员属性较少,或者这个模型将要接收不止一个字典,或者自定义对象有成员属性嵌套,则建议使用这种方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入一个字典将字典中的所有的键值取出来赋给模型的成员属性</span></span><br><span class="line">+ (instancetype)modelWithDict:(<span class="built_in">NSDictionary</span> *)dict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里的属性名称和字典的key可以不同名</span></span><br><span class="line">    <span class="comment">// 注意:在这里假如这个字典中没有"icon"这个key也没有关系,当有对象访问这个模型数据时不会报错.</span></span><br><span class="line">    Model *model = [[ShopsData alloc] init];</span><br><span class="line">    model<span class="variable">.name</span> = dict[<span class="string">@"name"</span>];</span><br><span class="line">    model<span class="variable">.icon</span> = dict[<span class="string">@"icon"</span>];</span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二种_:_利用KVC(KeyValueCoding)赋值">第二种 : 利用KVC(KeyValueCoding)赋值</h4><ul>
<li>如果字典有很多个key怎么破,当然我们可以像上面一样一个属性一个属性的赋值,只不过累一点嘛.那有没有捷径呢?有! 利用KVC来给属性赋值.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (instancetype)modelWithDict:(<span class="built_in">NSDictionary</span> *)dict</span><br><span class="line">&#123;</span><br><span class="line">    Model *model = [[ShopsData alloc] init];</span><br><span class="line">    <span class="comment">// 这种写法与上面代码的意思一样.只不过是通过KVC来实现赋值</span></span><br><span class="line">    [data setValue:dict[<span class="string">@"name"</span>]forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line">    [data setValue:dict[<span class="string">@"icon"</span>]forKeyPath:<span class="string">@"icon"</span>];</span><br><span class="line">    <span class="comment">// 或用这个方法一次性给模型所有的属性赋值</span></span><br><span class="line">    [data setValuesForKeysWithDictionary:dict];</span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>KVC赋值有一个注意点:<strong>那就是模型的属性名必须跟字典的key名一样,否则在取值的时候会报找不到这个键值的错.</strong></li>
</ul>
<h2 id="字典转模型的写法">字典转模型的写法</h2><ul>
<li>除了上面写法外,还可以进行重写构造方法来实现</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写构造方法进行赋值</span></span><br><span class="line">- (instancetype)initWithDict:(<span class="built_in">NSDictionary</span> *)dict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _name = dict[<span class="string">@"name"</span>];</span><br><span class="line">        _icon = dict[<span class="string">@"icon"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提供工厂方法快速创建对象</span></span><br><span class="line">+ (instancetype)modelWithDict:(<span class="built_in">NSDictionary</span> *)dict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithDict:dict];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果模型对外界的取值是固定的,那么我们还可以更进一步封装,直接在模型内部把外界的数据转好,调给其他对象使用.</li>
<li>比如说我们要调用一个plist文件中的数据</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将模型对象存进数组传出去</span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)models</span><br><span class="line">&#123;   <span class="comment">// 获取plist文件路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *file = [[<span class="built_in">NSBundle</span> mainBundle]pathForResource:<span class="string">@"model.plist"</span> ofType:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// 将plist文件里面的字典存进数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:file];</span><br><span class="line">    <span class="comment">// 创建一个临时数组用来存放模型</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *arrayM = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="comment">// 遍历数组,将数组里面的字典转成模型对象存进临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> array) &#123;</span><br><span class="line">        [arrayM addObject:[<span class="keyword">self</span> modelWithDict:dict]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回模型数组</span></span><br><span class="line">    <span class="keyword">return</span> arrayM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第二篇]]></title>
      <url>http://xionv.com/2013/08/29/demonayu/blog/README/</url>
      <content type="html"><![CDATA[<p>#Heeeeello Wooooorld!!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开篇]]></title>
      <url>http://xionv.com/2013/08/28/demonayu/blog/SUMMARY/</url>
      <content type="html"><![CDATA[<h1 id="My_Awesome_blog">My Awesome blog</h1><p>This file serves as your blog’s preface, a great place to describe your blog’s content and ideas.</p>
]]></content>
    </entry>
    
  
  
</search>
