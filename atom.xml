<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[XionVV Coding]]></title>
  <subtitle><![CDATA[好啦,好啦,我知道了!]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xionv.com/"/>
  <updated>2016-01-14T04:57:16.000Z</updated>
  <id>http://xionv.com/</id>
  
  <author>
    <name><![CDATA[XionVV]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[NSCache的介绍]]></title>
    <link href="http://xionv.com/2016/01/14/demonayu/blog/43.NSCache%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://xionv.com/2016/01/14/demonayu/blog/43.NSCache的介绍/</id>
    <published>2016-01-14T03:29:57.000Z</published>
    <updated>2016-01-14T04:57:16.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章介绍了如何使用NSCache来替代NSDictionary进行数据缓存.</p>
</blockquote>
<p><a href="http://www.15yan.com/topic/yi-dong-kai-fa-na-dian-shi/45toOUzFGlr/" target="_blank" rel="external">NSCache介绍</a></p>
<p>借此说一下SDWebImage这个框架中<code>cleanDisk</code>与<code>clearDisk</code>的区别:<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//clean:删除过期缓存(缓存周期为1周),计算当前缓存文件的总大小,比较设置的最大缓存,如果超出的话,那么就继续删除(按照缓存文件创建的顺序),直到小于最大缓存为止</span></span><br><span class="line">[[SDWebImageManager sharedManager]<span class="variable">.imageCache</span> cleanDisk];</span><br><span class="line"><span class="comment">//clear:简单粗暴,直接删除然后重新创建</span></span><br><span class="line">[[SDWebImageManager sharedManager]<span class="variable">.imageCache</span> clearDisk];</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这篇文章介绍了如何使用NSCache来替代NSDictionary进行数据缓存.</p>
</blockquote>
<p><a href="http://www.15yan.com/topic/yi-dong-kai-fa-na-dian-shi]]>
    </summary>
    
      <category term="iOS中级" scheme="http://xionv.com/tags/iOS%E4%B8%AD%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RunLoop础知识]]></title>
    <link href="http://xionv.com/2016/01/13/demonayu/blog/42.RunLoop%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://xionv.com/2016/01/13/demonayu/blog/42.RunLoop基础知识/</id>
    <published>2016-01-13T03:06:57.000Z</published>
    <updated>2016-01-18T15:05:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是RunLoop">什么是RunLoop</h2><ul>
<li>RunLoop: 运行循环, 顾名思义就是跑圈, 兜圈子的意思. 一个应用程序能够一直运行而不会退出就是基于这种机制.</li>
<li>基本作用:<ol>
<li>保持程序持续运行, 相当于一个死循环;</li>
<li>处理应用程序中的各种事件, 比如触摸事件, 定时器事件等;</li>
<li>它的作用机制是有就做事, 没事就待命休息, 节省资源;</li>
</ol>
</li>
<li>主RunLoop: 当程序一启动系统就会在main函数中调用<code>UIApplicationMain()</code>这个函数, 该函数会在程序的主线程中开启一个RunLoop一直保持程序的运行.</li>
<li>自动释放池什么时候创建和释放?<ol>
<li>第一次创建,是在RunLoop进入的时候创建,对应的状态 = kCRunLoopEntry</li>
<li>最后一释放,是在RunLoop时候,对应的状态 = kCFRuRunLoopExit</li>
<li>它创建和释放,每次睡觉的时候都会释放前自动释放池,然后再建一个新的.</li>
</ol>
</li>
<li>RunLoop对象 <ol>
<li>在iOS开发中有两套api访问RunLoop<ul>
<li>Foundation框架<code>NSRunLoop</code></li>
<li>Core Foundation框架<code>CFRunLoopRef</code></li>
</ul>
</li>
<li>这个两个框架中所代表RunLoop是等价的.</li>
<li>NSRunLoop基于<code>CFRunLoopRef</code>的一层OC封装.</li>
</ol>
</li>
<li>RunLoop与线程 <ol>
<li>每一个线程都有一个与之对应的RunLoop对象.</li>
<li>RunLoop生命周期与子线程息息相关,当子线程被销毁时,与之对应的RunLoop也会被销毁.</li>
<li>子线程的RunLoop要程序员手动开启.</li>
</ol>
</li>
<li><p>获取RunLoop对象:</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 获当前的RunLoop对象</span></span><br><span class="line"><span class="comment">// NSRunLoop</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *runLoop1 = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="comment">// CFRunLoopRef</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> runLoop2 = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="comment">// 2. 拿到当前应用程序的主RunLoop(主线程RunLoop)</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *mainRunLoopnR1 = [RunLoop<span class="built_in">NSR</span> mRunLoopainR];</span><br><span class="line"><span class="built_in">CFRunLoopRef</span> mainRunLoop = <span class="built_in">CFRunLoopGetMain</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>在子线程中如果不主动获取RunLoop的话,那么在子线程内部是不会主动创建RunLoop的.</li>
<li>在子线程中创建一个RunLoop对象不是通过<code>alloc init</code>方法创建,而是直接调用currentRunLoop方法,而且这个方法本身就是一个懒加载,所以在该线程中RunLoop对象只会被创建一次.</li>
<li>RunLoop对象是利用字典以当前的线程作为key来进行储存的.</li>
</ul>
</li>
</ul>
<h2 id="RunLoop相关类">RunLoop相关类</h2><ul>
<li>RunLoop的运行原理<br> <img src="http://r5.loli.io/AzUZFb.png" alt="RunLoop的运行原理图"></li>
<li>Core Foundation关于RunLoop的五个类<ul>
<li>CFRunLoopRef (RunLoop抽象类)</li>
<li>CFRunLoopModeRef (RunLoop的运行模式)</li>
<li>CFRunLoopSourceRef (RunLoop要处理的事件源)</li>
<li>CFRunLoopTimerRef (Timer事件)</li>
<li>CFRunLoopObserverRef (RunLoop的观察者/监听者)</li>
</ul>
</li>
<li>RunLoop和相关类之间的关系图<br> <img src="http://r6.loli.io/AnI3eu.png" alt="RunLoop和相关类之间的关系图"></li>
</ul>
<h3 id="RunLoop的运行模式">RunLoop的运行模式</h3><ul>
<li>每一个RunLoop运行必须要指定一个模式,而且必须要有source和timer,如果子线程的NSRunLoop没有设置source和timer,那么子线程的RunLoop会立刻关闭.</li>
<li>一个RunLoop可以有多个模式,一个模式可以有多个source\observer\timer.</li>
<li>如果需要切换mode,只能先退出当前RunLoop,再重新指定一个模式.</li>
<li>系统默认提供了5个模式:<ul>
<li>kCFRunLoopDefaultMode: App的默认Mode,通常主线程是在这个Mode下运行,与NSDefaultRunLoopMode等价;</li>
<li>UITrackingRunLoopMode: 界面跟踪Mode, 用于ScrollView追踪触摸滑动, 保证界面滑动时不受其他Mode影响;</li>
<li>UIInitializationRunLoopMode: 在刚启动App时第进入的第一个Mode, 启动完成后就不再使用;</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部Mode, 通常用不到;</li>
<li>kCFRunLoopCommonModes: 这是一个占位用的Mode,不是一种真正的Mode.</li>
</ul>
</li>
</ul>
<h3 id="CFRunLoopTimerRef_时间源">CFRunLoopTimerRef 时间源</h3><ul>
<li>CFRunLoopTimerRef: 它是基于时间的触发器约等于<code>NSTimer</code>, 说直点那就是时间到了就触发一个事件, 执行一个操作.</li>
<li>一个mode里面可以添加多个NSTimer,也就是说以后当创建NSTimer的时候,可以指定它是在什么模式下运行, NSTimer其实就是CFRunLoopTimerRef.</li>
<li><p>在主线程中使用定时器</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建定时器</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 2.1 把定时器添加到runLoop,选择默认运行模式(只有当runLoop处于默认模式时,定时器才工作)</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"><span class="comment">// 2.2 把定时器添加到runLoop,选择界面跟踪模式(只有当runLoop处于界面跟踪模式时,定时器才工作)</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">UITrackingRunLoopMode</span>];</span><br><span class="line"><span class="comment">// 2.3 把定时器添加被标记的RunLoop(意味着当前的定时器会被添加到所有被标记为Common Modes的运行模式下面)</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>在子线程中使用定时器</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建子线程RunLoop</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *currentRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="comment">//2.创建定时器对象,会把当前的定时器对象自动添加到runLoop,并设定为默认模式</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer =  [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">//3.子线程对应的runLoop需要手动开启</span></span><br><span class="line">[currentRunLoop run];</span><br></pre></td></tr></table></figure>
</li>
<li><p>GCD中的定时器</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1.创建GCD定时器对象</span></span><br><span class="line"> <span class="comment">// 第一个参数:source的类型DISPATCH_SOURCE_TYPE_TIMER 定时器</span></span><br><span class="line"> <span class="comment">// 第二个参数:描述信息 传递0</span></span><br><span class="line"> <span class="comment">// 第三个参数:详细的描述 传递0</span></span><br><span class="line"> <span class="comment">// 第四个参数:队列,决定定时器调用的方法在哪个线程执行</span></span><br><span class="line"> dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 2.设定时器(开始时间|间隔时间|精准度)</span></span><br><span class="line"> <span class="comment">// 第一个参数:imer 定时器对象</span></span><br><span class="line"> <span class="comment">// 第二个参数:开始计时的时间:DISPATCH_TIME_NOW --从现在开始</span></span><br><span class="line"> <span class="comment">// 第三个参数:间隔时间 2.0</span></span><br><span class="line"> <span class="comment">//第四个参数:精准度 如果要求对准确的话,传0(误差)</span></span><br><span class="line"> <span class="comment">// GCD时间单位:纳秒</span></span><br><span class="line"> dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 3.定时器要执行的操作</span></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"download ----%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 4.恢复 (启动执行)</span></span><br><span class="line"> dispatch_resume(timer);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// GCD定时器补充 - source的类型</span></span><br><span class="line"> <span class="comment">// DISPATCH_SOURCE_TYPE_TIMER         定时响应（定时器事件）</span></span><br><span class="line"> <span class="comment">// DIPATCH_SOURCE_TYPE_SIGNAL        接收到UNIX信号时响应</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// DISPATCH_SOURE_TYPE_READ          IO操作，如对文件的操作、socket操作的读响应</span></span><br><span class="line"> <span class="comment">// DISPATCH_SOURCE_TYPE_WRITE         IO操作，如对文件的操作、socket操作的写响应</span></span><br><span class="line"> <span class="comment">// DISPATCH_SOURCE_TYPE_VNODE         文件状态监听，文件被删除、移动、重命名</span></span><br><span class="line"> <span class="comment">// DISPATCH_SOURCE_TYPE_PROC          进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 下面两个都属于Mach相关事件响应</span></span><br><span class="line">     <span class="comment">// DISPATCH_SOURCE_TYPE_MACH_SEND</span></span><br><span class="line">     <span class="comment">// DISPATCH_SOURCE_TYPE_MACH_RECV</span></span><br><span class="line"> <span class="comment">// 下面两个都属于自定义的事件，并且也是有自己来触发</span></span><br><span class="line">     <span class="comment">// DISPATCH_SOURCE_TYPE_DATA_ADD</span></span><br><span class="line">     <span class="comment">// DISPATCH_SOURCE_TYPE_DATA_OR</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="CFRunLoopSourceRef_事件源">CFRunLoopSourceRef 事件源</h3><ul>
<li>事件源也就是输入源,可能包括用户输入设备(如点击button),网络链接(socket收到数据),定期或时间延迟事件(NSTimer),还有异步回调(NSURLConnection的异步请求).</li>
<li><p>有两种分类模式:</p>
<ul>
<li>一种是按照苹果官方文档进行划分<ul>
<li>Port-Based Sources</li>
<li>Custom Input Sources</li>
<li>Cocoa Perform Selector Sources</li>
</ul>
</li>
<li>一种是基于函数的调用栈来进行划分(source0和source1)<ul>
<li>Source1: 基于端口(port)的输入源(系统内部调用, 比如线程间通信). 它只包含了一个回调(函数指针), 并不能主动触发事件. 使用时你需要先调用CFRunLoopSourceSignal(source), 将这个Source标记为待处理, 然后手动调用CFRunLoopWakeUp(runloop) 来唤醒RunLoop, 让其处理这个事件.</li>
<li>Source0: 基于非端口的输入源 (主动触发, 比如用户的交互). 包含了一个mach_port和一个回调(函数指针), 被用于通过内核和其他线程相互发送消息. 这种Source能主动唤醒RunLoop的线程.</li>
</ul>
</li>
</ul>
</li>
<li><p>添加输入源<code>[performSelector:OnThread]</code>. Cocoa提供了可以在任一线程执行函数<code>[perform selector]</code>的输入源, 和基于端口的源不同的是, <code>[perform selector]</code>执行完后会自动清除出RunLoop. </p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送消息给主线程并且是否等待任务执行完成(下面一个方法是指定RunLoop模式)</span></span><br><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:  </span><br><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:modes:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息给指定的线程并且是否等待任务执行完成</span></span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:  </span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:modes:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息给主线程延迟调用方法(只能在主线程中执行)</span></span><br><span class="line">performSelector:withObject:afterDelay:</span><br><span class="line">performSelector:withObject:afterDelay:inModes:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消当前线程的消息发送</span></span><br><span class="line">cancelPreviousPerformRequestsWithTarget:  </span><br><span class="line">cancelPreviousPerformRequestsWithTarget:selector:object:</span><br></pre></td></tr></table></figure>
<ul>
<li>当调用NSObject的<code>performSelecter:afterDelay:</code>后, 实际上其内部会创建一个<code>Timer</code>并添加到当前线程的RunLoop中. 所以如果当前线程没有开启RunLoop, 这个方法则会失效. </li>
<li>当调用<code>performSelector:onThread:</code>时, 实际上其会创建一个<code>Timer</code>加到对应的线程去, 同样的如果对应线程没有开启RunLoop该方法也会失效.</li>
</ul>
</li>
</ul>
<h3 id="CFRunLoopObserverRef_观察者">CFRunLoopObserverRef 观察者</h3><ul>
<li>CFRunLoopObserverRef是观察者,能够监听RunLoop的状态改变</li>
<li>如何监听 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建观察者</span></span><br><span class="line"><span class="comment">// 第一个参数:分配空间</span></span><br><span class="line"><span class="comment">// 第二个参数:要监听的状态</span></span><br><span class="line"><span class="comment">// 第三个参数:YES 持续监听</span></span><br><span class="line"><span class="comment">// 第四个参数:和优先级相关 总是传递0</span></span><br><span class="line"><span class="comment">// 第五个参数:当发现runLoop状态改变的时候就会调用该block</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), k<span class="built_in">CFRunLoopAllActivities</span>, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopEntry</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"启动runLoop"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopBeforeTimers</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"即将处理定时器事件"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopBeforeSources</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"即将处理source事件"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopBeforeWaiting</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"即将休眠"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopAfterWaiting</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"刚从休眠中唤醒"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> k<span class="built_in">CFRunLoopExit</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"runLoop退出"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.给runLoop添加观察者</span></span><br><span class="line"><span class="comment">// 第一个参数:runLoop对象</span></span><br><span class="line"><span class="comment">// 第二个参数:观察者对象</span></span><br><span class="line"><span class="comment">// 第三个参数:运行模式(要监听那种模式下状态的改变)</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, k<span class="built_in">CFRunLoopDefaultMode</span>);</span><br><span class="line"><span class="comment">// 3.开启定时器</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(demo) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="RunLoop运行逻辑详情">RunLoop运行逻辑详情</h2><p><img src="http://r5.loli.io/ZrimYv.png" alt="示意图"><br><img src="http://r6.loli.io/NNn26b.png" alt="逻辑详情"></p>
<h2 id="补充">补充</h2><ul>
<li><p>从上图可以看出:</p>
<ul>
<li>如果是事件到达,消息会被传递给相应的处理程序来处理,runLoop处理完当次事件后,runLoop会退出,而不管之前预定的时间到了没有.你可以重新启动runLoop来等待下一事件.</li>
<li>如果线程中有需要处理的源,但是响应的事件没有到来的时候,线程就会休眠等待相应事件的发生.这就是为什么runLoop可以做到让线程有工作的时候忙于工作,而没工作的时候处于休眠状态.</li>
</ul>
</li>
<li><p>什么时候使用runLoop:</p>
<ul>
<li>仅当在为你的程序创建辅助线程的时候,你才需要显式运行一个run loop.RunLoop是程序主线程基础设施的关键部分.所以,Cocoa和Carbon程序提供了代码运行主程序的循环并自动启动runLoop.iOS程序中UIApplication的run方法作为程序启动步骤的一部分,它在程序正常启动的时候就会启动程序的主循环.类似的,RunApplicationEventLoop函数为Carbon程序启动主循环.如果你使用xcode提供的模板创建你的程序,那你永远不需要自己去显式的调用这些例程.</li>
<li>对于辅助线程,你需要判断一个runLoop是否是必须的.如果是必须的,那么你要自己配置并启动它.你不需要在任何情况下都去启动一个线程的runLoop.比如.你使用线程来处理一个预先定义的长时间运行的任务时,你应该避免启动runLoop.RunLoop在你要和线程有更多的交互时才需要,比如以下情况:<ul>
<li>使用端口或自定义输入源来和其他线程通信</li>
<li>使用线程的定时器</li>
<li>Cocoa中使用任何performSelector…的方法</li>
<li>使线程周期性工作.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>参考: <a href="http://www.cocoachina.com/ios/20150601/11970.html" target="_blank" rel="external">深入理解RunLoop</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="什么是RunLoop">什么是RunLoop</h2><ul>
<li>RunLoop: 运行循环, 顾名思义就是跑圈, 兜圈子的意思. 一个应用程序能够一直运行而不会退出就是基于这种机制.</li>
<li>基本作用:<ol>
<li>保持程序持续运行, 相当于]]>
    </summary>
    
      <category term="iOS进阶" scheme="http://xionv.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TableVIew单元格多图下载]]></title>
    <link href="http://xionv.com/2016/01/12/demonayu/blog/41.TableVIew%E5%8D%95%E5%85%83%E6%A0%BC%E5%A4%9A%E5%9B%BE%E4%B8%8B%E8%BD%BD/"/>
    <id>http://xionv.com/2016/01/12/demonayu/blog/41.TableVIew单元格多图下载/</id>
    <published>2016-01-12T03:06:57.000Z</published>
    <updated>2016-01-12T03:44:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="考虑因素">考虑因素</h2><ul>
<li>单元格的多图下载要考虑到:<ul>
<li>必须要在子线程进行下载</li>
<li>防止重复下载</li>
<li>数据缓存</li>
</ul>
</li>
</ul>
<h2 id="实现思路">实现思路</h2><p><img src="http://r5.loli.io/bIRVfm.png" alt=""></p>
<h2 id="实现方法">实现方法</h2><ul>
<li><p>将cache路径写成宏</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#define cachePath(url) [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).lastObject stringByAppendingPathComponent:[url lastPathComponent]]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>cellForRowAtIndexPath:</code>方法中判断图片是否存在</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取出对应的模型</span></span><br><span class="line">XVModel *item = <span class="keyword">self</span><span class="variable">.items</span>[indexPath<span class="variable">.row</span>];</span><br><span class="line">cell<span class="variable">.textLabel</span><span class="variable">.text</span> = item<span class="variable">.title</span>;</span><br><span class="line">cell<span class="variable">.detailTextLabel</span><span class="variable">.text</span> = item<span class="variable">.subTitle</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1&gt; 先从内存缓存中取</span></span><br><span class="line"><span class="comment">// 根据url取出图片</span></span><br><span class="line"><span class="built_in">UIImage</span> *memoryImage = <span class="keyword">self</span><span class="variable">.images</span>[item<span class="variable">.icon</span>];</span><br><span class="line"><span class="keyword">if</span> (memoryImage) &#123; <span class="comment">// 当内存中有图片时</span></span><br><span class="line">    cell<span class="variable">.imageView</span><span class="variable">.image</span> = memoryImage;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 当内存中没有图片时</span></span><br><span class="line">    <span class="comment">// 2&gt; 再从沙盒中取 - 每一张图片都是一个文件 文件名为url名</span></span><br><span class="line">    <span class="built_in">UIImage</span> *diskImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:cachePath(item<span class="variable">.icon</span>)];</span><br><span class="line">    <span class="keyword">if</span> (diskImage) &#123; <span class="comment">// 沙盒中有图片时</span></span><br><span class="line">        cell<span class="variable">.imageView</span><span class="variable">.image</span> = diskImage;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当沙盒中没有对应的图片时</span></span><br><span class="line">        <span class="comment">// 设置占位图片</span></span><br><span class="line">        cell<span class="variable">.imageView</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder3"</span>];</span><br><span class="line">        <span class="comment">// 3&gt; 从网络上下载</span></span><br><span class="line">        [<span class="keyword">self</span> downloadImageWithUrlStr:item<span class="variable">.icon</span> indexPath:indexPath];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现异步下载</p>
<ul>
<li>为了保证一张图片只下载一次,需要判断当前url是否有下载任务,如果没有才需要创建下载任务.</li>
<li>如何才能判断当前的url是否有下载任务呢?利用字典把url作为key绑定下载操作来判断.<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)downloadImageWithUrlStr:(<span class="built_in">NSString</span> *)urlStr indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出字典中url对应的下载任务</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *operation = <span class="keyword">self</span><span class="variable">.operations</span>[urlStr];</span><br><span class="line">    <span class="comment">// 如果当前url有下载任务 - 就不创建任务</span></span><br><span class="line">    <span class="keyword">if</span> (!operation) &#123; <span class="comment">// 没有下载任务</span></span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">        <span class="comment">// 创建异步任务 - 将下载图片的操作放入到子线程中 - (解决异步下载的问题)</span></span><br><span class="line">        operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">            <span class="comment">// 将字符串转成url</span></span><br><span class="line">            <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlStr];</span><br><span class="line">            <span class="comment">// 从url获取数据</span></span><br><span class="line">            <span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">            <span class="comment">// 将二进制数据转成图片</span></span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 返回主线程刷新数据</span></span><br><span class="line">            [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">                <span class="comment">// 如果下载成功将图片存入字典 - 字典不能存空</span></span><br><span class="line">                <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                    <span class="comment">// 1)将下载好的图片添加进图片字典中 url为key</span></span><br><span class="line">                    [weakself<span class="variable">.images</span> setObject:image forKey:urlStr];</span><br><span class="line">                    <span class="comment">// 刷新表格</span></span><br><span class="line">                    [weakself<span class="variable">.tableView</span> reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class="built_in">UITableViewRowAnimationFade</span>];</span><br><span class="line">                    <span class="comment">// 2)将image写入沙盒</span></span><br><span class="line">                    <span class="comment">// 将图片转成二进制数据</span></span><br><span class="line">                    <span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line">                    <span class="comment">// 写入沙盒</span></span><br><span class="line">                    [data writeToFile:cachePath(urlStr) atomically:<span class="literal">YES</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 下载完毕后将任务从字典中移除 - 如果下载失败将任务移除后还有机会下载,如果不移除,这个key就会一直存在永远也不能再次下载了</span></span><br><span class="line">                <span class="comment">// 在主线程中移除是为了保证下载操作已经执行完毕</span></span><br><span class="line">                [weakself<span class="variable">.operations</span> removeObjectForKey:urlStr];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将任务添加到队列</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.queue</span> addOperation:operation];</span><br><span class="line">    <span class="comment">// 将下载任务写入到字典里(解决重复下载问题)</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.operations</span> setObject:operation forKey:urlStr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="考虑因素">考虑因素</h2><ul>
<li>单元格的多图下载要考虑到:<ul>
<li>必须要在子线程进行下载</li>
<li>防止重复下载</li>
<li>数据缓存</li>
</ul>
</li>
</ul>
<h2 id="实现思路">实现思路</h]]>
    </summary>
    
      <category term="iOS中级" scheme="http://xionv.com/tags/iOS%E4%B8%AD%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIButton调换文字与图片位置的两种方法]]></title>
    <link href="http://xionv.com/2016/01/09/demonayu/blog/35.UIButton%E8%B0%83%E6%8D%A2%E6%96%87%E5%AD%97%E4%B8%8E%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://xionv.com/2016/01/09/demonayu/blog/35.UIButton调换文字与图片位置的两种方法/</id>
    <published>2016-01-09T02:12:57.000Z</published>
    <updated>2016-01-11T08:28:52.000Z</updated>
    <content type="html"><![CDATA[<p>假设自定义一个UIButton控件, 然后在button里面初始化了一个title和一个image:<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置button文字</span></span><br><span class="line">        [<span class="keyword">self</span> setTitle:<span class="string">@"title"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        <span class="comment">// 设置button图片</span></span><br><span class="line">        [<span class="keyword">self</span> setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        <span class="comment">// 设置文字大小</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.titleLabel</span><span class="variable">.font</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">17</span>];</span><br><span class="line">        <span class="comment">// 设置图片居中</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.contentMode</span> = <span class="built_in">UIViewContentModeCenter</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="第一种_-_重写layoutSubviews方法来实现">第一种 - 重写<code>layoutSubviews</code>方法来实现</h3><ol>
<li><p>重写<code>layoutSubviews</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    <span class="comment">// 修改titleButton里面子控件的位置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.frame</span><span class="variable">.origin</span><span class="variable">.x</span> &lt; <span class="keyword">self</span><span class="variable">.titleLabel</span><span class="variable">.frame</span><span class="variable">.origin</span><span class="variable">.x</span>) &#123; </span><br><span class="line">        <span class="comment">// 1. 取出title和image的frame</span></span><br><span class="line">        <span class="built_in">CGRect</span> titleFrame = <span class="keyword">self</span><span class="variable">.titleLabel</span><span class="variable">.frame</span>;</span><br><span class="line">        <span class="built_in">CGRect</span> imageFrame = <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.frame</span>;</span><br><span class="line">        <span class="comment">// 2. 调整title和imageView的x值</span></span><br><span class="line">        titleFrame<span class="variable">.origin</span><span class="variable">.x</span> = imageFrame<span class="variable">.origin</span><span class="variable">.x</span>;</span><br><span class="line">        imageFrame<span class="variable">.origin</span><span class="variable">.x</span> = <span class="built_in">CGRectGetMaxX</span>(titleFrame) + <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 3. 重新赋值</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.titleLabel</span><span class="variable">.frame</span> = titleFrame;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.frame</span> = imageFrame;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写<code>setImage: forState:</code>和<code>setTitle: forState:</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 重写父类setImage方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setImage:(<span class="built_in">UIImage</span> *)image forState:(<span class="built_in">UIControlState</span>)state</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setImage:image forState:state];</span><br><span class="line">    <span class="comment">// 自动计算尺寸</span></span><br><span class="line">    [<span class="keyword">self</span> sizeToFit];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 重写父类setTitle方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setTitle:(<span class="built_in">NSString</span> *)title forState:(<span class="built_in">UIControlState</span>)state</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setTitle:title forState:state];</span><br><span class="line">    <span class="comment">// 自动计算尺寸</span></span><br><span class="line">    [<span class="keyword">self</span> sizeToFit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第二种_-_重写titleRectForContentRect:和imageRectForContentRect:方法来实现">第二种 - 重写<code>titleRectForContentRect:</code>和<code>imageRectForContentRect:</code>方法来实现</h3><ol>
<li><p>重写<code>titleRectForContentRect:</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 返回文字的位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)titleRectForContentRect:(<span class="built_in">CGRect</span>)contentRect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> titleX = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> titleY = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> titleW = [<span class="keyword">self</span><span class="variable">.currentTitle</span> boundingRectWithSize:<span class="built_in">CGSizeMake</span>(MAXFLOAT, MAXFLOAT)</span><br><span class="line">                                                     options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span></span><br><span class="line">                                                  attributes:@&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">17</span>]&#125;</span><br><span class="line">                                                     context:<span class="literal">nil</span>]<span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> titleH = contentRect<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(titleX, titleY, titleW, titleH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写<code>imageRectForContentRect:</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 返回图片位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)imageRectForContentRect:(<span class="built_in">CGRect</span>)contentRect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageW = <span class="number">16</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageH = contentRect<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageX = contentRect<span class="variable">.size</span><span class="variable">.width</span> - imageW;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageY = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(imageX, imageY, imageW, imageH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设自定义一个UIButton控件, 然后在button里面初始化了一个title和一个image:<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">]]>
    </summary>
    
      <category term="iOS中级" scheme="http://xionv.com/tags/iOS%E4%B8%AD%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用运行时特性获取系统类的私有成员属性]]></title>
    <link href="http://xionv.com/2016/01/08/demonayu/blog/36.%E5%88%A9%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%89%B9%E6%80%A7%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"/>
    <id>http://xionv.com/2016/01/08/demonayu/blog/36.利用运行时特性获取系统类的私有成员变量/</id>
    <published>2016-01-08T03:00:57.000Z</published>
    <updated>2016-01-11T08:28:52.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>在iOS7以后苹果添加了一个边缘滑动返回的手势操作,我们通过修改这个手势操作来说明如何利用系统的私有成员属性来达到在项目中的要求.</p>
</blockquote>
<ul>
<li><p><code>interactivePopGestureRecognizer</code>这个api功能就是在NavigationController堆栈内的UIViewController可以支持右滑手势,轻轻在屏幕左边一滑,屏幕就会返回.<br>但是, 1.这个功能在自定义返回按钮后会失效; 2.它的作用范围在手机屏幕左侧边缘,如果要求全屏接受这个事件就需要自定义这个功能了.</p>
</li>
<li><p>通过打印<code>interactivePopGestureRecognizer</code>得知这个功能是通过<code>UIScreenEdgePanGestureRecognizer</code>这个手势来实现的.如果是手势就一定有<code>target</code>和<code>action</code>这两个成员属性,我们只要拿到<code>target</code>的真实类型.然后通过KVC就能”借用”系统实现方式来达到以上两个要求.</p>
</li>
<li><p>利用运行时获取所有的成员变量</p>
<ol>
<li><p>导入运行时头文件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用runtime函数获取获取类中的所有成员属性</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来接收数组元素个数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outcount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// UIGestureRecognizer是interactivePopGestureRecognizer的类型</span></span><br><span class="line">Ivar *ivars = class_copyIvarList([<span class="built_in">UIGestureRecognizer</span> class], &amp;outcount);</span><br><span class="line"><span class="comment">// Ivar：成员属性的意思;</span></span><br><span class="line"><span class="comment">// 第一个参数:表示获取哪个类中的成员属性;</span></span><br><span class="line"><span class="comment">// 第二个参数:表示这个类有多少成员属性,传入一个Int变量地址,会自动给这个变量赋值;</span></span><br><span class="line"><span class="comment">// 返回值Ivar*:指的是一个ivar数组,会把所有成员属性放在一个数组中,通过返回的数组就能全部获取到;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有的成员属性名</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历ivars获取目标类中每一个成员属性名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outcount; i++) &#123;</span><br><span class="line">    <span class="comment">// 打印所有的成员属性名</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, @(ivar_getName(ivars[i])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果: 第一个就是我们要拿到的成员属性.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_targets</span><br><span class="line">_delayedTouches</span><br><span class="line">_delayedPresses</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过KVC拿到其关键作用的<code>target</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿到打印结果,通过KVC拿到那个target</span></span><br><span class="line"><span class="built_in">NSArray</span> *targets = [<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span> valueForKeyPath:<span class="string">@"_targets"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, targets);</span><br><span class="line"><span class="keyword">id</span> target = [targets[<span class="number">0</span>] valueForKeyPath:<span class="string">@"target"</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个pan手势</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handleNavigationTransition:这个方法是通过打印结果得知系统内部会调用的方法,不用我们去实现.</span></span><br><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:target action:<span class="keyword">@selector</span>(handleNavigationTransition:)];</span><br><span class="line">pan<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addGestureRecognizer:pan];</span><br></pre></td></tr></table></figure>
</li>
<li><p>在根控制器禁用pan手势</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.childViewControllers</span><span class="variable">.count</span> &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>至此我们就已经修改完成了,是不是很暴力很直接!当然我本人是不支持这种方法的:1.它破坏了苹果的封装性.2它仍然有局限性,因为是利用系统的方法,如果有其他自定义要求不便于修改.</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>在iOS7以后苹果添加了一个边缘滑动返回的手势操作,我们通过修改这个手势操作来说明如何利用系统的私有成员属性来达到在项目中的要求.</p>
</blockquote>
<ul>
<li><p><code>interactivePopGestureR]]>
    </summary>
    
      <category term="iOS进阶" scheme="http://xionv.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[封装NavigationController基类]]></title>
    <link href="http://xionv.com/2016/01/07/demonayu/blog/37.%E5%B0%81%E8%A3%85NavigationController%E5%9F%BA%E7%B1%BB/"/>
    <id>http://xionv.com/2016/01/07/demonayu/blog/37.封装NavigationController基类/</id>
    <published>2016-01-07T04:47:57.000Z</published>
    <updated>2016-01-11T08:28:52.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>目前绝大多数应用的各个子控制器的NavigationBar都是是统一风格的,封装Nav一劳永逸.</p>
</blockquote>
<ul>
<li><p>第一步</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 在第一次使用这个类的时候初始化成员属性</span></span><br><span class="line"> + (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 获取所有导航控制器的bar实例</span></span><br><span class="line">    <span class="built_in">UINavigationBar</span> *navbar = [<span class="built_in">UINavigationBar</span> appearance];</span><br><span class="line">    <span class="comment">// 1.1 设置导航条字体</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    dict[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">17</span>];</span><br><span class="line">    [navbar setTitleTextAttributes:dict];</span><br><span class="line">    <span class="comment">// 1.2 设置导航条背景图片</span></span><br><span class="line">    [navbar setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"navigationbar_background_landscape"</span>] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">    <span class="comment">// 1.3 设置导航栏分割线为透明</span></span><br><span class="line">    [navbar setShadowImage:[[<span class="built_in">UIImage</span> alloc] init]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 获取所有导航控制器的item实例</span></span><br><span class="line">    <span class="built_in">UIBarButtonItem</span> *barBtn = [<span class="built_in">UIBarButtonItem</span> appearance];</span><br><span class="line">    <span class="comment">// 2.1 设置barButton的文字普通状态下的属性</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *barBtnAttributesN = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    barBtnAttributesN[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">    barBtnAttributesN[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">        <span class="comment">// 设置普通状态</span></span><br><span class="line">    [barBtn setTitleTextAttributes:barBtnAttributesN forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    <span class="comment">// 2.2 设置barButton的文字不可用状态下的属性</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *barBtnAttributesS = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    barBtnAttributesS[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    barBtnAttributesS[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">        <span class="comment">// 设置不可用状态</span></span><br><span class="line">    [barBtn setTitleTextAttributes:barBtnAttributesS forState:<span class="built_in">UIControlStateDisabled</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 添加一个边缘滑动手势</span></span><br><span class="line">    <span class="built_in">UIScreenEdgePanGestureRecognizer</span> *edgePan = [[<span class="built_in">UIScreenEdgePanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(edgePan:)];</span><br><span class="line">    edgePan<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 方向为左划</span></span><br><span class="line">    edgePan<span class="variable">.edges</span> = <span class="built_in">UIRectEdgeLeft</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addGestureRecognizer:edgePan];</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#pragma mark - 监听手势方法</span></span><br><span class="line"> - (<span class="keyword">void</span>)edgePan:(<span class="built_in">UIScreenEdgePanGestureRecognizer</span> *)edgePan</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三步</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写push方法</span></span><br><span class="line"> - (<span class="keyword">void</span>)pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当不是根控制器时</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.viewControllers</span><span class="variable">.count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 隐藏tabBar</span></span><br><span class="line">        viewController<span class="variable">.hidesBottomBarWhenPushed</span> = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">// 自定义导航栏左边按钮</span></span><br><span class="line">        <span class="built_in">UIButton</span> *leftBtn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">        [leftBtn setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"navigationbar_back"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        [leftBtn setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"navigationbar_back_highlighted"</span>] forState:<span class="built_in">UIControlStateHighlighted</span>];</span><br><span class="line">        [leftBtn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(backPress) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">        [leftBtn sizeToFit];</span><br><span class="line">        viewController<span class="variable">.navigationItem</span><span class="variable">.leftBarButtonItem</span> = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithCustomView:leftBtn];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置完毕后调用父类的push方法</span></span><br><span class="line">    [<span class="keyword">super</span> pushViewController:viewController animated:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> - (<span class="keyword">void</span>)backPress</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四步</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - UIGestureRecognizerDelegate</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不允许在根控制器使用返回手势</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.childViewControllers</span><span class="variable">.count</span> &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>目前绝大多数应用的各个子控制器的NavigationBar都是是统一风格的,封装Nav一劳永逸.</p>
</blockquote>
<ul>
<li><p>第一步</p>
<figure class="highlight objc"><table]]>
    </summary>
    
      <category term="iOS中级" scheme="http://xionv.com/tags/iOS%E4%B8%AD%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[新特性界面的两种搭建方法]]></title>
    <link href="http://xionv.com/2016/01/06/demonayu/blog/38.%E6%96%B0%E7%89%B9%E6%80%A7%E7%95%8C%E9%9D%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/"/>
    <id>http://xionv.com/2016/01/06/demonayu/blog/38.新特性界面的两种搭建方法/</id>
    <published>2016-01-06T05:43:57.000Z</published>
    <updated>2016-01-11T08:28:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="使用UIScrollView搭建">使用UIScrollView搭建</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"NewFeaturesViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"TabBarViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define kImageCount 4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NewFeaturesViewController</span>() &lt;<span class="title">UIScrollViewDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIScrollView</span> *scrollView;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIPageControl</span> *pageControl;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NewFeaturesViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载scrollView</span></span><br><span class="line">- (<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_scrollView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">UIScrollView</span> *scrollView = [[<span class="built_in">UIScrollView</span> alloc] init];</span><br><span class="line">        _scrollView = scrollView;</span><br><span class="line">        scrollView<span class="variable">.frame</span> = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>;</span><br><span class="line">        <span class="comment">// 取消回弹</span></span><br><span class="line">        scrollView<span class="variable">.bounces</span> = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">// 允许翻页</span></span><br><span class="line">        scrollView<span class="variable">.pagingEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">// 隐藏水平滚动条</span></span><br><span class="line">        scrollView<span class="variable">.showsHorizontalScrollIndicator</span> = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">// 设置滚动范围</span></span><br><span class="line">        scrollView<span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(kImageCount * <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置控制器为代理</span></span><br><span class="line">        scrollView<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">        <span class="comment">// 控制器View添加scrollView</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.view</span> addSubview:scrollView];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _scrollView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载pageControl</span></span><br><span class="line">- (<span class="built_in">UIPageControl</span> *)pageControl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_pageControl == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">UIPageControl</span> *pageControl = [[<span class="built_in">UIPageControl</span> alloc] init];</span><br><span class="line">        _pageControl = pageControl;</span><br><span class="line">        <span class="comment">// pageControl小圆点数量</span></span><br><span class="line">        pageControl<span class="variable">.numberOfPages</span> = kImageCount;</span><br><span class="line">        <span class="comment">/* pageControl比较特殊，可以不用设置宽高也能显示，因为小圆点为它的子控件, 但是不设置宽高就不能交互 */</span></span><br><span class="line">        <span class="comment">// 设置pageControl的位置</span></span><br><span class="line">        pageControl<span class="variable">.centerX</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span><span class="variable">.x</span>;</span><br><span class="line">        pageControl<span class="variable">.centerY</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span><span class="variable">.y</span> + <span class="number">250</span>;</span><br><span class="line">        <span class="comment">// 小圆点默认颜色</span></span><br><span class="line">        pageControl<span class="variable">.pageIndicatorTintColor</span> = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">        <span class="comment">// 小圆点选中颜色</span></span><br><span class="line">        pageControl<span class="variable">.currentPageIndicatorTintColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">        <span class="comment">// 控制器View添加pageControl</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.view</span> addSubview:pageControl];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _pageControl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kImageCount; i++) &#123;</span><br><span class="line">        <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.bounds</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"new_feature_%d"</span>, i + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">        imageView<span class="variable">.image</span> = image;</span><br><span class="line">        <span class="comment">// 设置性特性说明的x值</span></span><br><span class="line">        imageView<span class="variable">.x</span> = <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span> * i;</span><br><span class="line">        <span class="comment">// 添加新特性说明</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.scrollView</span> addSubview:imageView];</span><br><span class="line">        <span class="comment">// 当滑到最后一页时</span></span><br><span class="line">        <span class="keyword">if</span> (i == kImageCount - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置最后一页的内容</span></span><br><span class="line">            [<span class="keyword">self</span> setupLastImageView:imageView];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pageControl默认选中第一个原点</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.pageControl</span><span class="variable">.currentPage</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  设置最后一张图片</span><br><span class="line"> *</span><br><span class="line"> *  @param imageView 轮播器最后一张图片</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setupLastImageView:(<span class="built_in">UIImageView</span> *)imageView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建分享按钮</span></span><br><span class="line">    <span class="built_in">UIButton</span> *buttonShare = [[<span class="built_in">UIButton</span> alloc] init];</span><br><span class="line">    [buttonShare setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"new_feature_share_false"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [buttonShare setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"new_feature_share_true"</span>] forState:<span class="built_in">UIControlStateSelected</span>];</span><br><span class="line">    [buttonShare setTitle:<span class="string">@"分享给大家"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [buttonShare setTitleColor:[<span class="built_in">UIColor</span> grayColor] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    buttonShare<span class="variable">.titleLabel</span><span class="variable">.font</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">    <span class="comment">// 设置内边距 EdgeInsets理解为自切</span></span><br><span class="line">    buttonShare<span class="variable">.titleEdgeInsets</span> = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    buttonShare<span class="variable">.imageEdgeInsets</span> = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    buttonShare<span class="variable">.size</span> = <span class="built_in">CGSizeMake</span>(<span class="number">150</span>, <span class="number">30</span>);</span><br><span class="line">    buttonShare<span class="variable">.centerX</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centerX</span>;</span><br><span class="line">    buttonShare<span class="variable">.centerY</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centerY</span> * <span class="number">1.35</span>;</span><br><span class="line">    [buttonShare addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(clickShare:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建开启按钮</span></span><br><span class="line">    <span class="built_in">UIButton</span> *buttonOpen = [[<span class="built_in">UIButton</span> alloc] init];</span><br><span class="line">    [buttonOpen setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"new_feature_finish_button"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [buttonOpen setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"new_feature_finish_button_highlighted"</span>] forState:<span class="built_in">UIControlStateHighlighted</span>];</span><br><span class="line">    [buttonOpen setTitle:<span class="string">@"立即体验"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    buttonOpen<span class="variable">.size</span> = buttonOpen<span class="variable">.currentBackgroundImage</span><span class="variable">.size</span>;</span><br><span class="line">    buttonOpen<span class="variable">.centerX</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centerX</span>;</span><br><span class="line">    buttonOpen<span class="variable">.centerY</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centerY</span> * <span class="number">1.5</span>;</span><br><span class="line">    [buttonOpen addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(clickOpen) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    <span class="comment">// 设置imageView可交互</span></span><br><span class="line">    imageView<span class="variable">.userInteractionEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">    [imageView addSubview:buttonOpen];</span><br><span class="line">    [imageView addSubview:buttonShare];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)clickOpen</span><br><span class="line">&#123;</span><br><span class="line">    TabBarViewController *tabBarVC = [[TabBarViewController alloc] init];</span><br><span class="line">    <span class="comment">// 将跟控制器改为tabBarController，并销毁当前控制器</span></span><br><span class="line">    [<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.keyWindow</span><span class="variable">.rootViewController</span> = tabBarVC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)clickShare:(<span class="built_in">UIButton</span> *)button</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 状态取反</span></span><br><span class="line">    button<span class="variable">.selected</span> = !button<span class="variable">.isSelected</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当scrollView改变的时候，改变pageControl的currentPage</span></span><br><span class="line">    <span class="keyword">double</span> page = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span> / scrollView<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="comment">// (int)(page + 0.5)四舍五入法 准确定位page的圆点</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.pageControl</span><span class="variable">.currentPage</span> = (<span class="keyword">int</span>)(page + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="使用UICollectionView搭建">使用UICollectionView搭建</h2><p><strong>第一步:设置控制器的内容</strong><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"XVNewFeaturesController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"XVCollectionViewCell.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define kImagesCount 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XVNewFeaturesController</span> () &lt;<span class="title">UICollectionViewDataSource</span>&gt;</span></span><br><span class="line"><span class="comment">// 图片数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *images;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XVNewFeaturesController</span></span></span><br><span class="line"><span class="comment">// 懒加载图片数组</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)images</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_images == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 将图片存入数组</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *arrayM = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; kImagesCount; i++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"newFeatureImage%d"</span>, i];</span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">            [arrayM addObject:image];</span><br><span class="line">        &#125;</span><br><span class="line">        _images = arrayM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _images;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写构造方法在创建控制器的同时就设定好布局方式</span></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.设置collectionView的布局 - 布局设置是必须的</span></span><br><span class="line">    <span class="built_in">UICollectionViewFlowLayout</span> *layout = [[<span class="built_in">UICollectionViewFlowLayout</span> alloc] init];</span><br><span class="line">    <span class="comment">// 2.设置布局的最小行间距 - 注意:默认是有间距的,需要手动设置为0</span></span><br><span class="line">    layout<span class="variable">.minimumLineSpacing</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3.设置cell的大小</span></span><br><span class="line">    layout<span class="variable">.itemSize</span> = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span>;</span><br><span class="line">    <span class="comment">// 4.滚动方向</span></span><br><span class="line">    layout<span class="variable">.scrollDirection</span> = <span class="built_in">UICollectionViewScrollDirectionHorizontal</span>;</span><br><span class="line">    <span class="comment">// 5.完成初始化后调用父类方法</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> initWithCollectionViewLayout:layout];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化CollectionView设置 */</span></span><br><span class="line">    <span class="comment">// collectionView默认的背景色是黑色</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    <span class="comment">// 设置分页</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.pagingEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">// 取消滑块</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.showsHorizontalScrollIndicator</span> = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">// 禁用反弹</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.bounces</span> = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - UICollectionViewDataSource 数据源方法</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView numberOfItemsInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.images</span><span class="variable">.count</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用自定义cell</span></span><br><span class="line">    XVCollectionViewCell *cell = [XVCollectionViewCell cellWithCollectionView:collectionView forIndexPath:indexPath];</span><br><span class="line">    cell<span class="variable">.image</span> = <span class="keyword">self</span><span class="variable">.images</span>[indexPath<span class="variable">.row</span>];</span><br><span class="line">    <span class="comment">// 将当前的index和images总数传到cell中来判断是否是最后一页</span></span><br><span class="line">    [cell getIndexPath:indexPath andImagesCount:<span class="keyword">self</span><span class="variable">.images</span><span class="variable">.count</span>];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>第二步:自定义cell</strong><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"XVCollectionViewCell.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"XVTabBarController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XVCollectionViewCell</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIImageView</span> *imageV;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIButton</span> *button;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XVCollectionViewCell</span></span></span><br><span class="line"><span class="comment">// 实例化进入应用主界面的button</span></span><br><span class="line">- (<span class="built_in">UIButton</span> *)button</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_button == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">UIButton</span> *button = [[<span class="built_in">UIButton</span> alloc] init];</span><br><span class="line">        [button setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"startApp"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        [button sizeToFit];</span><br><span class="line">        button<span class="variable">.centerX</span> = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span>;</span><br><span class="line">        button<span class="variable">.centerY</span> = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span> * <span class="number">0.9</span>;</span><br><span class="line">        [button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(enterApp:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">        [<span class="keyword">self</span> addSubview:button];</span><br><span class="line">        _button = button;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写构造方法在初始化cell的时候就创建一个imageView用来显示新特性</span></span><br><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建显示新特新图片的imageView</span></span><br><span class="line">        <span class="built_in">UIImageView</span> *imageV = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="keyword">self</span><span class="variable">.bounds</span>];</span><br><span class="line">        [<span class="keyword">self</span> addSubview:imageV];</span><br><span class="line">        _imageV = imageV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写image的setter给imageV设置图片</span></span><br><span class="line">- (<span class="keyword">void</span>)setImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    _image = image;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageV</span><span class="variable">.image</span> = image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取索引来判断是否为最后一页</span></span><br><span class="line">- (<span class="keyword">void</span>)getIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath andImagesCount:(<span class="built_in">NSInteger</span>)imagesCount</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当滑动到最后一页时</span></span><br><span class="line">    <span class="keyword">if</span> (indexPath<span class="variable">.row</span> == imagesCount - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.button</span><span class="variable">.hidden</span> = <span class="literal">NO</span>; <span class="comment">// 显示button</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.button</span><span class="variable">.hidden</span> = <span class="literal">YES</span>; <span class="comment">// 隐藏button - 防止循环利用bug</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法快速创建cell</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *ID = <span class="string">@"cell"</span>;</span><br><span class="line">+ (instancetype)cellWithCollectionView:(<span class="built_in">UICollectionView</span> *)collectionView forIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    [collectionView registerClass:<span class="keyword">self</span> forCellWithReuseIdentifier:ID];</span><br><span class="line">    XVCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:ID forIndexPath:indexPath];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 监听方法</span></span><br><span class="line"><span class="comment">// 进入应用</span></span><br><span class="line">- (<span class="keyword">void</span>)enterApp:(<span class="built_in">UIButton</span> *)button</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 变更rootController</span></span><br><span class="line">    XVTabBarController *vc = [[XVTabBarController alloc] init];</span><br><span class="line">    [<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.keyWindow</span><span class="variable">.rootViewController</span> = vc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<h2 id="创建一个UIWindow的分类来控制是否显示新特性">创建一个UIWindow的分类来控制是否显示新特性</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"UIWindow+Extension.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"TabBarViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"NewFeaturesViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIWindow</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)switchRootViewController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.获得用户的偏好设置</span></span><br><span class="line">    <span class="built_in">NSUserDefaults</span> *user = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">    <span class="built_in">NSString</span> *keyVersion = <span class="string">@"CFBundleVersion"</span>;</span><br><span class="line">    <span class="comment">// 2.获得上一次打开的版本（存在沙盒内）</span></span><br><span class="line">    <span class="built_in">NSString</span> *lastVersion = [user valueForKeyPath:keyVersion];</span><br><span class="line">    <span class="comment">// 3.取出当前的版本号</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *info = [<span class="built_in">NSBundle</span> mainBundle]<span class="variable">.infoDictionary</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *currentVersion = info[keyVersion];</span><br><span class="line">    <span class="comment">// 4.当前版本号等于存于沙盒的版本号（上次打开时的版本）时则直接进入软件，否则显示新特性</span></span><br><span class="line">    <span class="keyword">if</span> ([currentVersion isEqualToString:lastVersion]) &#123;</span><br><span class="line">        TabBarViewController *tabBar = [[TabBarViewController alloc] init];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.rootViewController</span> = tabBar;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NewFeaturesViewController *new = [[NewFeaturesViewController alloc] init];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.rootViewController</span> = new;</span><br><span class="line">        <span class="comment">// 同步版本号</span></span><br><span class="line">        [user setValue:currentVersion forKeyPath:keyVersion];</span><br><span class="line">        [user synchronize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="使用UIScrollView搭建">使用UIScrollView搭建</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span clas]]>
    </summary>
    
      <category term="iOS中级-demo" scheme="http://xionv.com/tags/iOS%E4%B8%AD%E7%BA%A7-demo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[渐变图层,复制图层和形状图层的简单用法]]></title>
    <link href="http://xionv.com/2016/01/05/demonayu/blog/39.%E6%B8%90%E5%8F%98%E5%9B%BE%E5%B1%82,%E5%A4%8D%E5%88%B6%E5%9B%BE%E5%B1%82%E5%92%8C%E5%BD%A2%E7%8A%B6%E5%9B%BE%E5%B1%82%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xionv.com/2016/01/05/demonayu/blog/39.渐变图层,复制图层和形状图层的使用/</id>
    <published>2016-01-05T06:55:57.000Z</published>
    <updated>2016-01-11T08:28:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="渐变图层">渐变图层</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">/* 创建一个imageView控件 */</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *imageV = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image"</span>]];</span><br><span class="line">    imageV<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    imageV<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:imageV];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> addGradientLayerToView:imageV];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 添加渐变图层 */</span></span><br><span class="line">- (<span class="keyword">void</span>)addGradientLayerToView:(<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建一个渐变图层 */</span></span><br><span class="line">    <span class="built_in">CAGradientLayer</span> *gradient = [<span class="built_in">CAGradientLayer</span> layer];</span><br><span class="line">    <span class="comment">// 设置图层frame</span></span><br><span class="line">    gradient<span class="variable">.frame</span> = view<span class="variable">.bounds</span>;</span><br><span class="line">    <span class="comment">// 渐变颜色(用(id)强转成OC对象)</span></span><br><span class="line">    gradient<span class="variable">.colors</span> = @[(<span class="keyword">id</span>)[<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>, (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> blueColor]<span class="variable">.CGColor</span>];</span><br><span class="line">    <span class="comment">// 渐变范围(取值范围是0~1, 差值越大表示渐变范围越大)</span></span><br><span class="line">    gradient<span class="variable">.locations</span> = @[@<span class="number">0</span>, @<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 渐变方向(下面代码表示左上角到右下角的渐变)</span></span><br><span class="line">    gradient<span class="variable">.startPoint</span> = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    gradient<span class="variable">.endPoint</span> = <span class="built_in">CGPointMake</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 不透明度</span></span><br><span class="line">    gradient<span class="variable">.opacity</span> = <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给控件添加渐变图层</span></span><br><span class="line">    [view<span class="variable">.layer</span> addSublayer:gradient];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复制图层">复制图层</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 添加复制图层 */</span></span><br><span class="line">- (<span class="keyword">void</span>)addReplicatorLayerToView:(<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建一个复制层 */</span></span><br><span class="line">    <span class="built_in">CAReplicatorLayer</span> *replicator = [<span class="built_in">CAReplicatorLayer</span> layer];</span><br><span class="line">    <span class="comment">// 设置图层frame</span></span><br><span class="line">    replicator<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 设置背景颜色</span></span><br><span class="line">    replicator<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> blueColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    <span class="comment">// 添加图层</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:replicator];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子层1</span></span><br><span class="line">    <span class="built_in">CALayer</span> *sublayer1 = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    sublayer1<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">    sublayer1<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    [replicator addSublayer:sublayer1];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子层2</span></span><br><span class="line">    <span class="built_in">CALayer</span> *sublayer2 = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    sublayer2<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">70</span>, <span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">    sublayer2<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> greenColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    [replicator addSublayer:sublayer2];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制层是复制里面的子层,而不是复制层本身</span></span><br><span class="line">    <span class="comment">// 设置要复制图层中子层的个数(数量包括自己本身的)</span></span><br><span class="line">    replicator<span class="variable">.instanceCount</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 子层形变(基于上一次子层的形变)</span></span><br><span class="line">    replicator<span class="variable">.instanceTransform</span> = <span class="built_in">CATransform3DMakeTranslation</span>(<span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="形状图层">形状图层</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 添加形状图层 */</span></span><br><span class="line">- (<span class="keyword">void</span>)addShapeLayerToView:(<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 绘制一个圆形路径 */</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建一个形状图层 */</span></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *shape = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    <span class="comment">// 设置路径(将路径装换成形状图层)</span></span><br><span class="line">    shape<span class="variable">.path</span> = path<span class="variable">.CGPath</span>;</span><br><span class="line">    <span class="comment">// 设置填充色</span></span><br><span class="line">    shape<span class="variable">.fillColor</span> = [<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    <span class="comment">// 设置描边色</span></span><br><span class="line">    shape<span class="variable">.strokeColor</span> = [<span class="built_in">UIColor</span> blackColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    <span class="comment">// 设置线宽</span></span><br><span class="line">    shape<span class="variable">.lineWidth</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 描边起始点 (取值范围是0~1)</span></span><br><span class="line">    shape<span class="variable">.strokeStart</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 描边结束点 (取值范围是0~1)</span></span><br><span class="line">    shape<span class="variable">.strokeEnd</span> = <span class="number">0.75</span>;</span><br><span class="line">    <span class="comment">// 添加图层</span></span><br><span class="line">    [view<span class="variable">.layer</span> addSublayer:shape];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义view时重写父类类方法来修改view的初始层">自定义view时重写父类类方法来修改view的初始层</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回当前View当中layer的类型</span></span><br><span class="line">+ (Class)layerClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将初始层修改为复制层</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">CAReplicatorLayer</span> class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="渐变图层">渐变图层</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</spa]]>
    </summary>
    
      <category term="iOS中级" scheme="http://xionv.com/tags/iOS%E4%B8%AD%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图片折叠小demo]]></title>
    <link href="http://xionv.com/2016/01/04/demonayu/blog/40.%E5%9B%BE%E7%89%87%E6%8A%98%E5%8F%A0%E5%B0%8Fdemo/"/>
    <id>http://xionv.com/2016/01/04/demonayu/blog/40.图片折叠小demo/</id>
    <published>2016-01-04T14:40:57.000Z</published>
    <updated>2016-01-11T08:28:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="利用图层特性实现图片折叠的效果">利用图层特性实现图片折叠的效果</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define imageWH 200.0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIImageView</span> *imageTop;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIImageView</span> *imageBottom;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">CAGradientLayer</span> *gradient;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化图片</span></span><br><span class="line">    [<span class="keyword">self</span> setupImageView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 初始化图片 */</span></span><br><span class="line">- (<span class="keyword">void</span>)setupImageView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建一个透明的蒙版作为手势的接受者 */</span></span><br><span class="line">    <span class="built_in">UIView</span> *cover = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    cover<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, imageWH, imageWH);</span><br><span class="line">    cover<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line">    cover<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">    <span class="comment">// 添加pan手势</span></span><br><span class="line">    <span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pan:)];</span><br><span class="line">    [cover addGestureRecognizer:pan];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:cover];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 添加图片 - 原图片添加两次,分别显示上下部分 */</span></span><br><span class="line">    <span class="comment">// 上半部图片</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *imageTop = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">    imageTop<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">50</span>, imageWH, imageWH * <span class="number">0.5</span>);</span><br><span class="line">    imageTop<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"知道错了"</span>];</span><br><span class="line">    <span class="comment">// 修改layer的contentsRect只显示显示图片的上半部</span></span><br><span class="line">    imageTop<span class="variable">.layer</span><span class="variable">.contentsRect</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 修改锚点Y值为图片的高度</span></span><br><span class="line">    imageTop<span class="variable">.layer</span><span class="variable">.anchorPoint</span> = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">    _imageTop = imageTop;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下半部图片</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *imageBottom = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">    imageBottom<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">50</span>, imageWH, imageWH * <span class="number">0.5</span>);</span><br><span class="line">    imageBottom<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"知道错了"</span>];</span><br><span class="line">    <span class="comment">// 修改layer的contentsRect只显示显示图片的下半部</span></span><br><span class="line">    imageBottom<span class="variable">.layer</span><span class="variable">.contentsRect</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 修改锚点Y值为0</span></span><br><span class="line">    imageBottom<span class="variable">.layer</span><span class="variable">.anchorPoint</span> = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">    _imageBottom = imageBottom;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 给下半部图片添加阴影效果 */</span></span><br><span class="line">    <span class="comment">// 创建一个渐变层用来显示阴影效果</span></span><br><span class="line">    <span class="built_in">CAGradientLayer</span> *gradient = [<span class="built_in">CAGradientLayer</span> layer];</span><br><span class="line">    _gradient = gradient;</span><br><span class="line">    <span class="comment">// 设置图层的位置</span></span><br><span class="line">    gradient<span class="variable">.frame</span> = imageBottom<span class="variable">.bounds</span>;</span><br><span class="line">    <span class="comment">// 设置渐变颜色</span></span><br><span class="line">    gradient<span class="variable">.colors</span> = @[(<span class="keyword">id</span>)[<span class="built_in">UIColor</span> clearColor]<span class="variable">.CGColor</span>, (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> blackColor]<span class="variable">.CGColor</span>];</span><br><span class="line">    <span class="comment">// 设置不透明度</span></span><br><span class="line">    gradient<span class="variable">.opacity</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 给下半部图片添加图层</span></span><br><span class="line">    [imageBottom<span class="variable">.layer</span> addSublayer:gradient];</span><br><span class="line">    </span><br><span class="line">    [cover addSubview:imageBottom];</span><br><span class="line">    [cover addSubview:imageTop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 监听pan手势 */</span></span><br><span class="line">- (<span class="keyword">void</span>)pan:(<span class="built_in">UIPanGestureRecognizer</span> *)pan</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得手指偏移量的Y值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> offsetY = [pan translationInView:<span class="keyword">self</span><span class="variable">.view</span>]<span class="variable">.y</span>;</span><br><span class="line">    <span class="comment">// 将偏移量转成旋转弧度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> angle = offsetY * M_PI / imageWH;</span><br><span class="line">    <span class="keyword">if</span> (angle &gt; M_PI) &#123;</span><br><span class="line">        angle = M_PI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置透视效果 - 除数值越大透视效果越不明显(可以理解成眼睛看到物体的距离)</span></span><br><span class="line">    <span class="built_in">CATransform3D</span> transform = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">    transform<span class="variable">.m34</span> = -<span class="number">1</span> / <span class="number">400.0</span>;</span><br><span class="line">    <span class="comment">// 根据偏移量沿x轴旋转上半部图片</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageTop</span><span class="variable">.layer</span><span class="variable">.transform</span> = <span class="built_in">CATransform3DRotate</span>(transform, -angle, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 给下半部图片添加阴影效果</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.gradient</span><span class="variable">.opacity</span> = offsetY * <span class="number">1</span> / imageWH;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当手指松开的时候将位置返回</span></span><br><span class="line">    <span class="keyword">if</span> (pan<span class="variable">.state</span> == <span class="built_in">UIGestureRecognizerStateEnded</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置反弹动画</span></span><br><span class="line">        <span class="comment">// Duration:动画的执行时长</span></span><br><span class="line">        <span class="comment">// delay:延时执行时长</span></span><br><span class="line">        <span class="comment">// Damping:弹性系数(越小,弹性越大)</span></span><br><span class="line">        <span class="comment">// SpringVelocity:初始的弹性系数</span></span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.25</span> delay:<span class="number">0</span> usingSpringWithDamping:<span class="number">0.1</span> initialSpringVelocity:<span class="number">0</span> options:<span class="number">0</span> animations:^&#123;</span><br><span class="line">            <span class="comment">// 清空transform</span></span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageTop</span><span class="variable">.layer</span><span class="variable">.transform</span> = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">            <span class="comment">// 还原不透明度</span></span><br><span class="line">            <span class="keyword">self</span><span class="variable">.gradient</span><span class="variable">.opacity</span> = <span class="number">0</span>;</span><br><span class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="利用图层特性实现图片折叠的效果">利用图层特性实现图片折叠的效果</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class=]]>
    </summary>
    
      <category term="iOS中级 - demo" scheme="http://xionv.com/tags/iOS%E4%B8%AD%E7%BA%A7-demo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSFileManager和NSFileHandle的常用方法]]></title>
    <link href="http://xionv.com/2015/12/30/demonayu/blog/34.NSFileManager%E5%92%8CNSFileHandle%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://xionv.com/2015/12/30/demonayu/blog/34.NSFileManager和NSFileHandle的常用方法/</id>
    <published>2015-12-30T11:52:57.000Z</published>
    <updated>2016-01-11T08:28:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="NSFileManager">NSFileManager</h2><ul>
<li><p>创建一个文件管理者对象</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件与目录的操作</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">createFileAtPath:    <span class="comment">// 创建文件</span></span><br><span class="line">copyItemAtPath:    <span class="comment">// 复制文件</span></span><br><span class="line">moveItemAtPath:    <span class="comment">// 移动文件</span></span><br><span class="line">removeItemFileAtPath:    <span class="comment">// 删除文件</span></span><br><span class="line">attributesOfItemAtPath:    <span class="comment">// 获取文件的属性</span></span><br><span class="line">setAttributes:    <span class="comment">// 更改属性</span></span><br><span class="line">currentDirectoryPath:    <span class="comment">// 获取当前的目录</span></span><br><span class="line">changeCurrentDirectoryPath:    <span class="comment">// 更改目录</span></span><br><span class="line">createDirectoryAtPath:    <span class="comment">//  创建目录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取文件和目录信息</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">contentsAtPath:    <span class="comment">// 获取文件中的信息</span></span><br><span class="line">enumeratorAtPath:    <span class="comment">// 枚举目录</span></span><br><span class="line">contentsOfDirectoryAtPath:    <span class="comment">// 列举目录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>判断文件</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">fileExistsAtPath:    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">isReadableFile:    <span class="comment">// 判断是否能进行读取操作</span></span><br><span class="line">isWritableFileAtPath:    <span class="comment">// 判断是否能进行写入操作</span></span><br><span class="line">isDeletableFileAtPath:    <span class="comment">// 判断是否可删除</span></span><br><span class="line">isExecutableFileAtPath:    <span class="comment">// 判断是否可以执行</span></span><br><span class="line">contentsEqualAtPath:    <span class="comment">// 判断是否相等</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>目录工具函数</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSUserName</span>()    <span class="comment">// 函数:返回登录名</span></span><br><span class="line"><span class="built_in">NSFullUserName</span>()    <span class="comment">// 函数:返回完整用户名</span></span><br><span class="line"><span class="built_in">NSHomeDirectory</span>()   <span class="comment">// 函数:返回路径</span></span><br><span class="line"><span class="built_in">NSHomeDirectoryForUser</span>()    <span class="comment">// 函数:返回用户的主目录</span></span><br><span class="line"><span class="built_in">NSTemporaryDirectory</span>()  <span class="comment">// 函数:返回临时文件的路径目录</span></span><br><span class="line">[fileList pathsMatchingExtensions:[<span class="built_in">NSArrayarrayWithObject</span>:<span class="string">@"jpg"</span>]];   <span class="comment">// 过滤数组中的文件类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常用路径工具方法</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)pathWithComponents:components        <span class="comment">// 根据components中元素构造有效路径</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)pathComponents        <span class="comment">// 析构路径,获取路径的各个部分</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)lastPathComponent        <span class="comment">// 提取路径的最后一个组成部分</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)pathExtension        <span class="comment">// 路径扩展名</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByAppendingPathComponent:path        <span class="comment">// 将path添加到现有路径末尾</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByAppendingPathExtension:ext        <span class="comment">// 将拓展名添加的路径最后一个组成部分</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByDeletingPathComponent        <span class="comment">// 删除路径的最后一个部分</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByDeletingPathExtension        <span class="comment">// 删除路径的最后一个部分 的扩展名</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByExpandingTildeInPath        <span class="comment">// 将路径中的代字符扩展成用户主目录(~)或指定用户主目录(~user)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByResolvingSymlinksInPath        <span class="comment">// 尝试解析路径中的符号链接</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByStandardizingPath        <span class="comment">// 通过尝试解析~、..、.、和符号链接来标准化路径</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="NSFileHandle">NSFileHandle</h2><ul>
<li>文件读取 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">init:    <span class="comment">// 初始化文件读写对象</span></span><br><span class="line">fileHandleForReadingAtPath:    <span class="comment">// 读取时打开文件</span></span><br><span class="line">fileHandleForWritingAtPath:    <span class="comment">// 写入时打开文件</span></span><br><span class="line">fileHandleForUpdatingAtPath:    <span class="comment">// 更新时打开文件</span></span><br><span class="line">writeData:    <span class="comment">// 数据写入文件</span></span><br><span class="line">readDataToEndOfFile:    <span class="comment">// 读取数据</span></span><br><span class="line">readDataOfLength:    <span class="comment">// 读取固定大小的内容</span></span><br><span class="line">offsetInFile:    <span class="comment">// 获取当前偏移量</span></span><br><span class="line">seekToFileOffset:    <span class="comment">// 设置当前的偏移量</span></span><br><span class="line">seekToEndOfFile:    <span class="comment">// 将偏移量定位到文件尾</span></span><br><span class="line">truncateFileAtOffset:    <span class="comment">// 设置字节</span></span><br><span class="line">availableData:    <span class="comment">// 返回可用数据</span></span><br><span class="line">closeFile:    <span class="comment">// 关闭文件</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="NSProcessInfo类:设置或检索正在运行的应用程序的各种类型信息">NSProcessInfo类:设置或检索正在运行的应用程序的各种类型信息</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSProcessInfo</span> *)processInfo        <span class="comment">// 返回当前进程的信息</span></span><br><span class="line">- (<span class="built_in">NSArray</span>*)arguments        <span class="comment">// 以NSString对象数字的形式返回当前进程的参数</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)environment        <span class="comment">//  返回变量/值对词典。描述当前的环境变量</span></span><br><span class="line">- (<span class="keyword">int</span>)processIdentity        <span class="comment">// 返回进程标识</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)processName        <span class="comment">// 返回进程名称</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)globallyUniqueString        <span class="comment">// 每次调用该方法都会返回不同的单值字符串，可以用这个字符串生成单值临时文件名</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)hostname        <span class="comment">// 返回主机系统的名称</span></span><br><span class="line">- (<span class="keyword">unsigned</span> <span class="keyword">int</span>)operatingSystem        <span class="comment">// 返回表示操作系统的数字</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)operatingSystemName        <span class="comment">// 返回操作系统名称</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)operatingSystemVersionString        <span class="comment">// 返回操作系统当前版本</span></span><br><span class="line">- (<span class="keyword">void</span>)setProcessName:(<span class="built_in">NSString</span> *)name        <span class="comment">// 将当前进程名称设置为name</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="NSFileManager">NSFileManager</h2><ul>
<li><p>创建一个文件管理者对象</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span ]]>
    </summary>
    
      <category term="iOS备忘" scheme="http://xionv.com/tags/iOS%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[调用系统相册方法]]></title>
    <link href="http://xionv.com/2015/12/30/demonayu/blog/33.%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%86%8C%E6%96%B9%E6%B3%95/"/>
    <id>http://xionv.com/2015/12/30/demonayu/blog/33.调用系统相册方法/</id>
    <published>2015-12-30T07:59:57.000Z</published>
    <updated>2016-01-11T08:28:51.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li><p>调用系统相册</p>
<ol>
<li><p>调用系统相册需要先实例化一个照片选择控制器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建照片选择器</span></span><br><span class="line"><span class="built_in">UIImagePickerController</span> *picker = [[<span class="built_in">UIImagePickerController</span> alloc] init];</span><br><span class="line"><span class="comment">// 2. 设置数据源类型(是相册还是照相机)</span></span><br><span class="line">picker<span class="variable">.sourceType</span> = <span class="built_in">UIImagePickerControllerSourceTypeSavedPhotosAlbum</span>;</span><br><span class="line"><span class="comment">// 3. 将调用改控制的对象设置为代理 - 这里必须要实现系统要求的两个协议</span></span><br><span class="line">picker<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">// 4. modal出照片选择控制器</span></span><br><span class="line">[<span class="keyword">self</span> presentViewController:picker animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用代理方法拿到照片</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// info这个字典参数是选中照片的一些信息,根据里面的key可以拿到选择的照片</span></span><br><span class="line"> - (<span class="keyword">void</span>)imagePickerController:(<span class="built_in">UIImagePickerController</span> *)picker didFinishPickingMediaWithInfo:(<span class="built_in">NSDictionary</span> *)info</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 拿到图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = info[<span class="built_in">UIImagePickerControllerOriginalImage</span>];</span><br><span class="line">    <span class="comment">// 将照片选取器隐藏</span></span><br><span class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>往相册里存入照片</p>
<ol>
<li><p>调用写入方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将图片保存到用户相册里面</span></span><br><span class="line"><span class="comment">// image: 将要保存的图片</span></span><br><span class="line"><span class="comment">// target: 方法监听者</span></span><br><span class="line"><span class="comment">// SEL: 保存图片完成时调用的方法(系统规定写法,用来监听保存状态)</span></span><br><span class="line"><span class="comment">// contextInfo: 上下文信息</span></span><br><span class="line"><span class="built_in">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="keyword">self</span>, <span class="keyword">@selector</span>(image:didFinishSavingWithError:contextInfo:), <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现监听方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 保存相册后回调的监听方法</span></span><br><span class="line"> - (<span class="keyword">void</span>)image:(<span class="built_in">UIImage</span> *)image didFinishSavingWithError:(<span class="built_in">NSError</span> *)error contextInfo:(<span class="keyword">void</span> *)contextInfo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"保存失败"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"保存成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><p>调用系统相册</p>
<ol>
<li><p>调用系统相册需要先实例化一个照片选择控制器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="li]]>
    </summary>
    
      <category term="iOS备忘" scheme="http://xionv.com/tags/iOS%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[核心动画与UIView动画的对比]]></title>
    <link href="http://xionv.com/2015/12/30/demonayu/blog/32.%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E4%B8%8E%E6%98%BE%E7%A4%BA%E5%8A%A8%E7%94%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://xionv.com/2015/12/30/demonayu/blog/32.核心动画与显示动画的区别/</id>
    <published>2015-12-30T07:45:57.000Z</published>
    <updated>2016-01-11T08:28:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="CALayer">CALayer</h2><ul>
<li>CALayer简介<ul>
<li>CALayer我们又称它叫做层.</li>
<li>在每个UIView内部都有一个layer这样一个属性.</li>
<li>UIView之所以能够显示,就是因为它里面有这个一个层,才具有显示的功能.</li>
<li>我们通过操作CALayer对象,可以很方便地调整UIView的一些外观属性.比如给UIView设置阴影,圆角,边框等等…</li>
<li>所进行的核心动画在层里完成</li>
</ul>
</li>
<li><p>设置CALayer属性</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)add<span class="built_in">CALayer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自定义一个图层</span></span><br><span class="line">    <span class="built_in">CALayer</span> *layer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    <span class="comment">// 设置图层的宽高</span></span><br><span class="line">    layer<span class="variable">.bounds</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 图层位置</span></span><br><span class="line">    layer<span class="variable">.position</span> = <span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 图层的锚点(它决定CALayer身上哪一个点会在position属性所指的位置,默认为(0.5, 0.5)</span></span><br><span class="line">    layer<span class="variable">.anchorPoint</span> = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 图层的背景颜色</span></span><br><span class="line">    layer<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    <span class="comment">// 设置图层的圆角</span></span><br><span class="line">    layer<span class="variable">.cornerRadius</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 相当于Clip</span></span><br><span class="line">    layer<span class="variable">.masksToBounds</span> = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">// 设置图层边框宽度</span></span><br><span class="line">    layer<span class="variable">.borderWidth</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 设置图层边框颜色</span></span><br><span class="line">    layer<span class="variable">.borderColor</span> = [<span class="built_in">UIColor</span> whiteColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    <span class="comment">// 设置图层显示内容</span></span><br><span class="line">    layer<span class="variable">.contents</span> = (__bridge <span class="keyword">id</span>)([<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image"</span>]<span class="variable">.CGImage</span>);</span><br><span class="line">    <span class="comment">// 将自定义图层加载到父图层</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:layer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>注意</strong>: UIImageView当中Image并不是直接添加在层上面的.而是添加在layer当中的<code>contents</code>里.我们设置层的所有属性它只作用在层上面.对contents里面的东西并不起作用.所以如果直接只设置<code>cornerRadius</code>我们是看不到图片的圆角效果的.想要让图片有圆角的效果,需要设置<code>masksToBounds</code>属性设为YES,它会把超过根层以外的东西都给裁剪掉.<br> <strong>PS1</strong>: 为什么要使用CGImageRef、CGColorRef?         为了保证可移植性,QuartzCore不能使用UIImage、UIColor,只能使用CGImageRef、CGColorRef.<br> <strong>PS2</strong>: 所有的动画都是基于锚点做参照来进行的.</p>
</li>
<li><p>CALayer的<code>CATransform3D</code>属性 (只有旋转的时候才可以看出3D的效果).</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x,y,z 分别代表x,y,z轴.</span></span><br><span class="line"><span class="comment">// 旋转: </span></span><br><span class="line"><span class="built_in">CATransform3DMakeRotation</span>(M_PI, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 平移:</span></span><br><span class="line"><span class="built_in">CATransform3DMakeTranslation</span>(x,y,z);</span><br><span class="line"><span class="comment">// 缩放:</span></span><br><span class="line"><span class="built_in">CATransform3DMakeScale</span>(x,y,z);</span><br></pre></td></tr></table></figure>
<p> <strong>CATransform3D的键值</strong><br><img src="http://r6.loli.io/NNvIvy.png" alt="CATransform3D Key Paths"></p>
</li>
</ul>
<h2 id="隐式动画">隐式动画</h2><ul>
<li>什么是隐式动画 <br><ul>
<li>在了解隐式动画前先了解什么是根层和非根层:<ul>
<li>根层: UIView内部自动关联着的那个layer我们称它是根层.</li>
<li>非根层: 自己手动创建的层,称为非根层.</li>
</ul>
</li>
<li>隐式动画就是当对非根层的部分属性进行修改时,它会自动的产生一些动画的效果.我们称这个默认产生的动画为隐式动画.</li>
<li>给根层添加的动画叫做核心动画.隐式动画是系统默认给非根层添加的动画,核心动画是程序员自己手动来添加的,其实隐式动画就是核心动画.</li>
</ul>
</li>
<li>如何取消隐式动画<ul>
<li>隐式动画的底层是包装成一个事务(<code>CATransaction</code>)来进行的.<ul>
<li>事物: 很多操作绑定在一起,当这些操作执行完毕后,才去执行下一个操作.</li>
</ul>
</li>
<li>手动在事物中关闭动画<code>[CATransaction setDisableActions:YES];</code><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    <span class="built_in">CGPoint</span> point = [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 开启事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">        <span class="comment">// 动画时长</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">0.1</span>];</span><br><span class="line">        <span class="comment">// 取消隐式动画 (默认有)</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 修改图层属性</span></span><br><span class="line">    <span class="built_in">CGFloat</span> r = arc4random_uniform(<span class="number">256</span>) / <span class="number">255.0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> g = arc4random_uniform(<span class="number">256</span>) / <span class="number">255.0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> b = arc4random_uniform(<span class="number">256</span>) / <span class="number">255.0</span>;</span><br><span class="line">    <span class="comment">// 修改背景颜色</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.layer</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> colorWithRed:r green:g blue:b alpha:<span class="number">1</span>]<span class="variable">.CGColor</span>;</span><br><span class="line">    <span class="comment">// 修改圆角度数</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.layer</span><span class="variable">.cornerRadius</span> = arc4random_uniform(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 修改位置</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.layer</span><span class="variable">.position</span> = point;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 提交事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="核心动画">核心动画</h2><p><img src="http://r5.loli.io/YryMbm.png" alt="核心动画的继承结构"></p>
<blockquote>
<p>核心动画中所有类都遵守CAMediaTiming协议</p>
</blockquote>
<ul>
<li><p><strong>核心动画的继承结构</strong></p>
<ul>
<li>CAAnaimation是个抽象类,不具备动画效果,必须用它的子类才有动画效果,其中:<ul>
<li>CAAnimationGroup是个动画组,可以同时进行缩放,旋转;</li>
<li>CATransition是转场动画,界面之间跳转都可以用转场动画;</li>
</ul>
</li>
<li>CAPropertyAnimation也是个抽象类,本身不具备动画效果,只有调用其子类才有动画,其中:<ul>
<li>CABasicAnimation基本动画，做一些简单效果;</li>
<li>CAKeyframeAnimation帧动画，做一些连续的流畅的动画;</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基础核心动画</strong></p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建基本核心动画</span></span><br><span class="line"><span class="comment">// 旋转</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *rotation = [<span class="built_in">CABasicAnimation</span> animation];</span><br><span class="line"><span class="comment">// 直接通过KVC来更改键值</span></span><br><span class="line">rotation<span class="variable">.keyPath</span> = <span class="string">@"transform.rotation"</span>;</span><br><span class="line">rotation<span class="variable">.toValue</span> = @M_PI_2;</span><br><span class="line"><span class="comment">// 位移</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *position = [<span class="built_in">CABasicAnimation</span> animation];</span><br><span class="line">position<span class="variable">.keyPath</span> = <span class="string">@"position"</span>;</span><br><span class="line">position<span class="variable">.toValue</span> = [<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">200</span>)];</span><br><span class="line"><span class="comment">// 缩放</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *scale = [<span class="built_in">CABasicAnimation</span> animation];</span><br><span class="line">scale<span class="variable">.keyPath</span> = <span class="string">@"transform.scale"</span>;</span><br><span class="line">scale<span class="variable">.toValue</span> = @<span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个动画组(组合动画)</span></span><br><span class="line"><span class="built_in">CAAnimationGroup</span> *group = [<span class="built_in">CAAnimationGroup</span> animation];</span><br><span class="line"><span class="comment">// 将动画添加到动画组</span></span><br><span class="line">group<span class="variable">.animations</span> = @[rotation, position, scale];</span><br><span class="line"><span class="comment">// 动画时间</span></span><br><span class="line">group<span class="variable">.duration</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 取消反弹</span></span><br><span class="line">group<span class="variable">.removedOnCompletion</span> = <span class="literal">NO</span>;</span><br><span class="line"><span class="comment">// 保存动画最前面的效果</span></span><br><span class="line">group<span class="variable">.fillMode</span> = k<span class="built_in">CAFillModeForwards</span>;</span><br><span class="line"><span class="comment">// 给控件图层添加动画</span></span><br><span class="line">[image<span class="variable">.layer</span> addAnimation:group forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p> 使用动画组的好处: 不需要每次都去添加动画,设置动画完成时的属性.只需要把要执行的动画,添加到动画组的animations数组当中即可.最后把组动画添加到层上面,就会自动执行数组当中的动画.动画完成时设置的属性也只需要设置一次.</p>
</li>
<li><p><strong>关键帧动画</strong></p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建关键帧动画对象</span></span><br><span class="line"><span class="built_in">CAKeyframeAnimation</span> *frameAnim = [<span class="built_in">CAKeyframeAnimation</span> animation];</span><br><span class="line"><span class="comment">// 2.绘制一个路径</span></span><br><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line"><span class="comment">// 3.设置动画参数</span></span><br><span class="line">group<span class="variable">.duration</span> = <span class="number">1</span>;</span><br><span class="line">group<span class="variable">.removedOnCompletion</span> = <span class="literal">NO</span>;</span><br><span class="line">group<span class="variable">.fillMode</span> = k<span class="built_in">CAFillModeForwards</span>;</span><br><span class="line"><span class="comment">// 4.给控件添加动画</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.layer</span> addAnimation:frameAnim forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转场动画</strong></p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 转场动画要和转场代码写在同一个方法当中才有动画效果.</span></span><br><span class="line">    <span class="comment">// 1.1 设定转场条件</span></span><br><span class="line">    _i++;</span><br><span class="line">    <span class="keyword">if</span> (_i &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        _i = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.2 添加转场代码 - 替换图片</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageV</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, _i]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.1 添加一个转场动画</span></span><br><span class="line">    <span class="built_in">CATransition</span> *anim = [<span class="built_in">CATransition</span> animation];</span><br><span class="line">    <span class="comment">// 2.2 设置转场样式</span></span><br><span class="line">    anim<span class="variable">.type</span> = <span class="string">@"cube"</span>;</span><br><span class="line">    <span class="comment">// 2.3 动画参数</span></span><br><span class="line">      <span class="comment">//设置动画的开始位置</span></span><br><span class="line">      anim<span class="variable">.startProgress</span> = <span class="number">0.5</span>;</span><br><span class="line">	  <span class="comment">//设置动画的结束位置</span></span><br><span class="line">      anim<span class="variable">.endProgress</span>  =<span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">// 2.3 添加转场动画</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.imageV</span><span class="variable">.layer</span> addAnimation:anim forKey:<span class="literal">nil</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>转场动画过渡效果</strong><br><img src="http://r5.loli.io/iyUn22.png" alt="转场动画过渡效果"></p>
</li>
<li><p>核心动画的代理方法 - 它所使用的是非正式协议(其实就是个分类)</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动画开始</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim;</span><br><span class="line"><span class="comment">// 动画结束</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag;</span><br></pre></td></tr></table></figure>
</li>
<li><p>暂停动画和恢复动画</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂停动画</span></span><br><span class="line">-(<span class="keyword">void</span>)pauseLayer:(<span class="built_in">CALayer</span>*)layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CFTimeInterval</span> pausedTime = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 让CALayer的时间停止走动</span></span><br><span class="line">  layer<span class="variable">.speed</span> = <span class="number">0.0</span>;</span><br><span class="line"><span class="comment">// 让CALayer的时间停留在pausedTime这个时刻</span></span><br><span class="line">layer<span class="variable">.timeOffset</span> = pausedTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复动画</span></span><br><span class="line">-(<span class="keyword">void</span>)resumeLayer:(<span class="built_in">CALayer</span>*)layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CFTimeInterval</span> pausedTime = layer<span class="variable">.timeOffset</span>;</span><br><span class="line"><span class="comment">// 1. 让CALayer的时间继续行走</span></span><br><span class="line">  layer<span class="variable">.speed</span> = <span class="number">1.0</span>;</span><br><span class="line"><span class="comment">// 2. 取消上次记录的停留时刻</span></span><br><span class="line">  layer<span class="variable">.timeOffset</span> = <span class="number">0.0</span>;</span><br><span class="line"><span class="comment">// 3. 取消上次设置的时间</span></span><br><span class="line">  layer<span class="variable">.beginTime</span> = <span class="number">0.0</span>;    </span><br><span class="line"><span class="comment">// 4. 计算暂停的时间(这里也可以用CACurrentMediaTime()-pausedTime)</span></span><br><span class="line"><span class="built_in">CFTimeInterval</span> timeSincePause = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>] - pausedTime;</span><br><span class="line"><span class="comment">// 5. 设置相对于父坐标系的开始时间(往后退timeSincePause)</span></span><br><span class="line">  layer<span class="variable">.beginTime</span> = timeSincePause;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>补充两个控制动画的属性: <figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="header">fillMode属性值（要想fillMode有效，最好设置removedOnCompletion = NO）</span><br><span class="line">--------------</span></span><br><span class="line">kCAFillModeRemoved: 这个是默认值,也就是说当动画开始前和动画结束后,动画对layer都没有影响,动画结束后,layer会恢复到之前的状态;</span><br><span class="line">kCAFillModeForwards: 当动画结束后,layer会一直保持着动画最后的状态;</span><br><span class="line">kCAFillModeBackwards: 在动画开始前,只需要将动画加入了一个layer,layer便立即进入动画的初始状态并等待动画开始;</span><br><span class="line">kCAFillModeBoth: 这个其实就是上面两个的合成.动画加入后开始之前,layer便处于动画初始状态,动画结束后layer保持动画最后的状态.</span><br><span class="line"></span><br><span class="line"><span class="header">速度控制函数(CAMediaTimingFunction) </span><br><span class="line">--------------</span></span><br><span class="line">kCAMediaTimingFunctionLinear(线性): 匀速,给你一个相对静态的感觉;</span><br><span class="line">kCAMediaTimingFunctionEaseIn(渐进): 动画缓慢进入,然后加速离开;</span><br><span class="line">kCAMediaTimingFunctionEaseOut(渐出): 动画全速进入,然后减速的到达目的地;</span><br><span class="line">kCAMediaTimingFunctionEaseInEaseOut(渐进渐出): 动画缓慢的进入,中间加速，然后减速的到达目的地。这个是默认的动画行为.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="UIView动画与核心动画对比?">UIView动画与核心动画对比?</h2><ul>
<li>UIView动画和核心动画区别?<ul>
<li>核心动画只能添加到CALayer(图层);</li>
<li>核心动画一切都是假象,并不会改变真实的值;</li>
</ul>
</li>
<li>什么时候使用UIView的动画?<ul>
<li>如果需要与用户交互就使用UIView的动画;</li>
<li>不需要与用户交互可以使用核心动画;</li>
</ul>
</li>
<li>什么场景使用核心动画最多?<ul>
<li>在转场动画中,核心动画的类型比较多;</li>
<li>根据一个路径做动画,只能用核心动画（帧动画）;</li>
<li>动画组: 同时做多个动画;</li>
</ul>
</li>
<li>UIView和CALayer该怎样选择?<ul>
<li>对比CALayer,UIView多了一个事件处理的功能.也就是说CALayer不能处理用户的触摸事件,而UIView可以,如果显示出来的东西需要跟用户进行交互的话,用UIView;如果不需要跟用户进行交互,用UIView或者CALayer都可以.CALayer的性能会高一些,因为它少了事件处理的功能,更加轻量级.</li>
</ul>
</li>
</ul>
<h3 id="使用UIView动画函数实现转场动画">使用UIView动画函数实现转场动画</h3> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 单视图 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)transitionWithView:(<span class="built_in">UIView</span> *)view duration:(<span class="built_in">NSTimeInterval</span>)duration options:(<span class="built_in">UIViewAnimationOptions</span>)options animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion;</span><br><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"><span class="comment">// duration：动画的持续时间</span></span><br><span class="line"><span class="comment">// view：需要进行转场动画的视图</span></span><br><span class="line"><span class="comment">// options：转场动画的类型</span></span><br><span class="line"><span class="comment">// animations：将改变视图属性的代码放在这个block中</span></span><br><span class="line"><span class="comment">// completion：动画结束后，会自动调用这个block</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双视图 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)transitionFromView:(<span class="built_in">UIView</span> *)fromView toView:(<span class="built_in">UIView</span> *)toView duration:(<span class="built_in">NSTimeInterval</span>)duration options:(<span class="built_in">UIViewAnimationOptions</span>)options completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion;</span><br><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"><span class="comment">// duration：动画的持续时间</span></span><br><span class="line"><span class="comment">// options：转场动画的类型</span></span><br><span class="line"><span class="comment">// animations：将改变视图属性的代码放在这个block中</span></span><br><span class="line"><span class="comment">// completion：动画结束后，会自动调用这个block</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="CALayer">CALayer</h2><ul>
<li>CALayer简介<ul>
<li>CALayer我们又称它叫做层.</li>
<li>在每个UIView内部都有一个layer这样一个属性.</li>
<li>UIView之所以能够显示,就是因为它里面]]>
    </summary>
    
      <category term="iOS中级" scheme="http://xionv.com/tags/iOS%E4%B8%AD%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Quartz2D]]></title>
    <link href="http://xionv.com/2015/12/26/demonayu/blog/31.Quartz2D/"/>
    <id>http://xionv.com/2015/12/26/demonayu/blog/31.Quartz2D/</id>
    <published>2015-12-26T01:35:57.000Z</published>
    <updated>2016-01-11T08:28:51.000Z</updated>
    <content type="html"><![CDATA[<h3 id="长按截屏">长按截屏</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)longPress:(<span class="built_in">UILongPressGestureRecognizer</span> *)longPress</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注意这个longPress会调用两次,一次是触发时,一次是结束时, 所以这里需要对状态进行一次判定,避免两次触发</span></span><br><span class="line">    <span class="keyword">if</span> (longPress<span class="variable">.state</span> == <span class="built_in">UIGestureRecognizerStateBegan</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过设置首尾式动画来达到屏幕闪一下的效果</span></span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.2</span> animations:^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.alpha</span> = <span class="number">0.6</span>;</span><br><span class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">            [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span> animations:^&#123;</span><br><span class="line">                <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.alpha</span> = <span class="number">1</span>;</span><br><span class="line">            &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                <span class="comment">// 开启一个全屏位图上下文</span></span><br><span class="line">                <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>([<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span>, <span class="literal">YES</span>, <span class="number">0.0</span> );</span><br><span class="line">                <span class="comment">// 获取当前上下文</span></span><br><span class="line">                <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">                <span class="comment">// 渲染图层到上下文</span></span><br><span class="line">                [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> renderInContext:ctx];</span><br><span class="line">                <span class="comment">// 将当前上下文中的内容转成图片</span></span><br><span class="line">                <span class="built_in">UIImage</span> *capture = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">                <span class="comment">// 关闭上下文</span></span><br><span class="line">                <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">                <span class="comment">// 将图片输出</span></span><br><span class="line">                <span class="built_in">NSData</span> *imgData = <span class="built_in">UIImagePNGRepresentation</span>(capture);</span><br><span class="line">                [imgData writeToFile:<span class="string">@"/Users/Xion/Desktop/image.png"</span> atomically:<span class="literal">YES</span>];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图片裁剪">图片裁剪</h3><blockquote>
<p>为UIimage增加一个分类类方法,在实例化图片时就对其进行裁剪</p>
</blockquote>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="preprocessor">#import <span class="title">"UIImage+ClipImage.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">ClipImage</span>)</span></span><br><span class="line">+ (instancetype)imageNamed:(<span class="built_in">NSString</span> *)name withClipShape:(ClipShape)shape;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageNamed:name];</span><br><span class="line">    <span class="comment">// 开启一个上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(image<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 设置为模具</span></span><br><span class="line">    <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">        <span class="keyword">case</span> ClipShapeWithCircle: &#123; <span class="comment">// 圆</span></span><br><span class="line">            <span class="built_in">CGFloat</span> radius = image<span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span>;</span><br><span class="line">            <span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(radius, radius);</span><br><span class="line">            <span class="built_in">UIBezierPath</span> *circlePath = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:radius startAngle:<span class="number">0</span> endAngle:M_PI * <span class="number">2</span> clockwise:<span class="literal">YES</span>];</span><br><span class="line">            <span class="comment">// 设置裁剪区</span></span><br><span class="line">            [circlePath addClip];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ClipShapeWithtriangle: &#123; <span class="comment">// 三角形</span></span><br><span class="line">            <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">            <span class="built_in">CGPoint</span> startP = <span class="built_in">CGPointMake</span>(image<span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">            [path moveToPoint:startP];</span><br><span class="line">            [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, image<span class="variable">.size</span><span class="variable">.height</span>)];</span><br><span class="line">            [path addLineToPoint:<span class="built_in">CGPointMake</span>(image<span class="variable">.size</span><span class="variable">.width</span>, image<span class="variable">.size</span><span class="variable">.height</span>)];</span><br><span class="line">            <span class="comment">// 关闭路径</span></span><br><span class="line">            [path closePath];</span><br><span class="line">            [path addClip];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ClipShapeWithRhombus: &#123; <span class="comment">// 菱形</span></span><br><span class="line">            <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">            <span class="built_in">CGPoint</span> startP = <span class="built_in">CGPointMake</span>(image<span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">            [path moveToPoint:startP];</span><br><span class="line">            [path addLineToPoint:<span class="built_in">CGPointMake</span>(image<span class="variable">.size</span><span class="variable">.width</span>, image<span class="variable">.size</span><span class="variable">.height</span> * <span class="number">0.5</span>)];</span><br><span class="line">            [path addLineToPoint:<span class="built_in">CGPointMake</span>(image<span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span>, image<span class="variable">.size</span><span class="variable">.height</span>)];</span><br><span class="line">            [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, image<span class="variable">.size</span><span class="variable">.height</span> * <span class="number">0.5</span>)];</span><br><span class="line">            [path closePath];</span><br><span class="line">            [path addClip];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画出裁剪范围</span></span><br><span class="line">    [image drawAtPoint:<span class="built_in">CGPointZero</span>];</span><br><span class="line">    <span class="comment">// 将当前上下文的内容转成图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="comment">// 关闭上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> newImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="长按截屏">长按截屏</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</spa]]>
    </summary>
    
      <category term="iOS中级" scheme="http://xionv.com/tags/iOS%E4%B8%AD%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[手势识别基本使用]]></title>
    <link href="http://xionv.com/2015/12/25/demonayu/blog/30.%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://xionv.com/2015/12/25/demonayu/blog/30.手势识别基本使用/</id>
    <published>2015-12-25T01:31:57.000Z</published>
    <updated>2016-01-11T08:28:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="UIGestureRecognizer手势识别">UIGestureRecognizer手势识别</h2><ul>
<li>UIGestureRecognizer是一个抽象类,定义了所有手势的基本行为,使用它的子类才能处理具体的手势.</li>
<li>利用UIGestureRecognizer,能轻松识别用户在某个view上面做的一些常见手势.</li>
<li>手势有以下几种:<ul>
<li>UITapGestureRecognizer(敲击)</li>
<li>UIPinchGestureRecognizer(捏合，用于缩放)</li>
<li>UIPanGestureRecognizer(拖拽)</li>
<li>UISwipeGestureRecognizer(轻扫)</li>
<li>UIRotationGestureRecognizer(旋转)</li>
<li>UILongPressGestureRecognizer(长按)</li>
</ul>
</li>
<li><p>手势使用方法:</p>
<ul>
<li><p>创建手势</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个拖动手势</span></span><br><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pan:)];</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加手势</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addGestureRecognizer:pan];</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现手势方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)pan:(<span class="built_in">UIPanGestureRecognizer</span> *)pan &#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>拖动的状态</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(pan<span class="variable">.state</span> == <span class="built_in">UIGestureRecognizerStateBegan</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"开始"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pan<span class="variable">.state</span> == <span class="built_in">UIGestureRecognizerStateChanged</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"移动"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pan<span class="variable">.state</span> == <span class="built_in">UIGestureRecognizerStateEnded</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"移开"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拖动状态复位</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复位 - 因为setTranslation会基于上一次的改变</span></span><br><span class="line">[pan setTranslation:<span class="built_in">CGPointZero</span> inView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>手势常用的代理方法</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否允许接收手指点击</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否允许同时支持多个手势 - 默认为NO</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="UIGestureRecognizer手势识别">UIGestureRecognizer手势识别</h2><ul>
<li>UIGestureRecognizer是一个抽象类,定义了所有手势的基本行为,使用它的子类才能处理具体的手势.</li>
<li>利用UIG]]>
    </summary>
    
      <category term="iOS初步" scheme="http://xionv.com/tags/iOS%E5%88%9D%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[事件处理]]></title>
    <link href="http://xionv.com/2015/12/24/demonayu/blog/29.%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://xionv.com/2015/12/24/demonayu/blog/29.事件处理/</id>
    <published>2015-12-24T14:12:57.000Z</published>
    <updated>2016-01-11T08:28:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="事件的产生和传递">事件的产生和传递</h2><ul>
<li>iOS当中常用的事件:<ul>
<li>触摸事件</li>
<li>加速计事件</li>
<li>远程控制事件</li>
</ul>
</li>
<li><p>处理事件的常用方法:</p>
<ul>
<li><p>触摸事件:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加速计事件:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">   - (<span class="keyword">void</span>)motionBegan:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)motionEnded:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)motionCancelled:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程控制事件:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>事件是怎么传递的?</p>
<ul>
<li>比如当发生一个触摸事件后,系统会将该事件加入到一个由UIApplication管理的事件队列中.</li>
<li>UIApplication会从事件队列中取出最前面的事件,并将事件分发下去以便处理.</li>
<li>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件.</li>
<li><strong>触摸事件的传递是从父控件传递到子控件的, 如果一个父控件不能接收事件,那么它里面的了子控件也不能够接收事件.</strong></li>
</ul>
</li>
<li>一个控件什么情况下不能够接收事件.<ul>
<li>不能与用户交互的时候<code>userInteractionEnabled = NO</code>.(注意:UIImageView默认是不可交互的)</li>
<li>隐藏的时候<code>Hidden = YES</code>.</li>
<li>颜色为全透明的时候<code>alpha = 0</code>.</li>
</ul>
</li>
</ul>
<h2 id="事件响应">事件响应</h2><ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程 后，会找到最合适的视图控件来处理这个事件,找到最合适的视图控件后,就会调用控件的touches方法来作具体的事件处理那这些touches方法的默认做法是将事件顺着响应者链条向上传递,将事件交给上一个响应者进行处理.</li>
<li>什么是响应者对象和响应者链条: <ul>
<li>继承了UIResponds的对象我们称它为响应者对象</li>
<li>UIApplication、UIViewController、UIView都继承自UIResponder,因此它们都是响应者对象，都能够接收并处理事件</li>
<li>响应者链条是由多个响应者对象连接起来的链条.</li>
</ul>
</li>
<li><p>响应者链的事件传递过程</p>
<ol>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图<ul>
<li>如果当前的View是控制器的View,那么控制器就是上一个响应者.</li>
<li>如果当前的View不是控制器的View,那么它的父控件就是上一个响应者.</li>
</ul>
</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃<br><img src="http://r5.loli.io/UR77V3.png" alt="响应者链条示意图"></li>
</ol>
</li>
<li><p>如何寻找最合适的view</p>
<ol>
<li>先判断自己是否能够接收触摸事件,如果能再继续往下判断,</li>
<li>再判断触摸的当前点在不在自己的身上.</li>
<li>如果在自己身上,它会从后往前遍历子控件,遍历出每一个子控件后,重复前面的两个步骤.</li>
<li>如果没有符合条件的子控件,那么它自己就是最适合的View.<br><img src="http://r6.loli.io/j26faq.png" alt=""></li>
</ol>
</li>
</ul>
<h2 id="事件传递的完整过程">事件传递的完整过程</h2><ol>
<li>以触摸事件为例,先将事件对象由上往下传递(由父控件传递给子控件),找到最合适的控件来处理这个事件.</li>
<li>调用最合适控件的<code>touches…</code>方法.</li>
<li>如果调用了<code>[super touches….]</code>就会将事件顺着响应者链条往上传递,传递给上一个响应者.</li>
<li>接着就会调用上一个响应者的<code>touches…</code>方法.</li>
</ol>
<h3 id="hitTest方法与pointInside方法">hitTest方法与pointInside方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用:寻找最适合的View.</span></span><br><span class="line"><span class="comment">// 参数:当前手指所在的点;产生的事件</span></span><br><span class="line"><span class="comment">// 返回值:返回谁, 谁就是最适合的View.</span></span><br><span class="line"><span class="comment">// 什么时候用调用:只要一个事件,传递给一个控件时,就会调用这个控件的hitTest方法</span></span><br><span class="line">-(<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用:判断point在不在方法调用者上</span></span><br><span class="line"><span class="comment">// point:必须是方法调用者的坐标系</span></span><br><span class="line"><span class="comment">// 什么时候调用:hitTest方法底层会调用这个方法,判断点在不在控件上.</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>模拟<code>hitTest:withEvent:</code>方法的底层实现(寻找最合适view)<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.判断自己能否接收事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.hidden</span> == <span class="literal">YES</span> || <span class="keyword">self</span><span class="variable">.alpha</span> &lt;= <span class="number">0.01</span> || <span class="keyword">self</span><span class="variable">.userInteractionEnabled</span> == <span class="literal">NO</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.触摸点是否在自己身上</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> pointInside:point withEvent:event]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.从后往前遍历子控件,看自己的子控制器是否是最适合的View.</span></span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)<span class="keyword">self</span><span class="variable">.subviews</span><span class="variable">.count</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">UIView</span> *childV = <span class="keyword">self</span><span class="variable">.subviews</span>[i];</span><br><span class="line">        <span class="comment">//判断自己子控件是否是最适合的view</span></span><br><span class="line">        <span class="comment">//point点必须得要跟方法调用者在同一个坐标系上.</span></span><br><span class="line">        <span class="comment">//把当前点转换成子控件坐标系上面的点.</span></span><br><span class="line">        <span class="built_in">CGPoint</span> childViewP = [<span class="keyword">self</span> convertPoint:point toView:childV];</span><br><span class="line">        <span class="built_in">UIView</span> *fitView = [childV hitTest:childViewP withEvent:event];</span><br><span class="line">        <span class="keyword">if</span> (fitView) &#123;</span><br><span class="line">            <span class="keyword">return</span> fitView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有比它更适合的View.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="监听UIView的触摸事件来实现拖拽:">监听UIView的触摸事件来实现拖拽:</h3><ul>
<li>想要监听UIViiew的触摸事件,首先第一步要自定义UIView,因为只有实现了UIResponder的事件方法才能够监听事件.</li>
<li><p>一次完整的触摸过程，会经历3个状态：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 1. 触摸开始</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 2. 触摸移动</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 3. 触摸结束</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 触摸取消（可能会经历,比如突然来电,手机自动关机）</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure>
<ul>
<li>一次完整的触摸过程中，只会产生一个事件对象，4个触摸方法都是同一个event参数.</li>
<li>如果两根手指同时触摸一个view，那么view只会调用一次<code>touchesBegan:withEvent:</code>方法，touches参数中装着2个UITouch对象.</li>
<li>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次<code>touchesBegan:withEvent:</code>方法，并且每次调用时的touches参数中只包含一个UITouch对象.</li>
</ul>
</li>
<li>举例: 实现UIview的拖拽<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">    - (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 拿到这个点</span></span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    <span class="comment">// 获得这个点的当前位置</span></span><br><span class="line">    <span class="built_in">CGPoint</span> currentP = [touch locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 获得这个点之前的位置</span></span><br><span class="line">    <span class="built_in">CGPoint</span> previousP = [touch previousLocationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 计算出偏移量 - 要移动的距离</span></span><br><span class="line">    <span class="built_in">CGFloat</span> distanceX = currentP<span class="variable">.x</span> - previousP<span class="variable">.x</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> distanceY = currentP<span class="variable">.y</span> - previousP<span class="variable">.y</span> ;</span><br><span class="line">    <span class="comment">// 改变view状态</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformTranslate</span>(<span class="keyword">self</span><span class="variable">.transform</span>, distanceX, distanceY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="事件的产生和传递">事件的产生和传递</h2><ul>
<li>iOS当中常用的事件:<ul>
<li>触摸事件</li>
<li>加速计事件</li>
<li>远程控制事件</li>
</ul>
</li>
<li><p>处理事件的常用方法:</p>
<ul>
]]>
    </summary>
    
      <category term="iOS初步" scheme="http://xionv.com/tags/iOS%E5%88%9D%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[直接修改对象frame结构体中的成员属性]]></title>
    <link href="http://xionv.com/2015/12/23/demonayu/blog/28.%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%B1%A1frame%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7/"/>
    <id>http://xionv.com/2015/12/23/demonayu/blog/28.直接修改对象frame结构体的成员属性/</id>
    <published>2015-12-23T04:36:57.000Z</published>
    <updated>2016-01-11T08:28:51.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>在iOS中系统默认不能直接修改结构体成员属性的值, 通过添加分类来实现这个功能.</p>
</blockquote>
<ul>
<li>头文件(.h)<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">Extension</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> x;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> y;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> centerX;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> centerY;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> width;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> height;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> size;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGPoint</span> origin;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>实现文件(.m)<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">  <span class="preprocessor">#import <span class="title">"UIView+Extension.h"</span></span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line">  - (<span class="keyword">void</span>)setX:(<span class="built_in">CGFloat</span>)x</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.origin</span><span class="variable">.x</span> = x;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="keyword">void</span>)setY:(<span class="built_in">CGFloat</span>)y</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.origin</span><span class="variable">.y</span> = y;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="built_in">CGFloat</span>)x</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.origin</span><span class="variable">.x</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="built_in">CGFloat</span>)y</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.origin</span><span class="variable">.y</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="keyword">void</span>)setCenterX:(<span class="built_in">CGFloat</span>)centerX</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> center = <span class="keyword">self</span><span class="variable">.center</span>;</span><br><span class="line">    center<span class="variable">.x</span> = centerX;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.center</span> = center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="keyword">void</span>)setCenterY:(<span class="built_in">CGFloat</span>)centerY</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> center = <span class="keyword">self</span><span class="variable">.center</span>;</span><br><span class="line">    center<span class="variable">.y</span> = centerY;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.center</span> = center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="built_in">CGFloat</span>)centerX</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.center</span><span class="variable">.x</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="built_in">CGFloat</span>)centerY</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.center</span><span class="variable">.y</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="keyword">void</span>)setWidth:(<span class="built_in">CGFloat</span>)width</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.size</span><span class="variable">.width</span> = width;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="keyword">void</span>)setHeight:(<span class="built_in">CGFloat</span>)height</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.size</span><span class="variable">.height</span> = height;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="built_in">CGFloat</span>)height</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="built_in">CGFloat</span>)width</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="keyword">void</span>)setSize:(<span class="built_in">CGSize</span>)size</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.size</span> = size;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="built_in">CGSize</span>)size</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="keyword">void</span>)setOrigin:(<span class="built_in">CGPoint</span>)origin</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.origin</span> = origin;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  - (<span class="built_in">CGPoint</span>)origin</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.origin</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>在iOS中系统默认不能直接修改结构体成员属性的值, 通过添加分类来实现这个功能.</p>
</blockquote>
<ul>
<li>头文件(.h)<figure class="highlight objc"><table><tr><td cla]]>
    </summary>
    
      <category term="iOS工具类与方法" scheme="http://xionv.com/tags/iOS%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSArray和NSDictionary控制台中文打印]]></title>
    <link href="http://xionv.com/2015/12/23/demonayu/blog/27.NSArray%E5%92%8CNSDictionary%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%87%E6%89%93%E5%8D%B0/"/>
    <id>http://xionv.com/2015/12/23/demonayu/blog/27.NSArray和NSDictionary控制台中文打印/</id>
    <published>2015-12-23T04:36:57.000Z</published>
    <updated>2016-01-11T08:28:51.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>使用方法: 在项目中新建一个.m文件将代码拷贝到文件中即可.</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSDictionary</span> (<span class="title">Log</span>)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)descriptionWithLocale:(<span class="keyword">id</span>)locale</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    [str appendString:<span class="string">@"&#123;\n"</span>];</span><br><span class="line">    <span class="comment">// 遍历字典的所有键值对</span></span><br><span class="line">    [<span class="keyword">self</span> enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        [str appendFormat:<span class="string">@"\t%@ = %@,\n"</span>, key, obj];</span><br><span class="line">    &#125;];</span><br><span class="line">    [str appendString:<span class="string">@"&#125;"</span>];</span><br><span class="line">    <span class="comment">// 查出最后一个,的范围</span></span><br><span class="line">    <span class="built_in">NSRange</span> range = [str rangeOfString:<span class="string">@","</span> options:<span class="built_in">NSBackwardsSearch</span>];</span><br><span class="line">    <span class="comment">// 删掉最后一个,</span></span><br><span class="line">    [str deleteCharactersInRange:range];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSArray</span> (<span class="title">Log</span>)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)descriptionWithLocale:(<span class="keyword">id</span>)locale</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    [str appendString:<span class="string">@"[\n"</span>];</span><br><span class="line">    <span class="comment">// 遍历数组的所有元素</span></span><br><span class="line">    [<span class="keyword">self</span> enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        [str appendFormat:<span class="string">@"%@,\n"</span>, obj];</span><br><span class="line">    &#125;];</span><br><span class="line">    [str appendString:<span class="string">@"]"</span>];</span><br><span class="line">    <span class="comment">// 查出最后一个,的范围</span></span><br><span class="line">    <span class="built_in">NSRange</span> range = [str rangeOfString:<span class="string">@","</span> options:<span class="built_in">NSBackwardsSearch</span>];</span><br><span class="line">    <span class="comment">// 删掉最后一个,</span></span><br><span class="line">    [str deleteCharactersInRange:range];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>使用方法: 在项目中新建一个.m文件将代码拷贝到文件中即可.</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class]]>
    </summary>
    
      <category term="iOS工具类与方法" scheme="http://xionv.com/tags/iOS%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[image与color之间互转]]></title>
    <link href="http://xionv.com/2015/12/23/demonayu/blog/26.image%E4%B8%8Ecolor%E4%B9%8B%E9%97%B4%E4%BA%92%E8%BD%AC/"/>
    <id>http://xionv.com/2015/12/23/demonayu/blog/26.image与color之间互转/</id>
    <published>2015-12-23T04:24:57.000Z</published>
    <updated>2016-01-11T08:28:51.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>颜色转图片, 集成到UIImage分类<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithColor:(<span class="built_in">UIColor</span> *)color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 描述矩形</span></span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">1.0</span>f);</span><br><span class="line">    <span class="comment">// 开启位图上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(rect<span class="variable">.size</span>);</span><br><span class="line">    <span class="comment">// 获取位图上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">// 使用color演示填充上下文</span></span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, color<span class="variable">.CGColor</span>);</span><br><span class="line">    <span class="comment">// 渲染上下文</span></span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(context, rect);</span><br><span class="line">    <span class="comment">// 从上下文中获取图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *theImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="comment">// 结束上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> theImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>图片转颜色<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> colorWithPatternImage:image];</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>颜色转图片, 集成到UIImage分类<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UII]]>
    </summary>
    
      <category term="iOS工具类与方法" scheme="http://xionv.com/tags/iOS%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIAlertView在IOS9中的使用demo]]></title>
    <link href="http://xionv.com/2015/12/23/demonayu/blog/24.UIAlertView%E5%9C%A8IOS9%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xionv.com/2015/12/23/demonayu/blog/24.UIAlertView在IOS9中的使用/</id>
    <published>2015-12-23T02:37:57.000Z</published>
    <updated>2016-01-11T08:28:51.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>iOS9中改变了UIAlertView的使用方式, 并且与UIActionSheet融合进了一个类里面,统一进行管理.</p>
</blockquote>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 注销</span></span><br><span class="line">- (<span class="keyword">void</span>)loginOut</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建一个alertController来管理警示窗口, 并指定样式</span></span><br><span class="line">    <span class="built_in">UIAlertController</span> *alertController = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@"确定注销吗?"</span> message:<span class="literal">nil</span> preferredStyle:<span class="built_in">UIAlertControllerStyleActionSheet</span>];</span><br><span class="line">    <span class="comment">// 2.创建点击行为, 在block中实现事件</span></span><br><span class="line">    <span class="built_in">UIAlertAction</span> *action = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"确定"</span> style:<span class="built_in">UIAlertActionStyleDestructive</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.navigationController</span> popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"已注销"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">UIAlertAction</span> *cancel = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"取消"</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"取消注销"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 3.为alertController添加点击行为</span></span><br><span class="line">    [alertController addAction:action];</span><br><span class="line">    [alertController addAction:cancel];</span><br><span class="line">    <span class="comment">// 4.弹出警示窗口</span></span><br><span class="line">    [<span class="keyword">self</span> presentViewController:alertController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>iOS9中改变了UIAlertView的使用方式, 并且与UIActionSheet融合进了一个类里面,统一进行管理.</p>
</blockquote>
 <figure class="highlight objc"><table><tr><td]]>
    </summary>
    
      <category term="iOS初步-demo" scheme="http://xionv.com/tags/iOS%E5%88%9D%E6%AD%A5-demo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[KVC的底层实现]]></title>
    <link href="http://xionv.com/2015/12/22/demonayu/blog/25.KVC%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://xionv.com/2015/12/22/demonayu/blog/25.KVC的底层实现/</id>
    <published>2015-12-22T11:37:57.000Z</published>
    <updated>2016-01-11T08:28:51.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>KVC的本质就是调用成员属性的setter和getter方法.</p>
</blockquote>
<ul>
<li><code>setValuesForKeysWithDictionary:</code>方法的底层实现  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历字典给对应模型的成员属性赋值(key值就是成员属性名)</span></span><br><span class="line">  [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull obj, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">      [item setValue:obj forKeyPath:key];</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>setValue:forKeyPath:</code>的底层实现:<ol>
<li>调用key对应成员属性名的setter方法;</li>
<li>如果找不到,找带下划线(_)的成员属性名,然后给这个成员属性直接赋值.</li>
<li>如果找不到,找与key名完全相同的成员属性名,然后直接赋值.</li>
<li>如果都找不到,则程序崩溃,报错找不到对应的成员属性.</li>
</ol>
</li>
</ul>
<p>ps: 可以利用KVC的实现原理来重写赋值过程</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>KVC的本质就是调用成员属性的setter和getter方法.</p>
</blockquote>
<ul>
<li><code>setValuesForKeysWithDictionary:</code>方法的底层实现  <figure clas]]>
    </summary>
    
      <category term="iOS概念" scheme="http://xionv.com/tags/iOS%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
</feed>
