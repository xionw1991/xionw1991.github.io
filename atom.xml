<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xion&#39;s Blog</title>
  
  <subtitle>Feelings of life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xionw1991.github.io/"/>
  <updated>2020-06-24T02:48:13.535Z</updated>
  <id>https://xionw1991.github.io/</id>
  
  <author>
    <name>Xion</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux文件目录解释</title>
    <link href="https://xionw1991.github.io/2018/02/22/blog/47.Linux%E7%9B%AE%E5%BD%95%E8%A7%A3%E9%87%8A/"/>
    <id>https://xionw1991.github.io/2018/02/22/blog/47.Linux%E7%9B%AE%E5%BD%95%E8%A7%A3%E9%87%8A/</id>
    <published>2018-02-22T08:08:57.000Z</published>
    <updated>2020-06-24T02:48:13.535Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://www.debianadmin.com/linux-directory-structure-overview.html" target="_blank" rel="noopener">Linux Directory Structure Overview</a></p><h2 id="Linux和Windows的区别"><a href="#Linux和Windows的区别" class="headerlink" title="Linux和Windows的区别"></a>Linux和Windows的区别</h2><p>显著区别之一就是其不同的目录结构，并不仅仅是格式上的不同，而是不同位置上保存的东西区别很大。</p><p>在Windows中，典型的路径可能是这样的<code>D:\Folder\subfolder\file.txt</code>，而在Linux中，路径则是这样的<code>/Folder/subfolder/file.txt</code>。</p><p>斜线倾斜的方向不同，并且，在Linux中，也没有C盘D盘的概念，Linux系统启动之后，<code>根分区</code>就”挂载”在了在了<code>/</code>的位置，并且所有的文件、文件夹、设备以及不同的硬盘光驱之类的，也都挂载在了<code>/</code>。</p><p>虽然可能在下面这个例子中并不明显，但是Linux系统对文件或者文路径的名称中的大小写字符是敏感的。</p><p>比如<code>/Folder/subfolder/file.txt</code>与<code>/folder/subfolder/file.txt</code>并不是同一个文件。</p><h2 id="Linux系统目录说明"><a href="#Linux系统目录说明" class="headerlink" title="Linux系统目录说明"></a>Linux系统目录说明</h2><p>Unix中和Linux的目录结构是一个统一的目录结构，所有的目录和文件最终都统一到”/“根文件系统下。文件系统是无论是不是挂载过来的，最终都分层排列到以”/“为起始的文件系统之下。<br>Linux目录结构遵循”文件系统层次结构（Filesystem Hierarchy Structure，FHS)”，这标准是由”自由标准组织（Free Standards Group）”进行维护的，然而大多数LINUX发行版都有意或者无意的与这一规范背离。</p><p>“/“ 根路径</p><p>这是Linux系统的”根”目录，也是所有目录结构的最底层。在UNIX以及和它兼容的系统中，”/“是一个单独的目录。</p><p>/boot</p><p>这个目录下包含系统启动文件（boot loader），例如Grub，Lilo或者Kernel，以及initrd，system.map等配置文件。</p><blockquote><p>Initrd ramdisk或者”initrd”是指一个临时文件系统，它在启动阶段被Linux内核调用。initrd主要用于当”根”文件系统被挂载之前，进行准备工作。</p></blockquote><p>/sys</p><p>这个目录下包含内核、固件以及系统相关文件。</p><p>/sbin</p><p>包含系统操作和运作所必需的二进制文件以及管理工具，主要就是可执行文件。类似WINDOWS下的EXE文件。</p><p>/bin</p><p>包含单用户模式下的二进制文件以及工具程序，比如cat，ls，cp这些命令。</p><p>/lib</p><p>包含/sbin和/bin目录下二进制文件运行所需要的库文件。</p><p>/dev</p><p>内含必需的系统文件和驱动器。</p><p>/etc</p><p>内含系统配置文件，其下的目录，比如 /etc/hosts, /etc/resolv.conf, nsswitch.conf, 以及系统缺省设置，网络配置文件等等。以及一些系统和应用程序的配置文件。</p><p>/home</p><p>每一个用户的在这个目录下，都会单独有一个以其用户名命令的目录，在这里保存着用户的个人设置文件，尤其是以 profile结尾的文件。但是也有例外，root用户的数据就不在这个目录中，而是单独在根路径下，保存在单独的/root文件夹下。</p><p>/media</p><p>一个给所有可移动设备比如光驱、USB外接盘、软盘提供的常规挂载点。</p><p>/mnt</p><p>临时文件系统挂载点。比如，你并不想长期挂载某个驱动器，而是只是临时挂载一会U盘烤个MP3之类的，那么应该挂载在这个位置下。</p><p>/opt</p><p>在Linux系统中，这个目录用到的并不多，opt是 可选系统程序包（Optional Software Packages）的简称。这个目录在UNIX系统，如Sun Solaris用途要广泛的多。</p><p>/usr</p><p>用户数据目录，包含了属于用户的实用程序和应用程序。这里有很多重要的，但并非关键的文件系统挂载这个路径下面。在这里，你会重新找到一个 bin、sbin 和 lib目录，其中包含非关键用户和系统二进制文件以及相关的库和共享目录，以及一些库文件。</p><p>/usr/sbin</p><p>包含系统中非必备和并不是特别重要的系统二进制文件以及网络应用工具。</p><p>/usr/bin</p><p>包含用户的非必备和并不是特别重要的二进制文件。</p><p>/usr/lib</p><p>保存着/usr/sbin以及/usr/bin中二进制文件所需要的库文件。</p><p>/usr/share</p><p>“平台无关”的共享数据目录。</p><p>/usr/local</p><p>是/usr下的二级目录，这里主要保存着包含系统二进制文件以及运行库在内的本地系统数据。</p><p>/var</p><p>这个路径下通常保存着包括系统日志、打印机后台文件（spool files）、定时任务（crontab）、邮件、运行进程、进程锁文件等。这个目录尤其需要注意进行日常的检查和维护，因为这个目录下文件的大小可能会增长很快，以致于很快占满硬盘，然后导致系统便会出现各种奇奇怪怪的问题。</p><p>/tmp</p><p>顾名思义，这是一个临时文件夹，专门用来保存临时文件，每次系统重启之后，这个目录下的”临时”文件便会被清空。同样，/var/tmp 也同样保存着临时文件。两者唯一的不同是，后者 /var/tmp目录保存的文件会受到系统保护，系统重启之后这个目录下的文件也不会被清空。</p><p>/proc</p><p>这个目录是驻留在系统内存中的虚拟（psuedo，伪）文件系统，其中保存的都是文本格式的系统内核和进程信息。</p><h2 id="LINUX系统目录结构图"><a href="#LINUX系统目录结构图" class="headerlink" title="LINUX系统目录结构图"></a>LINUX系统目录结构图</h2><p><img src="http://www.wuliaole.com/post/directory_introduction_in_linux_or_raspbian/ldr.png" alt=""></p><blockquote><p>需要注意的是，不同LINUX发行版本的目录结构会有一些差异，这对LINUX新手来说比较纠结，但是大体上，所以LINUX的不同发行版本，都符合上面这幅图片中的路径结构。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;http://www.debianadmin.com/linux-directory-structure-overview.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux Directory Structur
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://xionw1991.github.io/tags/Linux/"/>
    
      <category term="目录结构" scheme="https://xionw1991.github.io/tags/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>使swift代码更简洁</title>
    <link href="https://xionw1991.github.io/2018/02/05/blog/46.%E4%BD%BFswift%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%AE%80%E6%B4%81/"/>
    <id>https://xionw1991.github.io/2018/02/05/blog/46.%E4%BD%BFswift%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%AE%80%E6%B4%81/</id>
    <published>2018-02-05T03:19:57.000Z</published>
    <updated>2020-06-23T15:09:45.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="swiftLint"><a href="#swiftLint" class="headerlink" title="swiftLint"></a><a href="https://github.com/realm/SwiftLint" target="_blank" rel="noopener">swiftLint</a></h2><p>功能与 eslint、pylint 一致，用来约束编码习惯，统一项目的代码风格，不符合规范的代码行有警告提示。第一次使用需要配置，使用后对编码习惯会有很大的改善。</p><h2 id="swiftformat"><a href="#swiftformat" class="headerlink" title="swiftformat"></a><a href="https://github.com/nicklockwood/SwiftFormat" target="_blank" rel="noopener">swiftformat</a></h2><p>这个就是单纯进行代码格式化，能让代码看起来更整洁，命令行使用，风格可以自定义，不过我觉得直接使用作者写好的模式就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;swiftLint&quot;&gt;&lt;a href=&quot;#swiftLint&quot; class=&quot;headerlink&quot; title=&quot;swiftLint&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/realm/SwiftLint&quot; target=&quot;_blank
      
    
    </summary>
    
    
    
      <category term="swift" scheme="https://xionw1991.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS使用底层socket</title>
    <link href="https://xionw1991.github.io/2017/11/03/blog/45.iOS%E4%BD%BF%E7%94%A8%E5%BA%95%E5%B1%82%E7%9A%84socket/"/>
    <id>https://xionw1991.github.io/2017/11/03/blog/45.iOS%E4%BD%BF%E7%94%A8%E5%BA%95%E5%B1%82%E7%9A%84socket/</id>
    <published>2017-11-03T03:19:57.000Z</published>
    <updated>2020-06-23T15:09:49.440Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="iOS 网络编程" scheme="https://xionw1991.github.io/tags/iOS-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>通用链接debug</title>
    <link href="https://xionw1991.github.io/2016/12/07/blog/44.%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5debug/"/>
    <id>https://xionw1991.github.io/2016/12/07/blog/44.%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5debug/</id>
    <published>2016-12-07T03:19:57.000Z</published>
    <updated>2020-06-23T15:14:33.544Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://building.usebutton.com/debugging/ios/deep-linking/links/universal-links/2016/03/31/debugging-universal-links/" target="_blank" rel="noopener">http://building.usebutton.com/debugging/ios/deep-linking/links/universal-links/2016/03/31/debugging-universal-links/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;http://building.usebutton.com/debugging/ios/deep-linking/links/universal-links/2016/03/31/debugging-universal-links/&quot; targe
      
    
    </summary>
    
    
    
      <category term="iOS开发笔记" scheme="https://xionw1991.github.io/tags/iOS%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>在iOS10接入https的坑</title>
    <link href="https://xionw1991.github.io/2016/09/04/blog/43.%E5%9C%A8iOS10%E4%B8%8B%E6%8E%A5%E5%85%A5https%E7%9A%84%E5%9D%91/"/>
    <id>https://xionw1991.github.io/2016/09/04/blog/43.%E5%9C%A8iOS10%E4%B8%8B%E6%8E%A5%E5%85%A5https%E7%9A%84%E5%9D%91/</id>
    <published>2016-09-04T06:09:57.000Z</published>
    <updated>2020-06-23T15:14:57.574Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从2017年1月1日开始，苹果将要求所有上传的应用必须使用https接口进行数据访问，这里面有些坑让我们来研究一下；</p></blockquote><h2 id="新https政策"><a href="#新https政策" class="headerlink" title="新https政策"></a>新https政策</h2><ul><li>一句话概括：从2017年的元旦起，苹果将继续收紧应用对http的访问权限，要求开发者统一使用https进行数据访问，iOS8及更早的版本不受影响。</li><li>新规下，作为服务器的API是肯定是要使用https的，访问网页则有点特殊，因为ATS影响到<code>NSURLSession</code>和<code>UIWebView</code>，所以理论上使用webview访问的网页也必须是https，但这样显然不现实，所以苹果在iOS10添加了新key<code>NSAllowsArbitraryLoadsInWebContent</code>来容许访问未加密的网页。但是这个key在iOS9下并不起作用，这样尴尬了：上传的应用不容许使用<code>NSAllowsArbitraryLoads</code>来绕过ATS，而在应用中又需要访问http网页，怎么办？</li></ul><h2 id="App-Transport-Security"><a href="#App-Transport-Security" class="headerlink" title="App Transport Security"></a>App Transport Security</h2><p>我们先来看看ATS的要求：</p><pre><code>The server certificate must meet at least one of the following trust requirements:    Issued by a certificate authority (CA) whose root certificate is incorporated into the operating system    Issued by a trusted root CA and installed by the user or a system administratorThe negotiated Transport Layer Security version must be TLS 1.2The negotiated TLS connection cipher suite must support forward secrecy (FS) and be one of the following:    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHAThe leaf server certificate must be signed with one of the following types of keys:    Rivest-Shamir-Adleman (RSA) key with a length of at least 2048 bits    Elliptic-Curve Cryptography (ECC) key with a size of at least 256 bitsIn addition, the leaf server certificate hashing algorithm must be Secure Hash Algorithm 2 (SHA-2) with a digest length of at least 256 (that is, SHA-256 or greater).</code></pre><p>大白话的就是：</p><ul><li>服务器证书必须至少满足以下条件中的一个<ul><li>颁发给服务器证书的证书机构（CA）的根证书必须是内置于操作系统的<a href="https://support.apple.com/zh-cn/HT205205" target="_blank" rel="noopener">受信任根证书</a>；</li><li>受用户或者系统管理员信任并安装到操作系统上的；</li></ul></li><li>服务器TLS版本至少是1.2版本；</li><li>连接加密方式必须支持下列正向加密的一种；</li><li>证书必须使用SHA256或者更好的哈希算法进行签名，要么是2048位或者更长的RSA密钥，要么就是256位或更长的ECC密钥；</li></ul><p>其实在这一层客户端所做的事情不多，当https服务器满足ATS默认的条件，而且SSL证书是通过权威的CA机构认证过的，客户端直接接入就可以了正常通信了（后台的兄弟们辛苦了）。<br><br>搭建完成后可以使用命令行来测试是否满足ATS要求：<code>nscurl --ats-diagnostics --verbose https://google.com</code>。</p><h2 id="ATS设定"><a href="#ATS设定" class="headerlink" title="ATS设定"></a>ATS设定</h2><ul><li>NSAllowsArbitraryLoads<ul><li>在Xcode7中这个key值默认为NO，我们将它设置为YES来访问任意接口，但是苹果新规出来后将限制这个key的使用，设置这个key值需要在应用审核的时候说明原因，能不能过还要看审核员的脸色；</li></ul></li><li>NSAllowsArbitraryLoadsInWebContent<ul><li>这是iOS10在ATS中新增加的key，目的是方便使用webview框架的应用在应用内访问http网页，这个key仅在iOS10起作用；</li></ul></li><li>NSExceptionDomains<ul><li>这个key值可以让开发者更加灵活的配置让哪些接口遵不遵守ATS的要求，具体设置方法可以参考：<a href="https://github.com/ChenYilong/iOS9AdaptationTips#how如何适配---弱弱地问下加班要多久" target="_blank" rel="noopener">NSExceptionDomains</a>；</li></ul></li><li>在iOS10下同时设置<code>NSAllowsArbitraryLoads</code>和<code>NSAllowsArbitraryLoadsInWebContent</code>，前者会失效，所以在iOS10下使用<code>NSAllowsArbitraryLoadsInWebContent</code>就意味着除了网页浏览，其他所有的连接都必须是https的；</li><li>在iOS9下仅设置<code>NSAllowsArbitraryLoads</code>有效，如果设置为YES则在审核时需要说明原因，如果为NO，则表示所有的连接必须是符合ATS的要求的，包括网页浏览；如果app内部使用webview访问的页面都是固定的域名，可以通过设置<code>NSExceptionDomains</code>白名单在不禁用ATS的情况下进行访问；</li><li>以下是整理出来的表格：<br>  <img src="http://ww3.sinaimg.cn/large/0060lm7Tgw1f7hp9c0t2aj314a0q2n5a.jpg" alt=""></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>回到第一个问题：怎么在不禁用ATS的情况下使用webview访问http网页？<br><br>答：在iOS10使用<code>NSAllowsArbitraryLoadsInWebContent</code>来对网页内容禁用ATS，在iOS9使用<code>NSExceptionDomains</code>白名单形式让特定的域名绕过ATS规则，注意如果白名单的网页使用了其他的资源，比如一些图床，则需要将相关的域名也要添加进白名单。目前还不得知苹果对<code>NSExceptionDomains</code>的审核标准，猜测如果在上传应用时说明是webview访问一些第三方的http资源应该会比较容易过审。<br><img src="http://ww1.sinaimg.cn/large/0060lm7Tgw1f7hsq1ggncj30ro076jtw.jpg" alt=""></p><p>参考：<a href="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33" target="_blank" rel="noopener">苹果官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;从2017年1月1日开始，苹果将要求所有上传的应用必须使用https接口进行数据访问，这里面有些坑让我们来研究一下；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;新https政策&quot;&gt;&lt;a href=&quot;#新https政策&quot; class=&quot;he
      
    
    </summary>
    
    
    
      <category term="iOS开发笔记" scheme="https://xionw1991.github.io/tags/iOS%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>处理URL的几种思路</title>
    <link href="https://xionw1991.github.io/2016/08/06/blog/42.%E5%A4%84%E7%90%86URL%E6%8B%BC%E6%8E%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://xionw1991.github.io/2016/08/06/blog/42.%E5%A4%84%E7%90%86URL%E6%8B%BC%E6%8E%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2016-08-06T09:51:57.000Z</published>
    <updated>2020-06-23T15:15:29.147Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在日常开发中，总会碰到需要在客户端对 URL 进行一些处理。这里就列举了三个处理 URL 的方式，灵活度逐渐提高。 </p></blockquote><h2 id="直接对-URL-字符串进行修改"><a href="#直接对-URL-字符串进行修改" class="headerlink" title="直接对 URL 字符串进行修改"></a>直接对 URL 字符串进行修改</h2><p>第一种是马上能够想到的方法，直接将得到的 URL 转成 string 来进行操作，比如添加参数，直接将参数名和参数值写死成 <code>key=value</code> 的形式拼接到原有的 URL 上，这里有两点要注意：</p><ol><li>注意格式，需要判断原有的 URL 是否已经带了参数，来决定使用哪个分隔符号 <code>?</code> 还是 <code>&amp;</code>； <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断url是否已经有参数 </span></span><br><span class="line"><span class="keyword">if</span> ([newUrlStr isMatchedByRegex:<span class="string">@"[\\s\\S]+?[\?][\\s\\S]+?"</span>]) </span><br><span class="line">&#123;</span><br><span class="line">    newUrlStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@&amp;%@"</span>, newUrlStr, param];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    newUrlStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@?%@"</span>, newUrlStr, param];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>需要判断带拼接的参数是否已经在 URL 中存在，如果存在则需要忽略掉； <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([url rangeOfString:paramName].location != <span class="built_in">NSNotFound</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>同样也有两点不方便：</p><ol><li>当遇到相同的参数时需要更新参数值就有些麻烦了，要在字符串中找出目标参数所在的范围然后将其替换；</li><li>直接操作字符串容易手抖写错，而且写错不好排查；</li></ol><h2 id="将-URL-解析成-dictionary-进行修改"><a href="#将-URL-解析成-dictionary-进行修改" class="headerlink" title="将 URL 解析成 dictionary 进行修改"></a>将 URL 解析成 dictionary 进行修改</h2><p>将 URL 的参数部分提取出来打散拆分成键值对存进字典中，然后把待拼接的参数也以字典的形式与原有的参数进行比对。最后组成一个新的字典，把里面的键值重组排列成参数字符串拼接到 URL 的 path 后面。这种方法需要注意的是，防止字典写空值，和注意拼接格式。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.将原始 query 转化为字典保存</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *paramsDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="built_in">NSArray</span> *paramsString = [url.query componentsSeparatedByString:<span class="string">@"&amp;"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *paramStr <span class="keyword">in</span> paramsString) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *tempArray = [paramStr componentsSeparatedByString:<span class="string">@"="</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *key = tempArray.firstObject;</span><br><span class="line">    <span class="built_in">NSString</span> *value = tempArray.lastObject;</span><br><span class="line">    [paramsDict setObject:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.拼接新参数，如果相同参数则更新值，没有相同参数则添加</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> newParamsDict.allKeys)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> value = [newParamsDict objectForKey:key];</span><br><span class="line">    [paramsDict setObject:key forKey:value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将参数字典重组为新的 query </span></span><br><span class="line">__block <span class="built_in">NSString</span> *newQuery = <span class="string">@""</span>;</span><br><span class="line">[paramsDict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull obj, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *param = <span class="string">@""</span>;</span><br><span class="line">    <span class="keyword">if</span> (newQuery.length == <span class="number">0</span>) <span class="comment">// 第一个参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        param = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"?%@=%@"</span>, [key description], [obj description]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        param = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&amp;%@=%@"</span>, [key description], [obj description]];</span><br><span class="line">    &#125;</span><br><span class="line">    newQuery = [newQuery stringByAppendingString:param];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这种方式比第一种要更加灵活的处理参数的变化，其实系统已经给了我们一种解决方案，简化了上述方式的转化工作，看下一种解决方案。</p><h2 id="使用-NSURLComponents-类来组合参数"><a href="#使用-NSURLComponents-类来组合参数" class="headerlink" title="使用 NSURLComponents 类来组合参数"></a>使用 NSURLComponents 类来组合参数</h2><p>NSURLComponents 是系统用来分解 URL 的一个类，它可以将原始的 URL 参数部分分解成一个参数数组。 NSURLQueryItem 就是这个数组中存储的对象，这个对象的 name 和 value 属性，对应着每个参数的键和值，我们可以通过遍历这个数组来添加和删除参数，最后将修改过后的参数数组重新赋值给 NSURLComponents 生成新的 URL。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用URL初始化</span></span><br><span class="line"><span class="built_in">NSURLComponents</span> *urlComponent = [<span class="built_in">NSURLComponents</span> componentsWithURL:url resolvingAgainstBaseURL:<span class="literal">NO</span>];</span><br><span class="line"><span class="comment">// 新的query数组</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *newQureyItems = [urlComponent.queryItems mutableCopy];</span><br><span class="line"><span class="comment">// newParams是待拼接的参数数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURLQueryItem</span> *itemNew <span class="keyword">in</span> newParams)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 是否存在相同参数的标识位</span></span><br><span class="line">    <span class="built_in">BOOL</span> hasParam = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSURLQueryItem</span> *itemOld <span class="keyword">in</span> urlComponent.queryItems)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ([itemOld.name isEqualToString:itemNew.name])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果存在相同的参数则更新</span></span><br><span class="line">            [newQureyItems replaceObjectAtIndex:[newQureyItems indexOfObject:itemOld] withObject:itemNew];</span><br><span class="line">            hasParam = <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!hasParam)</span><br><span class="line">    &#123;</span><br><span class="line">        [newQureyItems addObject:itemNew];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取到新的query</span></span><br><span class="line">urlComponent.queryItems = newQureyItems;</span><br></pre></td></tr></table></figure><p>这种方式最大的好处就是不用我们自己来解析 URL 和拼参了，系统已经做好了这些繁琐的事情，剩下的只需要我们来修改这些值就可以了。</p><hr><p>以上就是三种拼接 URL 参数的方法，在经过性能测试也没有发现很大差距，最大的区别就在与灵活性和易用性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在日常开发中，总会碰到需要在客户端对 URL 进行一些处理。这里就列举了三个处理 URL 的方式，灵活度逐渐提高。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;直接对-URL-字符串进行修改&quot;&gt;&lt;a href=&quot;#直接对-URL-字符串进
      
    
    </summary>
    
    
    
      <category term="iOS开发笔记" scheme="https://xionw1991.github.io/tags/iOS%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Github, Gitcafe和 Coding的Pages服务对比</title>
    <link href="https://xionw1991.github.io/2015/12/14/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%9B%BD%E5%86%85%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E7%BD%91%E7%AB%99/"/>
    <id>https://xionw1991.github.io/2015/12/14/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%9B%BD%E5%86%85%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E7%BD%91%E7%AB%99/</id>
    <published>2015-12-14T04:01:57.000Z</published>
    <updated>2020-06-23T15:12:38.260Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>GitHub/GitCafe/Coding的Pages服务<br> 因为之前博客放在github上, 有时候网络不稳定访问很慢,并且push的时候要等很久,甚至直接push失败, 借昨天放假休息正好可以认真搞一搞博客的部署.<br> 把线路迁移到国内有几个比较流行的代码托管网站,比如gitcafe和coding. gitcafe可以自定义域名,但最近好像不太稳定,在我部署的当天就宕机了,而且到今天数据还不能更新;coding速度很快,一键部署非常方便(运行环境要选择html),但是这个网站默认不支持自定义域名,当然成为付费用户可以选择香港线路来自定义域名,还有在代码上传后需要手动点击一键部署来更新文档, 也可以参照官方的帮助文档设定自动更新<a href="http://static-site.coding.io" target="_blank" rel="noopener">Coding 云端演示平台静态网站部署指南</a>.</p></li><li><p>说说心得:</p><ul><li>github: 稳定,除了网络抽风push的时候有点慢和国内的搜索引擎可能爬不到,其他完美仍然是首选.</li><li>gitcafe: 据说服务器在香港,相比github访问速度要快一些,但是最近很不稳定,比如昨天就宕机了很久,导致博客打不开,之后push上去的新内容不能及时更新.不知道是不是我昨天运气不好,等稳定了再说.</li><li>coding: 速度快,而且界面友好,但是不支持免费自定义域名,需要花钱办会员,对于没有绑定域名需求的朋友还是很推荐的.</li></ul></li><li><p>最后: 我还是推荐把github作为主站,然后把gitcafe作为镜像用于国内的搜索引擎去收入(使用dnspods把gitcafe.io解析为搜索引擎线路).coding作为备份网站,当前面两个网站打不开的时候救急.</p><blockquote><p>最后的最后, 生命止于折腾.</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;GitHub/GitCafe/Coding的Pages服务&lt;br&gt; 因为之前博客放在github上, 有时候网络不稳定访问很慢,并且push的时候要等很久,甚至直接push失败, 借昨天放假休息正好可以认真搞一搞博客的部署.&lt;br&gt; 把线路迁移到国内有几个
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://xionw1991.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>升级Xcode后插件失效的解决办法</title>
    <link href="https://xionw1991.github.io/2015/12/10/blog/Xcode%E6%8F%92%E4%BB%B6%E5%A4%B1%E6%95%88%E5%90%8E%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://xionw1991.github.io/2015/12/10/blog/Xcode%E6%8F%92%E4%BB%B6%E5%A4%B1%E6%95%88%E5%90%8E%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2015-12-10T07:21:01.000Z</published>
    <updated>2016-08-02T08:19:49.000Z</updated>
    
    <content type="html"><![CDATA[<p> 1.打开终端，输入以下代码获取到DVTPlugInCompatibilityUUID:<br>    <code>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID</code></p><p> 2.然后输入如下命令(最后一项是获取到的DVTPlugInCompatibilityUUID):<br>    <code>find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add F41BD31E-2683-44B8-AE7F-5F09E919790E</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 1.打开终端，输入以下代码获取到DVTPlugInCompatibilityUUID:&lt;br&gt;    &lt;code&gt;defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID&lt;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://xionw1991.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>图片折叠小demo</title>
    <link href="https://xionw1991.github.io/2015/12/04/blog/41.%E5%9B%BE%E7%89%87%E6%8A%98%E5%8F%A0%E5%B0%8Fdemo/"/>
    <id>https://xionw1991.github.io/2015/12/04/blog/41.%E5%9B%BE%E7%89%87%E6%8A%98%E5%8F%A0%E5%B0%8Fdemo/</id>
    <published>2015-12-04T14:40:57.000Z</published>
    <updated>2020-06-23T16:12:35.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用图层特性实现图片折叠的效果"><a href="#利用图层特性实现图片折叠的效果" class="headerlink" title="利用图层特性实现图片折叠的效果"></a>利用图层特性实现图片折叠的效果</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> imageWH 200.0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIImageView</span> *imageTop;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIImageView</span> *imageBottom;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">CAGradientLayer</span> *gradient;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化图片</span></span><br><span class="line">    [<span class="keyword">self</span> setupImageView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 初始化图片 */</span></span><br><span class="line">- (<span class="keyword">void</span>)setupImageView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建一个透明的蒙版作为手势的接受者 */</span></span><br><span class="line">    <span class="built_in">UIView</span> *cover = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    cover.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, imageWH, imageWH);</span><br><span class="line">    cover.center = <span class="keyword">self</span>.view.center;</span><br><span class="line">    cover.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">    <span class="comment">// 添加pan手势</span></span><br><span class="line">    <span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pan:)];</span><br><span class="line">    [cover addGestureRecognizer:pan];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:cover];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 添加图片 - 原图片添加两次,分别显示上下部分 */</span></span><br><span class="line">    <span class="comment">// 上半部图片</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *imageTop = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">    imageTop.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">50</span>, imageWH, imageWH * <span class="number">0.5</span>);</span><br><span class="line">    imageTop.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"知道错了"</span>];</span><br><span class="line">    <span class="comment">// 修改layer的contentsRect只显示显示图片的上半部</span></span><br><span class="line">    imageTop.layer.contentsRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 修改锚点Y值为图片的高度</span></span><br><span class="line">    imageTop.layer.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">    _imageTop = imageTop;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下半部图片</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *imageBottom = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">    imageBottom.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">50</span>, imageWH, imageWH * <span class="number">0.5</span>);</span><br><span class="line">    imageBottom.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"知道错了"</span>];</span><br><span class="line">    <span class="comment">// 修改layer的contentsRect只显示显示图片的下半部</span></span><br><span class="line">    imageBottom.layer.contentsRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 修改锚点Y值为0</span></span><br><span class="line">    imageBottom.layer.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">    _imageBottom = imageBottom;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 给下半部图片添加阴影效果 */</span></span><br><span class="line">    <span class="comment">// 创建一个渐变层用来显示阴影效果</span></span><br><span class="line">    <span class="built_in">CAGradientLayer</span> *gradient = [<span class="built_in">CAGradientLayer</span> layer];</span><br><span class="line">    _gradient = gradient;</span><br><span class="line">    <span class="comment">// 设置图层的位置</span></span><br><span class="line">    gradient.frame = imageBottom.bounds;</span><br><span class="line">    <span class="comment">// 设置渐变颜色</span></span><br><span class="line">    gradient.colors = @[(<span class="keyword">id</span>)[<span class="built_in">UIColor</span> clearColor].CGColor, (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> blackColor].CGColor];</span><br><span class="line">    <span class="comment">// 设置不透明度</span></span><br><span class="line">    gradient.opacity = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 给下半部图片添加图层</span></span><br><span class="line">    [imageBottom.layer addSublayer:gradient];</span><br><span class="line">    </span><br><span class="line">    [cover addSubview:imageBottom];</span><br><span class="line">    [cover addSubview:imageTop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 监听pan手势 */</span></span><br><span class="line">- (<span class="keyword">void</span>)pan:(<span class="built_in">UIPanGestureRecognizer</span> *)pan</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得手指偏移量的Y值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> offsetY = [pan translationInView:<span class="keyword">self</span>.view].y;</span><br><span class="line">    <span class="comment">// 将偏移量转成旋转弧度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> angle = offsetY * M_PI / imageWH;</span><br><span class="line">    <span class="keyword">if</span> (angle &gt; M_PI) &#123;</span><br><span class="line">        angle = M_PI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置透视效果 - 除数值越大透视效果越不明显(可以理解成眼睛看到物体的距离)</span></span><br><span class="line">    <span class="built_in">CATransform3D</span> transform = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">    transform.m34 = <span class="number">-1</span> / <span class="number">400.0</span>;</span><br><span class="line">    <span class="comment">// 根据偏移量沿x轴旋转上半部图片</span></span><br><span class="line">    <span class="keyword">self</span>.imageTop.layer.transform = <span class="built_in">CATransform3DRotate</span>(transform, -angle, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 给下半部图片添加阴影效果</span></span><br><span class="line">    <span class="keyword">self</span>.gradient.opacity = offsetY * <span class="number">1</span> / imageWH;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当手指松开的时候将位置返回</span></span><br><span class="line">    <span class="keyword">if</span> (pan.state == <span class="built_in">UIGestureRecognizerStateEnded</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置反弹动画</span></span><br><span class="line">        <span class="comment">// Duration:动画的执行时长</span></span><br><span class="line">        <span class="comment">// delay:延时执行时长</span></span><br><span class="line">        <span class="comment">// Damping:弹性系数(越小,弹性越大)</span></span><br><span class="line">        <span class="comment">// SpringVelocity:初始的弹性系数</span></span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.25</span> delay:<span class="number">0</span> usingSpringWithDamping:<span class="number">0.1</span> initialSpringVelocity:<span class="number">0</span> options:<span class="number">0</span> animations:^&#123;</span><br><span class="line">            <span class="comment">// 清空transform</span></span><br><span class="line">            <span class="keyword">self</span>.imageTop.layer.transform = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">            <span class="comment">// 还原不透明度</span></span><br><span class="line">            <span class="keyword">self</span>.gradient.opacity = <span class="number">0</span>;</span><br><span class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;利用图层特性实现图片折叠的效果&quot;&gt;&lt;a href=&quot;#利用图层特性实现图片折叠的效果&quot; class=&quot;headerlink&quot; title=&quot;利用图层特性实现图片折叠的效果&quot;&gt;&lt;/a&gt;利用图层特性实现图片折叠的效果&lt;/h2&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
    
    
      <category term="iOS代码" scheme="https://xionw1991.github.io/tags/iOS%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>调用系统相册的两种方法</title>
    <link href="https://xionw1991.github.io/2015/10/08/blog/40.%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%86%8C%E6%96%B9%E6%B3%95/"/>
    <id>https://xionw1991.github.io/2015/10/08/blog/40.%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%86%8C%E6%96%B9%E6%B3%95/</id>
    <published>2015-10-08T07:59:57.000Z</published>
    <updated>2020-06-23T16:12:19.832Z</updated>
    
    <content type="html"><![CDATA[<ul><li>调用系统相册<ol><li>调用系统相册需要先实例化一个照片选择控制器 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建照片选择器</span></span><br><span class="line"><span class="built_in">UIImagePickerController</span> *picker = [[<span class="built_in">UIImagePickerController</span> alloc] init];</span><br><span class="line"><span class="comment">// 2. 设置数据源类型(是相册还是照相机)</span></span><br><span class="line">picker.sourceType = <span class="built_in">UIImagePickerControllerSourceTypeSavedPhotosAlbum</span>;</span><br><span class="line"><span class="comment">// 3. 将调用改控制的对象设置为代理 - 这里必须要实现系统要求的两个协议</span></span><br><span class="line">picker.delegate = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">// 4. modal出照片选择控制器</span></span><br><span class="line">[<span class="keyword">self</span> presentViewController:picker animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></li><li>调用代理方法拿到照片 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// info这个字典参数是选中照片的一些信息,根据里面的key可以拿到选择的照片</span></span><br><span class="line">- (<span class="keyword">void</span>)imagePickerController:(<span class="built_in">UIImagePickerController</span> *)picker didFinishPickingMediaWithInfo:(<span class="built_in">NSDictionary</span> *)info</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 拿到图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = info[<span class="built_in">UIImagePickerControllerOriginalImage</span>];</span><br><span class="line">    <span class="comment">// 将照片选取器隐藏</span></span><br><span class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li>往相册里存入照片<ol><li>调用写入方法 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将图片保存到用户相册里面</span></span><br><span class="line"><span class="comment">// image: 将要保存的图片</span></span><br><span class="line"><span class="comment">// target: 方法监听者</span></span><br><span class="line"><span class="comment">// SEL: 保存图片完成时调用的方法(系统规定写法,用来监听保存状态)</span></span><br><span class="line"><span class="comment">// contextInfo: 上下文信息</span></span><br><span class="line"><span class="built_in">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="keyword">self</span>, <span class="keyword">@selector</span>(image:didFinishSavingWithError:contextInfo:), <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure></li><li>实现监听方法 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存相册后回调的监听方法</span></span><br><span class="line">- (<span class="keyword">void</span>)image:(<span class="built_in">UIImage</span> *)image didFinishSavingWithError:(<span class="built_in">NSError</span> *)error contextInfo:(<span class="keyword">void</span> *)contextInfo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"保存失败"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"保存成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>待续…</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;调用系统相册&lt;ol&gt;
&lt;li&gt;调用系统相册需要先实例化一个照片选择控制器 &lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="iOS代码" scheme="https://xionw1991.github.io/tags/iOS%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题</title>
    <link href="https://xionw1991.github.io/2015/10/05/blog/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://xionw1991.github.io/2015/10/05/blog/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2015-10-05T05:01:57.000Z</published>
    <updated>2016-08-02T10:40:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是从简书上拷贝下来题目,没事自己做做.</p></blockquote><a id="more"></a><h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><ul><li><strong>关于单方面技术</strong><ul><li>ARC / MRC 简单叙述一下<br><code>ARC和MRC的意思分别是自动引用计数和手动引用计数，它是iOS中内存管理的一种机制。当一个对象被创建和引用时那么它的引用计数器就会+1，当没有这个对象的引用计数为0时这个对象就会被销毁。MRC中有3个关键字来控制引用计数分别是retain/release/autorelease，retain表示计数器+1，release和autorelease表示计数器-1。ARC与MRC对内存管理的原理是一样的，只是具体实现不一样，ARC它是一种编译器特性，在ARC环境下我们不用手动编写retain和release，编译器会自动在适当的地方插入这些方法。ARC它是通过判断有没有强引用来判断对象是否该销毁，它也有3个关键字来控制对象的生命，strong/weak/assign，strong表示强引用，只要有一个强引用引用者该对象，那么这个对象就不会被销毁。</code></li><li>封装过什么控件, 简单叙述一下<br><code>封装过一些HUD和自定义tabbar， hud就是自定义一个UIView，然后重写view的drewRect: 方法使用cg和ca框架来画出需要的图形。自定义一个tabbar来替换系统自带的tabbar，还有就是自己写一个tabbarViewcontroller来实现完全的自定义。</code></li><li>属性readwrite，readonly，assign，retain，copy，nonatomic各是什么作用<br><code>以上关键字是用来修饰成员属性的，readwrite表示该成员属性可读可写，意味着编译器会默认生成带下划线的成员变量名和与之对应的setter和getter方法；readonly则表示只读，意味着只会生成带下划线的成员变量和对应的getter方法；assign一般用来修饰基本数据类型；retain一般在MRC环境下使用，它修饰的成员属性在被调用的时候，引用计数器会+1；copy一般用来修饰集合类型，因为集合类型分为可变和不可变类型，如果直接使用retain或strong修饰的话，外界就有可能会改这个集合中的值，导致数据污染，通常做法就是当外界使用这个集合的时候都会进行一次拷贝操作，以保证原始数据的完整性；nonatomic表示非原子性，表示非线程安全的，当有多个线程同时访问和修改一个成员变量时，会出现抢夺资源的情况，导致访问成员变量值出错，而atomic就是给这个成员变量配一把锁，当有一个线程访问这个成员变量时就会得到这把锁，其他线程就不能访问，只有这个线程把这个锁释放后其他线程才能访问，保证数据的安全性。</code></li><li>Get Set方法<br><code>get 和 set 方法是为了保证对象的封装性而存在的。一般在程序设计时，如果把一个成员变量暴露在外供外界随意调用是一件很危险的事情。所以这时需要对成员变量进行一次封装，让这个成员变量只能在类的内部调用，对外则提供一些特定的接口让外界访问，这用就能有效的过滤外界对成员变量的行为，保证数据的安全性。</code></li><li>id 是什么<br><code>id可以理解为一个万能指针，它能指向任意一个对象。它是oc多态特征的表现，1.只有当程序运行的时候对象的真实类型才能被确定；2.可以用父类指针指向子类。</code></li><li>代理, Block, 循环引用<br><code>代理实际上是一种设计模式，一个类有一些方法需要外界来实现的时候就可以使用代理模式，比如tableView的数据源，tableView的代理方法。它的存在主要是为了让类之间解耦，以达到模块化的目的；block其实就是一段代码块，用来保存一段代码，然后让这段代码在合适的时候进行调用。block的本质其实就是一个指向结构体的指针，block保存的代码块则最终会被转成一个函数，然后block指向的结构体会生成一个指向该函数的指针型成员变量，当block被调用的时候实际上就是调用的这段函数；循环引用的意思就是，当两个对象互相强引用着对方时，谁也不能被销毁。代理模式和block都会产生循环引用的问题，所以当一个类声明一个代理属性的时候，需要将那个类修饰为弱引用来防止出现循环引用。在block中也是，当block的调用者在block的回调函数中被引用时就会产生循环引用，解决办法就是，新定义一个弱引用的变量来指向block调用者，在block的回调函数中使用这个弱引用来指代这个调用者。</code></li><li>通知的使用<br><code>通知的流程就是当一个事件产生时拿到通知中心单例对象，通过这个单例对象post一个事件，这个事件中包含这个通知的标识，通知发送者和一个字典类型的参数，接下来如果有对象要接收这个通知则先需要add一个监听者来监听这个通知的发送在做一些响应操作，最后当通知的监听对象被销毁的时候记得使用remove来移除监听。通知的使用场景一般是，结构层次很深，或互不相干的两个对象需要进行一个事件监听和数据处理。</code></li></ul></li><li><strong>关于项目方面</strong><ul><li>参与过什么项目, 负责什么</li><li>项目中你参与的模块遇到过什么大的问题, 怎么解决的, 详细叙述</li><li>Git/SVN<br><code>一个是集中式源代码管理工具，一个分布式源代码管理工具，这个没什么好说的。</code></li></ul></li></ul><h2 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h2><ul><li><strong>在基础技术问题的基础上</strong><ul><li>本地通知和远程通知<br><br><code>感觉没什么好说的，本地通知，用来提示本地信息。远程通知是当客户端不在活跃状态时由服务器发送消息给苹果的APNS服务器，然后再根据deviceToken推送给各个设备</code></li><li>简单讲述SDWebImage实现原理<br><br><code>直接上代码</code><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadImageWithUrlStr:(<span class="built_in">NSString</span> *)urlStr placeholder:(<span class="built_in">NSString</span> *)placeholder completeHandle:(<span class="keyword">void</span> (^)(<span class="built_in">UIImage</span> *image))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1&gt; 先从内存缓存中取</span></span><br><span class="line">    <span class="comment">// 根据url取出图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *memoryImage = <span class="keyword">self</span>.images[urlStr];</span><br><span class="line">    <span class="keyword">if</span> (memoryImage) &#123; <span class="comment">// 当内存中有图片时</span></span><br><span class="line">        block(memoryImage);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当内存中没有图片时</span></span><br><span class="line">        <span class="comment">// 2&gt; 再从沙盒中取 - 每一张图片都是一个文件 文件名为url名</span></span><br><span class="line">        <span class="built_in">UIImage</span> *diskImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:cachePath(urlStr)];</span><br><span class="line">        <span class="keyword">if</span> (diskImage) &#123; <span class="comment">// 沙盒中有图片时</span></span><br><span class="line">            block(diskImage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当沙盒中没有对应的图片时</span></span><br><span class="line">            <span class="comment">// 设置占位图片</span></span><br><span class="line">            block([<span class="built_in">UIImage</span> imageNamed:placeholder]);</span><br><span class="line">            <span class="comment">// 3&gt; 从网络上下载</span></span><br><span class="line">            <span class="comment">/* 为了保证一张图片只下载一次,需要判断当前url是否有下载任务,如果没有才需要创建下载任务 */</span></span><br><span class="line">            <span class="comment">/* 如何才能判断当前的url是否有下载任务呢?利用字典一对一绑定来判断 */</span></span><br><span class="line">            <span class="comment">// 取出字典中url对应的下载任务</span></span><br><span class="line">            <span class="built_in">NSBlockOperation</span> *operation = <span class="keyword">self</span>.operations[urlStr];</span><br><span class="line">            <span class="comment">// 如果当前url有下载任务 - 就不创建任务</span></span><br><span class="line">            <span class="keyword">if</span> (!operation) &#123;</span><br><span class="line">                __<span class="keyword">weak</span> <span class="keyword">typeof</span> (<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">                <span class="comment">// 创建异步任务 - 将下载图片的操作放入到子线程中 - 解决异步下载的问题</span></span><br><span class="line">                operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">                    <span class="comment">// 将字符串转成url</span></span><br><span class="line">                    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlStr];</span><br><span class="line">                    <span class="comment">// 从url获取数据</span></span><br><span class="line">                    <span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">                    <span class="comment">// 将二进制数据转成图片</span></span><br><span class="line">                    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 返回主线程刷新数据</span></span><br><span class="line">                    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">                        <span class="comment">// 如果下载成功将图片存入字典 - 字典不能存空</span></span><br><span class="line">                        <span class="keyword">if</span> (image) &#123;</span><br><span class="line"></span><br><span class="line">                            block(image);</span><br><span class="line">                            <span class="comment">// 1)将下载好的图片添加进图片字典中 url为key</span></span><br><span class="line">                            [weakself.images setObject:image forKey:urlStr];</span><br><span class="line">                            <span class="comment">// 2)将image写入沙盒</span></span><br><span class="line">                            <span class="comment">// 将图片转成二进制数据</span></span><br><span class="line">                            <span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line">                            <span class="comment">// 写入沙盒</span></span><br><span class="line">                            [data writeToFile:cachePath(urlStr) atomically:<span class="literal">YES</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 下载完毕后将任务从字典中移除 - 如果下载失败将任务移除后还有机会下载,如果不移除,这个key就会一直存在永远也不能再次下载了</span></span><br><span class="line">                        <span class="comment">// 在主线程中移除是为了保证下载操作已经执行完毕</span></span><br><span class="line">                        [<span class="keyword">self</span>.operations removeObjectForKey:urlStr];</span><br><span class="line">                    &#125;];</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将任务添加到队列 - 如果当前队列有相同任务则不添加</span></span><br><span class="line">            <span class="keyword">if</span> (![<span class="keyword">self</span>.queue.operations containsObject:operation]) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.queue addOperation:operation];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将下载任务写入到字典里(解决重复下载问题)</span></span><br><span class="line">            [<span class="keyword">self</span>.operations setObject:operation forKey:urlStr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>数据库语句<br><br><code>列举几个常用的数据库语句：</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创表</span><br><span class="line">CREATE TABLE IF NOT EXISTS t_cmpt (id INTEGER PRIMARY KEY, name TEXT, price REAL)</span><br><span class="line">&#x2F;&#x2F; 插入数据</span><br><span class="line">INSERT INTO t_cmpt (name, price) VALUES (abc, 998)</span><br><span class="line">&#x2F;&#x2F; 删除数据</span><br><span class="line">DELETE FROM t_cmpt</span><br><span class="line">&#x2F;&#x2F; 查询数据</span><br><span class="line">SELECT * FROM t_cmpt</span><br></pre></td></tr></table></figure></li><li>CoreData常用使用<br><br><code>一般用sqlite，没用过CoreData</code></li><li>优化UITableView的方式, 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- 对于复杂的视图，使用纯代码来实现布局（storyboard对资源的消耗要大于纯代码）</span><br><span class="line">- 使用SDWebImage来异步加载图片, 管理下载队列, 缓存数据</span><br><span class="line">- 使用估算高度,来防止tableView一显示就计算所有cell的高度(延迟调用heightForRow)</span><br><span class="line">- 在不等高cell中,使用字典来保存已经计算高度的cell,在下次滑动到这个cell的时候优先调用字典里的cellHeight, 最好的办法是在数据返回的时候就根据数据来计算出cell的高度并缓存起来</span><br><span class="line">- 调用scrollView的代理方法,在滑动tableView的时候就停止所有的网络请求(比如图片下载)</span><br><span class="line">- 在cell已经离开显示区域后从内存中清除cell,特别是带大量图片的复杂的cell, 防止内存占用过多导致程序崩溃</span><br><span class="line">- 在cell中使用高清大图时尽量使用fileFormPath来加载图片而不是使用imageName: 前者是一次性显示,当从可显示区域移除后就会自动从内存中销毁, 而后者只有内存警告的时候才会被回收</span><br><span class="line">- 在对象销毁的时候将所有的代理清空</span><br><span class="line">- 尽量让所有的view不透明(opaque), 因为透明会额外消耗性能</span><br><span class="line">- 尽量不要动态给cell添加子控件(意思就是不要在cellForRow中添加子控件)</span><br><span class="line">- 不需要交互的内容不使用系统封装好的控件来显示，而是调用独立功能的API来在图层上绘制，比如cell中的图片只需要显示，而不需要交互，则可以考虑自定义图层来绘制出这个图片，还有文字使用更底层的CoreText来绘制文字而不是使用label</span><br><span class="line">- 根据滑动的位置异步按需加载内容(比如提前加载当前显示cell附近cell的内容)</span><br><span class="line">- 使用第三方框架的tableView(异步渲染UI)，比如AsyncDisplayKit框架</span><br></pre></td></tr></table></figure></li><li>深浅拷贝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">浅复制（浅拷贝，指针拷贝，shallow copy）</span><br><span class="line">- 源对象和副本对象是同一个对象</span><br><span class="line">- 源对象（副本对象）引用计数器+1,相当于做一次retain操作</span><br><span class="line">- 本质是：没有产生新的对象</span><br><span class="line">- 原对象引用计数器+1</span><br><span class="line">- 必须对原对象进行释放</span><br><span class="line">深复制（深拷贝，内容拷贝，deep copy）</span><br><span class="line">- 源对象和副本对象是不同的两个对象</span><br><span class="line">- 源对象引用计数器不变,副本对象计数器为1（因为是新产生的）</span><br><span class="line">- 本质是：产生了新的对象</span><br><span class="line">- 必须释放新对象</span><br></pre></td></tr></table></figure></li><li>运行时你知道多少（是什么？有哪些用处？）<br><br><code>运行时是一套纯c语言的函数库，它是支撑整个OC动态特性的幕后工作者，在OC环境下所编写的代码在编译的时候都会先转换成纯c的运行时代码然后在再编译成二进制的机器语言。使用运行时可以办到一些OC办不到的事情，比如获取类中的私有成员变量，动态添加方法，动态添加成员属性，动态添加一个类（KVO），Method Swizzle，实现消息转发等。</code></li><li>封装过什么<br><code>封装过一些工具类，视图类，模型缓存类等</code></li></ul></li><li><strong>关于项目方面</strong><ul><li>熟练的使用Git</li><li>如果让你设计一个缓存模块, 你会怎么设计,需要考虑到什么<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每次获取数据优先从内存中获取，如果没有再查找本地数据库和文件，如果没有则发送网络请求，从服务区加载数据，然后将获得的数据进行本地缓存。</span><br><span class="line">数据库缓存方面注意点：</span><br><span class="line">1.首先考虑到的是线程安全，因为在iOS中sqlite不支持多线程并发访问，会引起数据库锁定，所以在访问数据库的时候都是以同步串行的方式进行访问的；</span><br><span class="line">2.添加文件校验，将文件名和文件数据进行关联，防止文件多次下载；</span><br><span class="line">3.防止文件名冲突，比如像SDWebImage对下载下来的文件名进行MD5加密，防止文件被覆盖；</span><br></pre></td></tr></table></figure></li><li>说说MVC MVVM MVP<br><code>MVP是MVC的衍生版，真正做到了模型与视图的隔离，每次视图需要获取数据必须要通过Presenter，当然这又产生一个问题，就是Presenter的体积会越来越庞大，不便于后期的维护。MVVM则更像MVC的改良版，它将控制器中对数据的处理全部抽到了一个视图模型中，减小了控制器的体积，同时也办到了视图与模型的隔离。</code></li><li>做过最失败的项目是什么, 为什么</li><li>你觉得怎么划分模块会好一点<br><code>我觉得按功能划分最好啦~</code></li></ul></li></ul><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><ul><li><strong>基于前两个</strong><ul><li>多线程详细说一下, 怎么封装一个适合自己项目的线程池,怎么处理会好一点。</li><li>多线程CoreData, 这个基本所有的面试都会提到一下吧</li><li>使用过什么开源的动画库, 这就是随便问问 比如pop, canvas等</li><li>有自己的开源项目么？</li><li>有全面的对网络库进行二次开发封装么, 怎么干的。</li><li>讲一下运行时调换系统方法swizzle的原理</li><li>自己尝试着模拟系统Block的实现</li><li>怎么理解界面模板, 有做过相关开发么</li><li>IM的东西随便问问，如果公司需要</li><li>内存优化怎么搞一下<br><br><code>见tableView的优化思路</code></li><li>自己写个tableView玩玩？</li></ul></li><li><strong>项目方面</strong><ul><li>参与过什么项目, 做过什么大型的项目, 负责哪些模块</li><li>框架的设计有没有参与, 如果有的话, 参与了框架中哪一部分的工作, 怎么考虑你这部分未来的可扩展性的。</li><li>在项目中严格按照产品,UIUE的思维去做,还是会把自己的想法提出来。</li><li>怎么为一个项目写一套完整的网络库, 缓存库, 界面库。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是从简书上拷贝下来题目,没事自己做做.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://xionw1991.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>UIAlertView在iOS9中的使用</title>
    <link href="https://xionw1991.github.io/2015/09/20/blog/39.UIAlertView%E5%9C%A8IOS9%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://xionw1991.github.io/2015/09/20/blog/39.UIAlertView%E5%9C%A8IOS9%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2015-09-20T02:37:57.000Z</published>
    <updated>2020-06-23T15:15:59.512Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>iOS9中改变了UIAlertView的使用方式, 并且与UIActionSheet融合进了一个类里面,统一进行管理.</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注销</span></span><br><span class="line">- (<span class="keyword">void</span>)loginOut</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建一个alertController来管理警示窗口, 并指定样式</span></span><br><span class="line">    <span class="built_in">UIAlertController</span> *alertController = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@"确定注销吗?"</span> message:<span class="literal">nil</span> preferredStyle:<span class="built_in">UIAlertControllerStyleActionSheet</span>];</span><br><span class="line">    <span class="comment">// 2.创建点击行为, 在block中实现事件</span></span><br><span class="line">    <span class="built_in">UIAlertAction</span> *action = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"确定"</span> style:<span class="built_in">UIAlertActionStyleDestructive</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"已注销"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">UIAlertAction</span> *cancel = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"取消"</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"取消注销"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 3.为alertController添加点击行为</span></span><br><span class="line">    [alertController addAction:action];</span><br><span class="line">    [alertController addAction:cancel];</span><br><span class="line">    <span class="comment">// 4.弹出警示窗口</span></span><br><span class="line">    [<span class="keyword">self</span> presentViewController:alertController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;iOS9中改变了UIAlertView的使用方式, 并且与UIActionSheet融合进了一个类里面,统一进行管理.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
    
      <category term="iOS代码" scheme="https://xionw1991.github.io/tags/iOS%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Runtime黑魔法</title>
    <link href="https://xionw1991.github.io/2015/09/18/blog/38.Runtime%E9%BB%91%E9%AD%94%E6%B3%95/"/>
    <id>https://xionw1991.github.io/2015/09/18/blog/38.Runtime%E9%BB%91%E9%AD%94%E6%B3%95/</id>
    <published>2015-09-18T14:09:57.000Z</published>
    <updated>2020-06-23T15:16:04.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Runtime消息机制"><a href="#Runtime消息机制" class="headerlink" title="Runtime消息机制"></a>Runtime消息机制</h2><p>之前写过一篇短文: <a href="http://xionv.com/2015/05/08/demonayu/blog/29.利用运行时特性获取系统类的私有成员变量/" target="_blank" rel="noopener">利用运行时特性获取系统类的私有成员属性</a>.<br><br>通过运行时特性获得私有的成员变量target, 然后为target重新指定手势方法来达到全屏都能接收到滑动返回的事件.</p><ul><li>如果要搞清楚为什么能这样做首先得明白OC的运行时机制,看下面代码:<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pan:)];</span><br></pre></td></tr></table></figure></li><li>这行代码的意思就是:使用UIPanGestureRecognizer类来实例化了一个名为pan的实例对象,并为这个对象指定了手势的监听对象(假设是控制器)和监听方法. 其实这只是我们看到的表面,实际上OC所有的方法调用本质上还是函数的调用.</li><li>大概了解一下什么是runtime:<ul><li>Runtime顾名思义就是运行时的意思.在运行的时候才会调用需要实现的函数.</li><li>OC是一门动态的语言,相对于C语言来讲,OC方法的调用是在程序运行的时候才决定的.也就是说只有方法的声明没有方法的实现照样也能编译通过.这样就需要一个运行时系统 (runtime system) 来执行编译后的代码.</li></ul></li><li>运行时中的消息机制: <ul><li>每一个方法的调用实际上就是向对象发送了一条消息让其执行SEL指向的方法实现(IMP);</li><li>上面的代码可以使用runtime函数改写:<ul><li>导入头文件,在项目设置中将<code>enable strict checking of objcmsgsend calls</code>改成<code>NO</code><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br></pre></td></tr></table></figure></li><li>改写方法为消息函数<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = objc_msgSend(objc_msgSend (objc_getClass(<span class="string">"UIPanGestureRecognizer"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"initWithTarget:action:"</span>), <span class="keyword">self</span>, sel_registerName(<span class="string">"pan:"</span>));</span><br></pre></td></tr></table></figure>解释: <code>objc_msgSend</code>就是消息函数.<br><code>objc_getClass</code>将字符串转化成类名, <code>sel_registerName</code> 将字符串注册成一个方法标识.<br>后面的<code>self</code>和<code>sel_registerName(&quot;pan:&quot;)</code>则相当于消息的参数. 这句话翻译过来就是,系统向<code>UIPanGestureRecognizer</code>这个类对象发送了一条消息,让它去执行参数<code>alloc</code>所指向的方法实现,返回一个实例对象, 再发送一条消息让返回的实例对象去执行<code>initWithTarget:action:</code>这个方法,并且同时传入了两个参数.</li></ul></li><li>分析消息函数:<code>objc_msgSend(id self, SEL op, ...);</code><ul><li>每一个消息函数都需要至少传入两个参数, 一个是消息的接收者(target), 一个方法代号(SEL).</li><li>这个两个参数被称为隐式参数.如果你用过<code>NSInvocation</code>那么你就会明白为什么调用<code>[invocation setArgument:&amp;param1 atIndex:2];</code>传入参数的时候索引要从2开始.</li><li><strong>系统在向一个对象发送消息并不意味着会被马上执行.如果消息的接收者能够找到对应的selector,那么就相当于直接执行了接收者这个对象的特定方法;否则,消息被转发,或是临时向接收者动态添加这个selector对应的实现内容(动态方法解析),如果都没有则程序崩溃.</strong></li></ul></li></ul></li><li>消息发送的步骤:<ol><li>检测这个<code>selector</code>是不是要忽略的;</li><li>检测这个<code>target</code>是不是<code>nil</code>对象;</li><li>如果上面两关都过了则开始查找类中的cache中的IMP, 如果能找到这执行函数,如果不能在去映射表中查找;</li><li>如果当前类中映射表中查不到,则向上沿着父类的映射表查找,一直找到根类;</li><li>如果仍然没有找到则开始动态方法解析和消息转发.</li></ol></li></ul><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul><li>在OC中类本身也是一个对象,为了处理类和对象的关系,runtime库创建了一种叫做元类 (Meta Class) 的东西,类对象所属类型就叫做元类,它用来表述类对象本身所具备的元数据.类方法就定义于此处,因为这些方法可以理解成类对象的实例方法.每个类仅有一个类对象,而每个类对象仅有一个与之相关的元类.当发出一个类似<code>[NSObject alloc]</code>的消息时,事实上是把这个消息发给了一个类对象 (Class Object),这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class)的实例.所有的元类最终都指向根元类为其超类.所有的元类的方法列表都有能够响应消息的类方法.所以当<code>[NSObject alloc]</code>这条消息发给类对象的时候,objc_msgSend()会去它的元类里面去查找能够响应消息的方法,如果找到了,然后对这个类对象执行方法调用.<br><img src="http://cn.cocos2d-x.org/uploads/20141018/1413628797629491.png" alt=""></li></ul><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><ul><li>方法的selector用于表示运行时方法的名字.OC在编译时,会依据每一个方法的名字,参数序列,生成一个唯一的整型标识(Int类型的地址),这个标识就是SEL;</li><li>SEL类型代表着方法的签名,在类对象的方法列表中存储着该签名与方法代码的对应关系;</li><li>每一个方法都对应着一个SEL.所以在同一个类(及类的继承体系)中,不能存在2个同名的方法,即使参数类型不同也不行.相同的方法只能对应一个SEL。</li><li>本质上,SEL只是一个指向方法的指针(准确的说,只是一个根据方法名hash化了的KEY值,能唯一代表一个方法),它的存在只是为了加快方法的查询速度,最终指向方法的实现.</li><li>运行时有三种方式获得SEL<ul><li><code>sel_registerName</code>函数</li><li>编译器提供的<code>@selector()</code></li><li><code>NSSelectorFromString()</code>方法</li></ul></li></ul><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><ul><li>IMP实际上是一个函数指针,指向方法实现的首地址.可以理解成它就是实现方法的一个入口,连接着代码区的方法实现代码.取得IMP后我们就可以像调用普通的C语言函数一样来使用这个函数指针了.</li><li>通过取得IMP,我们可以跳过Runtime的消息传递机制,直接执行IMP指向的函数实现,这样省去了Runtime消息传递过程中所做的一系列查找操作,会比直接向对象发送消息高效一些.</li><li>直接获取方法地址: <code>methodForSelector:</code>.</li></ul><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><ul><li><p>Method的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> *<span class="title">Method</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> &#123;</span></span><br><span class="line">    SEL method_name                 OBJC2_UNAVAILABLE;  <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">char</span> *method_types              OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                  OBJC2_UNAVAILABLE;  <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到该结构体中包含一个SEL和IMP,实际上相当于在SEL和IMP之间作了一个映射.有了SEL,我们便可以找到对应的IMP,从而调用方法的实现代码.</p><p><img src="http://r5.loli.io/EVBVVn.png" alt=""></p></li></ul><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><ul><li>Cache为方法调用的性能进行优化,通俗地讲,每当实例对象接收到一个消息时,它不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法,因为这样效率太低了,而是优先在Cache中查找.Runtime系统会把被调用的方法存到Cache中(理论上讲一个方法如果被调用，那么它有可能今后还会被调用),下次查找的时候效率更高.</li></ul><h2 id="Runtime几个常见的用法"><a href="#Runtime几个常见的用法" class="headerlink" title="Runtime几个常见的用法"></a>Runtime几个常见的用法</h2><h3 id="获取成员和方法列表"><a href="#获取成员和方法列表" class="headerlink" title="获取成员和方法列表"></a>获取成员和方法列表</h3><ul><li>在Runtime面前没有私有变量,使用私有变量调用自定义方法.<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来记录成员变量个数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ivarCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 取出所有的成员变量</span></span><br><span class="line">Ivar *ivars = class_copyIvarList([<span class="built_in">UIPageControl</span> <span class="keyword">class</span>], &amp;ivarCount);</span><br><span class="line"><span class="comment">// 遍历所有的成员变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ivarCount; i++) &#123;</span><br><span class="line">    <span class="comment">// 打印变量名</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, ivar_getName(ivars[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"----------分割线-----------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录成员属性个数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> propertyCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 取出所有的成员属性</span></span><br><span class="line">objc_property_t *propertise = class_copyPropertyList([<span class="built_in">UIPageControl</span> <span class="keyword">class</span>], &amp;propertyCount);</span><br><span class="line"><span class="comment">// 遍历成员属性列表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) &#123;</span><br><span class="line">    <span class="comment">// 打印属性名</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, property_getName(propertise[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>获取方法列表:调用私有方法成为可能<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出方法列表</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outcount = <span class="number">0</span>;</span><br><span class="line">Method *methods = class_copyMethodList([<span class="built_in">UIPageControl</span> <span class="keyword">class</span>], &amp;outcount);</span><br><span class="line"><span class="comment">// 遍历方法列表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outcount; i++) &#123;</span><br><span class="line">    SEL action = method_getName(methods[i]);</span><br><span class="line">    <span class="comment">// 打印所有方法(包括私有)</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(action));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用私有方法, UIPageControl默认是不能设置图片的, 通过调用这个私有方法可以设置指示器图片</span></span><br><span class="line">[[<span class="built_in">UIPageControl</span> new] performSelector:<span class="keyword">@selector</span>(_pageIndicatorImageForPage:) withObject:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image"</span>]];</span><br></pre></td></tr></table></figure></li></ul><h4 id="三种方式调用私有方法"><a href="#三种方式调用私有方法" class="headerlink" title="三种方式调用私有方法"></a>三种方式调用私有方法</h4><ol><li>performSelector: – 优点:方便; 缺点:最多只能传2个参数<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[XVPerson new] performSelector:<span class="keyword">@selector</span>(eat:drink:play:) withObject:<span class="string">@"hamburger"</span> withObject:<span class="string">@"coke"</span>];</span><br></pre></td></tr></table></figure>ps: 让selector调用的方法接受的参数类型为Dictionary类型可以间接实现多参数传递.</li><li>NSInvocation – 优点:可以传多个参数; 缺点:调用麻烦,代码较多<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个方法签名</span></span><br><span class="line">SEL myMethod = <span class="keyword">@selector</span>(eat:drink:play:);</span><br><span class="line"><span class="built_in">NSMethodSignature</span> *signature = [[XVPerson <span class="keyword">class</span>] instanceMethodSignatureForSelector:myMethod];</span><br><span class="line"><span class="comment">// 初始化一个NSInvocation对象</span></span><br><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];</span><br><span class="line"><span class="comment">// 要执行的方法</span></span><br><span class="line">[invocation setSelector:myMethod];</span><br><span class="line"><span class="comment">// 注: 这里的index为什么要从2开始? 因为每一个OC方法的本质就是一个至少带有两个参数(self,_cmd)的普通C函数</span></span><br><span class="line"><span class="comment">// 这两个参数在这里所对应的就是Target和Selector, 这两个参数已经将0 和 1 的位置给占了.所以其他参数要从 2 开始.</span></span><br><span class="line"><span class="built_in">NSString</span> *param1 = <span class="string">@"hamburger"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *param2 = <span class="string">@"coke"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *param3 = <span class="string">@"hockey"</span>;</span><br><span class="line">[invocation setArgument:&amp;param1 atIndex:<span class="number">2</span>];</span><br><span class="line">[invocation setArgument:&amp;param2 atIndex:<span class="number">3</span>];</span><br><span class="line">[invocation setArgument:&amp;param3 atIndex:<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 调用方法 并指定调用谁的方法</span></span><br><span class="line">[invocation invokeWithTarget:[XVPerson new]];</span><br></pre></td></tr></table></figure></li><li>Runtime – 优点:代码简单,能传多参数 缺点:要导入头文件<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend([XVPerson new], sel_registerName(<span class="string">"eat:drink:play:"</span>), <span class="string">@"hamburger"</span>, <span class="string">@"coke"</span>, <span class="string">@"hockey"</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="交换方法"><a href="#交换方法" class="headerlink" title="交换方法"></a><strong>交换方法</strong></h3><ul><li>目标: 当系统找不到方法的时候会调用<code>doesNotRecognizeSelector:</code>来抛出崩溃详情. 要求通过添加分类来实现改写这个系统方法.本质上就是一种消息转发机制.</li><li>思路: 利用Runtime在程序抛出错误时添加一行打印, 通过交换方法可以在不影响错误打印的同时在程序退出时做一些事情.<ol><li>为NSObject添加一个分类,并导入头文件<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> (Extension)</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br></pre></td></tr></table></figure></li><li>定义一个自定义方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)xv_doesNotRecognizeSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"因为找不到%@方法,程序即将崩溃!"</span>, <span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"====================================="</span>);</span><br><span class="line">    <span class="comment">// 这个时候实现这个方法并不会死循环, 因为实际上执行的是doesNotRecognizeSelector:</span></span><br><span class="line">    [<span class="keyword">self</span> xv_doesNotRecognizeSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>与系统方法进行交换<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在类加载的时候就进行交换</span></span><br><span class="line"> + (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前类中的对象方法</span></span><br><span class="line">    Method method1 = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(doesNotRecognizeSelector:));</span><br><span class="line">    Method method2 = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(xv_doesNotRecognizeSelector:));</span><br><span class="line">    <span class="comment">// 交换方法</span></span><br><span class="line">    method_exchangeImplementations(method1, method2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><ul><li>使用场景: 用到该方法时再加载该方法;</li><li>思路: 当对象调用一个未实现的方法时, 系统就会调用下面这个方法,本质上就消息转发<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用这个方法的意思就是,给个机会让类添加这个未实现的方法</span></span><br><span class="line"> + (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br></pre></td></tr></table></figure></li><li>假如person这个对象要调用未实现的方法<code>eat:drink:play:</code>, 具体步骤:<ol><li>当前类重写<code>resolveInstanceMethod:</code><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> + (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当传进来的sel是未实现的sel时</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"eat:drink:play:"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 参数1: 需要添加方法的类</span></span><br><span class="line">        <span class="comment">// 参数2: 传进来的方法名称</span></span><br><span class="line">        <span class="comment">// 参数3: 需要添加的方法实现</span></span><br><span class="line">        <span class="comment">// 参数4: "v@:@@@" 这个方法的参数描述 -- v表示空值, @表示对象, :表示方法(SEL)</span></span><br><span class="line">        <span class="comment">// 对应函数 void myMethodIMP(id self, SEL _cmd, NSString *eat, NSString *drink, NSString *play) 的5个参数类型</span></span><br><span class="line">        <span class="comment">// 给类动态添加一个方法来救命</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)myMethodIMP, <span class="string">"v@:@@@"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>添加的方法实现<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一个OC方法的本质其实就是一个至少带有两个参数（self,_cmd）的普通C函数</span></span><br><span class="line"><span class="keyword">void</span> myMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *eat, <span class="built_in">NSString</span> *drink, <span class="built_in">NSString</span> *play) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"eat: %@, drink: %@, play:%@"</span>, eat, drink, play);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@--%@"</span>, <span class="keyword">self</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="动态添加成员属性"><a href="#动态添加成员属性" class="headerlink" title="动态添加成员属性"></a>动态添加成员属性</h3><ul><li>需求: 为根类NSObject添加属性,不准使用继承;</li><li>思路: 如果要扩展某个系统类,不使用继承就只有使用分类了,但是在分类中使用property只会生成setter和getter方法并不会生成成员变量.</li><li>实现步骤:<ol><li>在分类的.h文件中添加属性接口<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为只会生成setter和getter方法,写上修饰属性的关键字没有意义(nonatomic, strong)</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *myProperty;</span><br></pre></td></tr></table></figure></li><li>在分类的.m文件中实现setter和getter方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setter方法</span></span><br><span class="line"> - (<span class="keyword">void</span>)setMyProperty:(<span class="built_in">NSString</span> *)myProperty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加成员属性</span></span><br><span class="line">    <span class="comment">// 参数1: 给那个对象添加成员属性</span></span><br><span class="line">    <span class="comment">// 参数2: 添加的成员属性名</span></span><br><span class="line">    <span class="comment">// 参数3: 添加的成员属性值</span></span><br><span class="line">    <span class="comment">// 参数4: 属性策略 - RETAIN_NONATOMIC ==&gt; (nonatomic, strong)</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="string">"property"</span>, myProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getter方法</span></span><br><span class="line"> - (<span class="built_in">NSString</span> *)myProperty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回成员属性</span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="string">"property"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="MJExtension框架中字典转模型的原理"><a href="#MJExtension框架中字典转模型的原理" class="headerlink" title="MJExtension框架中字典转模型的原理"></a>MJExtension框架中字典转模型的原理</h3><ul><li>一句话概括: 利用运行时获取对象中所有成员变量, 然后将成员变量名与字典中的key名进行比对,将比对成功的成员变量进行赋值.</li><li>思路: 为基类添加一个分类, 让所有的类都能调用这个方法.</li><li>要注意的细节: <ul><li>如果字典中嵌套字典;</li><li>如果字典中嵌套字典数组;</li></ul></li><li>具体实现的代码:<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认返回nil, 有数组字典需要转成模型时需要在外部重写这个方法</span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)arrayContentModelClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入一个字典将其转成模型</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)objectWithDict:(<span class="built_in">NSDictionary</span> *)dict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个id对象</span></span><br><span class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    <span class="comment">// 遍历类中所有的成员变量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ivarCount = <span class="number">0</span>;</span><br><span class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;ivarCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ivarCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 取出成员变量</span></span><br><span class="line">        Ivar ivar = ivarList[i];</span><br><span class="line">        <span class="comment">// 取出成员的类型名称字符串 @"@\"classname\""</span></span><br><span class="line">        <span class="built_in">NSString</span> *classname = @(ivar_getTypeEncoding(ivar));</span><br><span class="line">        <span class="comment">// 截取出类型名字</span></span><br><span class="line">        classname = [classname stringByReplacingOccurrencesOfString:<span class="string">@"\""</span> withString:<span class="string">@""</span>];</span><br><span class="line">        classname = [classname stringByReplacingOccurrencesOfString:<span class="string">@"@"</span> withString:<span class="string">@""</span>];</span><br><span class="line">        <span class="comment">// 截取出所有成员变量的名称</span></span><br><span class="line">        <span class="built_in">NSString</span> *ivarName = [@(ivar_getName(ivar)) substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拿到属性名与字典的key名一样的值, 如果字典中找不到跟key名一样的属性名那么value为nil</span></span><br><span class="line">        <span class="keyword">id</span> value = dict[ivarName];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 二级转换 - 当value为字典时 */</span></span><br><span class="line">        <span class="comment">// 当值的类型是字典并且是自定义类型的时候, 取出类名, 再转一次</span></span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]] &amp;&amp; ![classname hasPrefix:<span class="string">@"NS"</span>]) &#123;</span><br><span class="line">            value = [<span class="built_in">NSClassFromString</span>(classname) objectWithDict:value];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 三级转换 - 当value为字典数组时 */</span></span><br><span class="line">        <span class="comment">// 问题: 将数组中的字典转成哪个类?</span></span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="comment">// 当一个数组字典想要转成一个模型时,必须要实现这个方法: arrayContentModelClass</span></span><br><span class="line">            <span class="comment">// 如果不做判断, 那么在数据源中有数组的而没有实现这个方法的话就会报找不到方法的错</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> arrayContentModelClass] != <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="comment">// key:数组名 ; value:模型类名</span></span><br><span class="line">                <span class="built_in">NSDictionary</span> *classDict = [<span class="keyword">self</span> arrayContentModelClass];</span><br><span class="line">                <span class="built_in">NSArray</span> *array = value;</span><br><span class="line">                <span class="built_in">NSMutableArray</span> *arrM = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">                <span class="comment">// 遍历数组</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> array) &#123;</span><br><span class="line">                    <span class="comment">// 根据当前成员变量名取出来的值就是类名字符串, 再将字符串转成类</span></span><br><span class="line">                    <span class="keyword">id</span> tempValue = [<span class="built_in">NSClassFromString</span>(classDict[ivarName]) objectWithDict:dict];</span><br><span class="line">                    <span class="comment">// 当类名写错时 对象会没有值, 数组中不能添加nil, 所以要做这个容错处理</span></span><br><span class="line">                    <span class="keyword">if</span> (tempValue == <span class="literal">nil</span>) &#123;</span><br><span class="line">                        arrM = value;</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@"创建模型失败, 找不到类..."</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        [arrM addObject:tempValue];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                value = [<span class="built_in">NSArray</span> arrayWithArray:arrM];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当value有值时才进行赋值</span></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="comment">// 利用kvc赋值</span></span><br><span class="line">            [objc setValue:value forKey:ivarName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>有数组字典时,在模型类中重写<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 说明将要把数组里面的字典转成哪个模型</span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)arrayContentModelClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将哪个数组中的字典元素转成哪个类</span></span><br><span class="line">    <span class="keyword">return</span> @&#123; <span class="string">@"pic_urls"</span> : <span class="string">@"XVPicURL"</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="利用消息转发给程序三次起死回生的机会"><a href="#利用消息转发给程序三次起死回生的机会" class="headerlink" title="利用消息转发给程序三次起死回生的机会"></a>利用消息转发给程序三次起死回生的机会</h2><p><img src="http://images.cnitblog.com/i/31852/201404/231837047638961.png" alt=""></p><ul><li>在程序运行时如果找不到实现方法,系统会给程序几次机会来使能够程序正常运行,实在没出路了才会抛出异常.</li><li>三次补救机会<ol><li>动态方法解析,<code>resolveInstanceMethod</code> 给类一个动态添加方法的机会,前面已经提及.</li><li>快速消息转发,<code>forwardingTargetForSelector:</code>将SEL转给其他对象实现的机会;</li><li>标准消息转发,<code>methodSignatureForSelector:</code>(函数符号制造器)让重载方有机会抛出一个函数的签名,再由<code>forwardInvocation:</code>(函数执行器)去执行这个函数.</li></ol></li><li>具体流程参考: <a href="http://blog.csdn.net/yiyaaixuexi/article/details/8970734" target="_blank" rel="noopener">Objective-C 的“多继承”</a></li></ul><h2 id="self与super"><a href="#self与super" class="headerlink" title="self与super"></a>self与super</h2><ul><li>看过一个题目是这样的: 问打印结果是什么?<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>答案: 都输出 Son.</li><li>本质上super是一个编译指示器, 它并不是一个指针, 它仅仅是表示调用父类的方法,但是调用者仍然是当前对象,跟父类没有关系.也就是说上面的例子不管调用<code>[self class]</code>还是<code>[super class]</code>,接受消息的对象都是当前<code>Son</code>这个对象.</li><li>当使用self调用方法时,会从当前类的方法列表中开始找,如果没有,就从父类中再找;而当使用super时,则从父类的方法列表中开始找.然后调用父类的这个方法.</li><li><code>[super superClass]</code>等价于<code>[self superClass]</code>表示获取当前方法调用者的父类.</li></ul><p>参考:</p><ul><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a></li><li><a href="http://www.cocoachina.com/ios/20141008/9844.html" target="_blank" rel="noopener">理解 Objective-C Runtime</a></li><li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a></li></ul><p>拓展阅读:</p><ul><li><a href="http://www.cocoachina.com/ios/20141224/10740.html" target="_blank" rel="noopener">刨根问底Objective－C Runtime</a></li><li><a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">深入理解Objective-C：Category</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Runtime消息机制&quot;&gt;&lt;a href=&quot;#Runtime消息机制&quot; class=&quot;headerlink&quot; title=&quot;Runtime消息机制&quot;&gt;&lt;/a&gt;Runtime消息机制&lt;/h2&gt;&lt;p&gt;之前写过一篇短文: &lt;a href=&quot;http://xionv.co
      
    
    </summary>
    
    
    
      <category term="iOS干货" scheme="https://xionw1991.github.io/tags/iOS%E5%B9%B2%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>RunLoop基础知识</title>
    <link href="https://xionw1991.github.io/2015/09/13/blog/37.RunLoop%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://xionw1991.github.io/2015/09/13/blog/37.RunLoop%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2015-09-13T03:06:57.000Z</published>
    <updated>2020-06-23T15:17:06.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop"></a>什么是RunLoop</h2><ul><li>RunLoop: 运行循环, 顾名思义就是跑圈, 兜圈子的意思. 一个应用程序能够一直运行而不会退出就是基于这种机制.</li><li>基本作用:<ol><li>保持程序持续运行, 相当于一个死循环;</li><li>处理应用程序中的各种事件, 比如触摸事件, 定时器事件等;</li><li>它的作用机制是有就做事, 没事就待命休息, 节省资源;</li></ol></li><li>主RunLoop: 当程序一启动系统就会在main函数中调用<code>UIApplicationMain()</code>这个函数, 该函数会在程序的主线程中开启一个RunLoop一直保持程序的运行.</li><li>自动释放池什么时候创建和释放?<ol><li>第一次创建,是在RunLoop进入的时候创建,对应的状态 = kCRunLoopEntry</li><li>最后一释放,是在RunLoop时候,对应的状态 = kCFRuRunLoopExit</li><li>它创建和释放,每次睡觉的时候都会释放前自动释放池,然后再建一个新的.</li></ol></li><li>RunLoop对象 <ol><li>在iOS开发中有两套api访问RunLoop<ul><li>Foundation框架<code>NSRunLoop</code></li><li>Core Foundation框架<code>CFRunLoopRef</code></li></ul></li><li>这个两个框架中所代表RunLoop是等价的.</li><li>NSRunLoop基于<code>CFRunLoopRef</code>的一层OC封装.</li></ol></li><li>RunLoop与线程 <ol><li>每一个线程都有一个与之对应的RunLoop对象.</li><li>RunLoop生命周期与子线程息息相关,当子线程被销毁时,与之对应的RunLoop也会被销毁.</li><li>子线程的RunLoop要程序员手动开启.</li></ol></li><li>获取RunLoop对象: <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获当前的RunLoop对象</span></span><br><span class="line"><span class="comment">// NSRunLoop</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *runLoop1 = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="comment">// CFRunLoopRef</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> runLoop2 = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="comment">// 2. 拿到当前应用程序的主RunLoop(主线程RunLoop)</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *mainRunLoop = [<span class="built_in">NSRunLoop</span> mainRunLoop];</span><br><span class="line"><span class="built_in">CFRunLoopRef</span> mainRunLoop = <span class="built_in">CFRunLoopGetMain</span>();</span><br></pre></td></tr></table></figure><ul><li>在子线程中如果不主动获取RunLoop的话,那么在子线程内部是不会主动创建RunLoop的.</li><li>在子线程中创建一个RunLoop对象不是通过<code>alloc init</code>方法创建,而是直接调用currentRunLoop方法,而且这个方法本身就是一个懒加载,所以在该线程中RunLoop对象只会被创建一次.</li><li>RunLoop对象是利用字典以当前的线程作为key来进行储存的.</li></ul></li></ul><h2 id="RunLoop相关类"><a href="#RunLoop相关类" class="headerlink" title="RunLoop相关类"></a>RunLoop相关类</h2><ul><li>RunLoop的运行原理<br> <img src="http://r5.loli.io/AzUZFb.png" alt="RunLoop的运行原理图"></li><li>Core Foundation关于RunLoop的五个类<ul><li>CFRunLoopRef (RunLoop抽象类)</li><li>CFRunLoopModeRef (RunLoop的运行模式)</li><li>CFRunLoopSourceRef (RunLoop要处理的事件源)</li><li>CFRunLoopTimerRef (Timer事件)</li><li>CFRunLoopObserverRef (RunLoop的观察者/监听者)</li></ul></li><li>RunLoop和相关类之间的关系图<br><img src="http://r.loli.io/nIFNja.png" alt=""><br> <img src="http://r6.loli.io/AnI3eu.png" alt="RunLoop和相关类之间的关系图"></li></ul><h3 id="RunLoop的运行模式"><a href="#RunLoop的运行模式" class="headerlink" title="RunLoop的运行模式"></a>RunLoop的运行模式</h3><ul><li>每一个RunLoop运行必须要指定一个模式,而且必须要有source和timer,如果子线程的NSRunLoop没有设置source和timer,那么子线程的RunLoop会立刻关闭.</li><li>一个RunLoop可以有多个模式,一个模式可以有多个source\observer\timer.</li><li>如果需要切换mode,只能先退出当前RunLoop,再重新指定一个模式.</li><li>系统默认提供了5个模式:<ul><li>kCFRunLoopDefaultMode: App的默认Mode,通常主线程是在这个Mode下运行,与NSDefaultRunLoopMode等价;</li><li>UITrackingRunLoopMode: 界面跟踪Mode, 用于ScrollView追踪触摸滑动, 保证界面滑动时不受其他Mode影响;</li><li>UIInitializationRunLoopMode: 在刚启动App时第进入的第一个Mode, 启动完成后就不再使用;</li><li>GSEventReceiveRunLoopMode: 接受系统事件的内部Mode, 通常用不到;</li><li>kCFRunLoopCommonModes: 这是一个占位用的Mode,不是一种真正的Mode.</li></ul></li></ul><h3 id="CFRunLoopTimerRef-时间源"><a href="#CFRunLoopTimerRef-时间源" class="headerlink" title="CFRunLoopTimerRef 时间源"></a>CFRunLoopTimerRef 时间源</h3><ul><li>CFRunLoopTimerRef: 它是基于时间的触发器约等于<code>NSTimer</code>, 说直白点那就是时间到了就触发一个事件, 执行一个操作.</li><li>一个mode里面可以添加多个NSTimer,也就是说以后创建NSTimer的时候,可以指定它是在什么模式下运行,从侧面说明了 NSTimer就是CFRunLoopTimerRef.</li><li>在主线程中使用定时器 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建定时器</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 2.1 把定时器添加到runLoop,选择默认运行模式(只有当runLoop处于默认模式时,定时器才工作)</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"><span class="comment">// 2.2 把定时器添加到runLoop,选择界面跟踪模式(只有当runLoop处于界面跟踪模式时,定时器才工作)</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">UITrackingRunLoopMode</span>];</span><br><span class="line"><span class="comment">// 2.3 把定时器添加被标记的RunLoop(意味着当前的定时器会被添加到所有被标记为Common Modes的运行模式下面)</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure></li><li>在子线程中使用定时器 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建子线程RunLoop</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *currentRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="comment">//2.创建定时器对象,会把当前的定时器对象自动添加到runLoop,并设定为默认模式</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer =  [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">//3.子线程对应的runLoop需要手动开启</span></span><br><span class="line">[currentRunLoop run];</span><br></pre></td></tr></table></figure></li><li>GCD中的定时器(注：GCD的定时器跟runloop没有什么关系，它们是两套系统) <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1.创建GCD定时器对象</span></span><br><span class="line"> <span class="comment">// 第一个参数:source的类型DISPATCH_SOURCE_TYPE_TIMER 定时器</span></span><br><span class="line"> <span class="comment">// 第二个参数:描述信息 传递0</span></span><br><span class="line"> <span class="comment">// 第三个参数:详细的描述 传递0</span></span><br><span class="line"> <span class="comment">// 第四个参数:队列,决定定时器调用的方法在哪个线程执行</span></span><br><span class="line"> dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 2.设定时器(开始时间|间隔时间|精准度)</span></span><br><span class="line"> <span class="comment">// 第一个参数:imer 定时器对象</span></span><br><span class="line"> <span class="comment">// 第二个参数:开始计时的时间:DISPATCH_TIME_NOW --从现在开始</span></span><br><span class="line"> <span class="comment">// 第三个参数:间隔时间 2.0</span></span><br><span class="line"> <span class="comment">// 第四个参数:精准度 如果要求对准确的话,传0(误差)</span></span><br><span class="line"> <span class="comment">// GCD时间单位:纳秒</span></span><br><span class="line"> dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 3.定时器要执行的操作</span></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"download ----%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 4.恢复 (启动执行)</span></span><br><span class="line"> dispatch_resume(timer);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// GCD定时器补充 - source的类型</span></span><br><span class="line"> <span class="comment">// DISPATCH_SOURCE_TYPE_TIMER         定时响应（定时器事件）</span></span><br><span class="line"> <span class="comment">// DIPATCH_SOURCE_TYPE_SIGNAL        接收到UNIX信号时响应</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// DISPATCH_SOURE_TYPE_READ          IO操作，如对文件的操作、socket操作的读响应</span></span><br><span class="line"> <span class="comment">// DISPATCH_SOURCE_TYPE_WRITE         IO操作，如对文件的操作、socket操作的写响应</span></span><br><span class="line"> <span class="comment">// DISPATCH_SOURCE_TYPE_VNODE         文件状态监听，文件被删除、移动、重命名</span></span><br><span class="line"> <span class="comment">// DISPATCH_SOURCE_TYPE_PROC          进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 下面两个都属于Mach相关事件响应</span></span><br><span class="line">     <span class="comment">// DISPATCH_SOURCE_TYPE_MACH_SEND</span></span><br><span class="line">     <span class="comment">// DISPATCH_SOURCE_TYPE_MACH_RECV</span></span><br><span class="line"> <span class="comment">// 下面两个都属于自定义的事件，并且也是有自己来触发</span></span><br><span class="line">     <span class="comment">// DISPATCH_SOURCE_TYPE_DATA_ADD</span></span><br><span class="line">     <span class="comment">// DISPATCH_SOURCE_TYPE_DATA_OR</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="CFRunLoopSourceRef-事件源"><a href="#CFRunLoopSourceRef-事件源" class="headerlink" title="CFRunLoopSourceRef 事件源"></a>CFRunLoopSourceRef 事件源</h3><ul><li><p>事件源也就是输入源,可能包括用户输入设备(如点击button),网络链接(socket收到数据),定期或时间延迟事件(NSTimer),还有异步回调(NSURLConnection的异步请求).</p></li><li><p>有两种分类模式:</p><ul><li>一种是按照苹果官方文档进行划分<ul><li>Port-Based Sources</li><li>Custom Input Sources</li><li>Cocoa Perform Selector Sources</li></ul></li><li>一种是基于函数的调用栈来进行划分(source0和source1)<ul><li>Source1: 基于端口(port)的输入源(系统内部调用, 比如线程间通信). 它只包含了一个回调(函数指针), 并不能主动触发事件. 使用时你需要先调用CFRunLoopSourceSignal(source), 将这个Source标记为待处理, 然后手动调用CFRunLoopWakeUp(runloop) 来唤醒RunLoop, 让其处理这个事件.</li><li>Source0: 基于非端口的输入源 (主动触发, 比如用户的交互). 包含了一个mach_port和一个回调(函数指针), 被用于通过内核和其他线程相互发送消息. 这种Source能主动唤醒RunLoop的线程.</li></ul></li></ul></li><li><p>添加输入源<code>[performSelector:OnThread]</code>. Cocoa提供了可以在任一线程执行函数<code>[perform selector]</code>的输入源, 和基于端口的源不同的是, <code>[perform selector]</code>执行完后会自动清除出RunLoop. </p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息给主线程并且是否等待任务执行完成(下面一个方法是指定RunLoop模式)</span></span><br><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:  </span><br><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:modes:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息给指定的线程并且是否等待任务执行完成</span></span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:  </span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:modes:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息给主线程延迟调用方法</span></span><br><span class="line">performSelector:withObject:afterDelay:</span><br><span class="line">performSelector:withObject:afterDelay:inModes:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消当前线程的消息发送</span></span><br><span class="line">cancelPreviousPerformRequestsWithTarget:  </span><br><span class="line">cancelPreviousPerformRequestsWithTarget:selector:object:</span><br></pre></td></tr></table></figure><ul><li>当调用NSObject的<code>performSelecter:afterDelay:</code>后, 实际上其内部会创建一个<code>Timer</code>并添加到当前线程的RunLoop中. 所以如果当前线程没有开启RunLoop, 这个方法则会失效. </li><li>当调用<code>performSelector:onThread:</code>时, 实际上其会创建一个<code>Timer</code>加到对应的线程去, 同样的如果对应线程没有开启RunLoop该方法也会失效.</li></ul></li></ul><h3 id="CFRunLoopObserverRef-观察者"><a href="#CFRunLoopObserverRef-观察者" class="headerlink" title="CFRunLoopObserverRef 观察者"></a>CFRunLoopObserverRef 观察者</h3><ul><li>CFRunLoopObserverRef是观察者,能够监听RunLoop的状态改变</li><li>如何监听 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建观察者</span></span><br><span class="line"><span class="comment">// 第一个参数:分配空间</span></span><br><span class="line"><span class="comment">// 第二个参数:要监听的状态</span></span><br><span class="line"><span class="comment">// 第三个参数:YES 持续监听</span></span><br><span class="line"><span class="comment">// 第四个参数:和优先级相关 总是传递0</span></span><br><span class="line"><span class="comment">// 第五个参数:当发现runLoop状态改变的时候就会调用该block</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"启动runLoop"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"即将处理定时器事件"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"即将处理source事件"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"即将休眠"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"刚从休眠中唤醒"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"runLoop退出"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.给runLoop添加观察者</span></span><br><span class="line"><span class="comment">// 第一个参数:runLoop对象</span></span><br><span class="line"><span class="comment">// 第二个参数:观察者对象</span></span><br><span class="line"><span class="comment">// 第三个参数:运行模式(要监听那种模式下状态的改变)</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);</span><br><span class="line"><span class="comment">// 3.开启定时器</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(demo) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure></li></ul><h2 id="RunLoop运行逻辑详情"><a href="#RunLoop运行逻辑详情" class="headerlink" title="RunLoop运行逻辑详情"></a>RunLoop运行逻辑详情</h2><p><img src="http://r5.loli.io/ZrimYv.png" alt="示意图"><br><img src="http://r6.loli.io/NNn26b.png" alt="逻辑详情"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><p>从上图可以看出:</p><ul><li>如果是事件到达,消息会被传递给相应的处理程序来处理,runLoop处理完当次事件后,runLoop会退出,而不管之前预定的时间到了没有.你可以重新启动runLoop来等待下一事件.</li><li>如果线程中有需要处理的源,但是响应的事件没有到来的时候,线程就会休眠等待相应事件的发生.这就是为什么runLoop可以做到让线程有工作的时候忙于工作,而没工作的时候处于休眠状态.</li></ul></li><li><p>什么时候使用runLoop:</p><ul><li>仅当在为你的程序创建辅助线程的时候,你才需要显式运行一个run loop.RunLoop是程序主线程基础设施的关键部分.所以,Cocoa和Carbon程序提供了代码运行主程序的循环并自动启动runLoop.iOS程序中UIApplication的run方法作为程序启动步骤的一部分,它在程序正常启动的时候就会启动程序的主循环.类似的,RunApplicationEventLoop函数为Carbon程序启动主循环.如果你使用xcode提供的模板创建你的程序,那你永远不需要自己去显式的调用这些例程.</li><li>对于辅助线程,你需要判断一个runLoop是否是必须的.如果是必须的,那么你要自己配置并启动它.你不需要在任何情况下都去启动一个线程的runLoop.比如.你使用线程来处理一个预先定义的长时间运行的任务时,你应该避免启动runLoop.RunLoop在你要和线程有更多的交互时才需要,比如以下情况:<ul><li>使用端口或自定义输入源来和其他线程通信</li><li>使用线程的定时器</li><li>Cocoa中使用任何performSelector…的方法</li><li>使线程周期性工作.</li></ul></li></ul></li><li><p>AFNetWorking 这个框架就是这么干的, 当第一次创建一个manager单例时, 它就会开辟一个子线程同时开启一个runloop, 然后手动维护这个runloop, 来持续监听事件的接收.<br> <img src="http://r5.loli.io/aYZnYf.png" alt=""></p></li></ul><p>参考: <a href="http://www.cocoachina.com/ios/20150601/11970.html" target="_blank" rel="noopener">深入理解RunLoop</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是RunLoop&quot;&gt;&lt;a href=&quot;#什么是RunLoop&quot; class=&quot;headerlink&quot; title=&quot;什么是RunLoop&quot;&gt;&lt;/a&gt;什么是RunLoop&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;RunLoop: 运行循环, 顾名思义就是跑圈, 兜圈子的意思.
      
    
    </summary>
    
    
    
      <category term="iOS干货" scheme="https://xionw1991.github.io/tags/iOS%E5%B9%B2%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>封装NavigationController基类</title>
    <link href="https://xionw1991.github.io/2015/08/06/blog/36.%E5%B0%81%E8%A3%85NavigationController%E5%9F%BA%E7%B1%BB/"/>
    <id>https://xionw1991.github.io/2015/08/06/blog/36.%E5%B0%81%E8%A3%85NavigationController%E5%9F%BA%E7%B1%BB/</id>
    <published>2015-08-06T04:47:57.000Z</published>
    <updated>2020-06-23T15:10:32.174Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>目前绝大多数应用的各个子控制器的NavigationBar都是是统一风格的,封装Nav一劳永逸.</p></blockquote><ul><li><p>第一步</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在第一次使用这个类的时候初始化成员属性</span></span><br><span class="line">+ (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 获取所有导航控制器的bar实例</span></span><br><span class="line">    <span class="built_in">UINavigationBar</span> *navbar = [<span class="built_in">UINavigationBar</span> appearance];</span><br><span class="line">    <span class="comment">// 1.1 设置导航条字体</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    dict[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">17</span>];</span><br><span class="line">    [navbar setTitleTextAttributes:dict];</span><br><span class="line">    <span class="comment">// 1.2 设置导航条背景图片</span></span><br><span class="line">    [navbar setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"navigationbar_background_landscape"</span>] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">    <span class="comment">// 1.3 设置导航栏分割线为透明</span></span><br><span class="line">    [navbar setShadowImage:[[<span class="built_in">UIImage</span> alloc] init]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取所有导航控制器的item实例</span></span><br><span class="line">    <span class="built_in">UIBarButtonItem</span> *barBtn = [<span class="built_in">UIBarButtonItem</span> appearance];</span><br><span class="line">    <span class="comment">// 2.1 设置barButton的文字普通状态下的属性</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *barBtnAttributesN = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    barBtnAttributesN[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">    barBtnAttributesN[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">        <span class="comment">// 设置普通状态</span></span><br><span class="line">    [barBtn setTitleTextAttributes:barBtnAttributesN forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    <span class="comment">// 2.2 设置barButton的文字不可用状态下的属性</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *barBtnAttributesS = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    barBtnAttributesS[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    barBtnAttributesS[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">        <span class="comment">// 设置不可用状态</span></span><br><span class="line">    [barBtn setTitleTextAttributes:barBtnAttributesS forState:<span class="built_in">UIControlStateDisabled</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二步</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 添加一个边缘滑动手势</span></span><br><span class="line">    <span class="built_in">UIScreenEdgePanGestureRecognizer</span> *edgePan = [[<span class="built_in">UIScreenEdgePanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(edgePan:)];</span><br><span class="line">    edgePan.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 方向为左划</span></span><br><span class="line">    edgePan.edges = <span class="built_in">UIRectEdgeLeft</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:edgePan];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 监听手势方法</span></span><br><span class="line">- (<span class="keyword">void</span>)edgePan:(<span class="built_in">UIScreenEdgePanGestureRecognizer</span> *)edgePan</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第三步</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写push方法</span></span><br><span class="line">- (<span class="keyword">void</span>)pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当不是根控制器时</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.viewControllers.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 隐藏tabBar</span></span><br><span class="line">        viewController.hidesBottomBarWhenPushed = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">// 自定义导航栏左边按钮</span></span><br><span class="line">        <span class="built_in">UIButton</span> *leftBtn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">        [leftBtn setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"navigationbar_back"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        [leftBtn setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"navigationbar_back_highlighted"</span>] forState:<span class="built_in">UIControlStateHighlighted</span>];</span><br><span class="line">        [leftBtn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(backPress) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">        [leftBtn sizeToFit];</span><br><span class="line">        viewController.navigationItem.leftBarButtonItem = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithCustomView:leftBtn];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置完毕后调用父类的push方法</span></span><br><span class="line">    [<span class="keyword">super</span> pushViewController:viewController animated:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)backPress</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第四步</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - UIGestureRecognizerDelegate</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不允许在根控制器使用返回手势</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.childViewControllers.count &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;目前绝大多数应用的各个子控制器的NavigationBar都是是统一风格的,封装Nav一劳永逸.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一步&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table
      
    
    </summary>
    
    
    
      <category term="iOS开发笔记" scheme="https://xionw1991.github.io/tags/iOS%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>单例设计模式</title>
    <link href="https://xionw1991.github.io/2015/08/03/blog/35.Singleton/"/>
    <id>https://xionw1991.github.io/2015/08/03/blog/35.Singleton/</id>
    <published>2015-08-03T13:27:57.000Z</published>
    <updated>2020-06-23T15:17:29.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式概念"><a href="#单例模式概念" class="headerlink" title="单例模式概念"></a>单例模式概念</h2><ul><li><p>什么是单例模式:(Singleton)</p><ul><li>单例模式的意图是让类的对象成为系统中唯一的实例,􏰀供一个访问点,供客户类共享资源。</li></ul></li><li><p>什么情况下使用单例?</p><ul><li>1、类只能有一个实例,而且必须从一个为人熟知的访问点对其进行访问,比如工厂方法。</li><li>2、这个唯一的实例只能通过子类化进行扩展,而且扩展的对象不会破坏客户端代码。</li></ul></li><li><p>单例设计模式的要点:</p><ul><li>1) 某个类只能有一个实例;</li><li>2) 他必须自行创建这个对象;</li><li>3) 必须自行向整个系统􏰀供这个实例;</li><li>4) 为了保证实例的唯一性,我们必须将;</li><li>5) 这个方法必须是一个静态类;</li></ul></li></ul><h2 id="单例模式宏-预处理ARC和MRC"><a href="#单例模式宏-预处理ARC和MRC" class="headerlink" title="单例模式宏,预处理ARC和MRC"></a>单例模式宏,预处理ARC和MRC</h2><a id="more"></a><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> interfaceSingleton(name)  +(instancetype)share##name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(objc_arc)</span></span><br><span class="line"><span class="comment">// ARC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> implementationSingleton(name)  \</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)share#<span class="meta">#name \</span></span><br><span class="line">&#123; \</span><br><span class="line">name *instance = [[<span class="keyword">self</span> alloc] init]; \</span><br><span class="line"><span class="keyword">return</span> instance; \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">static</span> name *_instance = <span class="literal">nil</span>; \</span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">_instance = [[<span class="keyword">super</span> allocWithZone:zone] init]; \</span><br><span class="line">&#125;); \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone&#123; \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// MRC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> implementationSingleton(name)  \</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)share#<span class="meta">#name \</span></span><br><span class="line">&#123; \</span><br><span class="line">name *instance = [[<span class="keyword">self</span> alloc] init]; \</span><br><span class="line"><span class="keyword">return</span> instance; \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">static</span> name *_instance = <span class="literal">nil</span>; \</span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">_instance = [[<span class="keyword">super</span> allocWithZone:zone] init]; \</span><br><span class="line">&#125;); \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone&#123; \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>)release \</span><br><span class="line">&#123; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="keyword">instancetype</span>)<span class="keyword">retain</span> \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">return</span>  MAXFLOAT; \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例模式概念&quot;&gt;&lt;a href=&quot;#单例模式概念&quot; class=&quot;headerlink&quot; title=&quot;单例模式概念&quot;&gt;&lt;/a&gt;单例模式概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是单例模式:(Singleton)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单例模式的意图是让类的对象成为系统中唯一的实例,􏰀供一个访问点,供客户类共享资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么情况下使用单例?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、类只能有一个实例,而且必须从一个为人熟知的访问点对其进行访问,比如工厂方法。&lt;/li&gt;
&lt;li&gt;2、这个唯一的实例只能通过子类化进行扩展,而且扩展的对象不会破坏客户端代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;单例设计模式的要点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1) 某个类只能有一个实例;&lt;/li&gt;
&lt;li&gt;2) 他必须自行创建这个对象;&lt;/li&gt;
&lt;li&gt;3) 必须自行向整个系统􏰀供这个实例;&lt;/li&gt;
&lt;li&gt;4) 为了保证实例的唯一性,我们必须将;&lt;/li&gt;
&lt;li&gt;5) 这个方法必须是一个静态类;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;单例模式宏-预处理ARC和MRC&quot;&gt;&lt;a href=&quot;#单例模式宏-预处理ARC和MRC&quot; class=&quot;headerlink&quot; title=&quot;单例模式宏,预处理ARC和MRC&quot;&gt;&lt;/a&gt;单例模式宏,预处理ARC和MRC&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="iOS开发笔记" scheme="https://xionw1991.github.io/tags/iOS%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>UIButton调换文字与图片位置的两种方法</title>
    <link href="https://xionw1991.github.io/2015/08/02/blog/34.UIButton%E8%B0%83%E6%8D%A2%E6%96%87%E5%AD%97%E4%B8%8E%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://xionw1991.github.io/2015/08/02/blog/34.UIButton%E8%B0%83%E6%8D%A2%E6%96%87%E5%AD%97%E4%B8%8E%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2015-08-02T02:12:57.000Z</published>
    <updated>2020-06-23T15:17:41.746Z</updated>
    
    <content type="html"><![CDATA[<p>假设自定义一个UIButton控件, 然后在button里面初始化了一个title和一个image:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置button文字</span></span><br><span class="line">        [<span class="keyword">self</span> setTitle:<span class="string">@"title"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        <span class="comment">// 设置button图片</span></span><br><span class="line">        [<span class="keyword">self</span> setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        <span class="comment">// 设置文字大小</span></span><br><span class="line">        <span class="keyword">self</span>.titleLabel.font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">17</span>];</span><br><span class="line">        <span class="comment">// 设置图片居中</span></span><br><span class="line">        <span class="keyword">self</span>.imageView.contentMode = <span class="built_in">UIViewContentModeCenter</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一种-重写layoutSubviews方法来实现"><a href="#第一种-重写layoutSubviews方法来实现" class="headerlink" title="第一种 - 重写layoutSubviews方法来实现"></a>第一种 - 重写<code>layoutSubviews</code>方法来实现</h3><ol><li>重写<code>layoutSubviews</code>方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    <span class="comment">// 修改titleButton里面子控件的位置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.imageView.frame.origin.x &lt; <span class="keyword">self</span>.titleLabel.frame.origin.x) &#123; </span><br><span class="line">        <span class="comment">// 1. 取出title和image的frame</span></span><br><span class="line">        <span class="built_in">CGRect</span> titleFrame = <span class="keyword">self</span>.titleLabel.frame;</span><br><span class="line">        <span class="built_in">CGRect</span> imageFrame = <span class="keyword">self</span>.imageView.frame;</span><br><span class="line">        <span class="comment">// 2. 调整title和imageView的x值</span></span><br><span class="line">        titleFrame.origin.x = imageFrame.origin.x;</span><br><span class="line">        imageFrame.origin.x = <span class="built_in">CGRectGetMaxX</span>(titleFrame) + <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 3. 重新赋值</span></span><br><span class="line">        <span class="keyword">self</span>.titleLabel.frame = titleFrame;</span><br><span class="line">        <span class="keyword">self</span>.imageView.frame = imageFrame;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>重写<code>setImage: forState:</code>和<code>setTitle: forState:</code>方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写父类setImage方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setImage:(<span class="built_in">UIImage</span> *)image forState:(<span class="built_in">UIControlState</span>)state</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setImage:image forState:state];</span><br><span class="line">    <span class="comment">// 自动计算尺寸</span></span><br><span class="line">    [<span class="keyword">self</span> sizeToFit];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 重写父类setTitle方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setTitle:(<span class="built_in">NSString</span> *)title forState:(<span class="built_in">UIControlState</span>)state</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setTitle:title forState:state];</span><br><span class="line">    <span class="comment">// 自动计算尺寸</span></span><br><span class="line">    [<span class="keyword">self</span> sizeToFit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="第二种-重写titleRectForContentRect-和imageRectForContentRect-方法来实现"><a href="#第二种-重写titleRectForContentRect-和imageRectForContentRect-方法来实现" class="headerlink" title="第二种 - 重写titleRectForContentRect:和imageRectForContentRect:方法来实现"></a>第二种 - 重写<code>titleRectForContentRect:</code>和<code>imageRectForContentRect:</code>方法来实现</h3><ol><li>重写<code>titleRectForContentRect:</code>方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回文字的位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)titleRectForContentRect:(<span class="built_in">CGRect</span>)contentRect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> titleX = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> titleY = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> titleW = [<span class="keyword">self</span>.currentTitle boundingRectWithSize:<span class="built_in">CGSizeMake</span>(MAXFLOAT, MAXFLOAT)</span><br><span class="line">                                                     options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span></span><br><span class="line">                                                  attributes:@&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">17</span>]&#125;</span><br><span class="line">                                                     context:<span class="literal">nil</span>].size.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> titleH = contentRect.size.height;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(titleX, titleY, titleW, titleH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>重写<code>imageRectForContentRect:</code>方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回图片位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)imageRectForContentRect:(<span class="built_in">CGRect</span>)contentRect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageW = <span class="number">16</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageH = contentRect.size.height;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageX = contentRect.size.width - imageW;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageY = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(imageX, imageY, imageW, imageH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设自定义一个UIButton控件, 然后在button里面初始化了一个title和一个image:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
    
    
      <category term="iOS开发笔记" scheme="https://xionw1991.github.io/tags/iOS%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>GCD的一些总结</title>
    <link href="https://xionw1991.github.io/2015/07/21/blog/33.GCD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://xionw1991.github.io/2015/07/21/blog/33.GCD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</id>
    <published>2015-07-21T02:09:57.000Z</published>
    <updated>2020-06-23T15:17:52.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列与任务"><a href="#队列与任务" class="headerlink" title="队列与任务"></a>队列与任务</h2><ul><li>同步: 同步任务,不开新线程,会阻塞当前线程.</li><li>异步: 异步任务,开新线程,不会阻塞当前线程.</li><li>串行: 串行队列,串行是按顺序排队执行任务,不会出现资源抢夺的问题,所以它默认是线程安全的.</li><li>并行: 并行队列,多条线程同时执行任务,可能会导致多条线程抢夺同一块资源.所以它默认是线程不安全的,所以在一条线程访问一块资源时需要进行加锁处理;<br><img src="http://r6.loli.io/If22Iv.png" alt=""></li></ul><h3 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h3><ul><li>主队列 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> main_queue= dispatch_get_main_queue();</span><br></pre></td></tr></table></figure><ol><li>所有与UI界面相关的操作都在主队列中执行.</li><li>主队列只有一条主线程,所以它默认是串行的.</li><li>在主队列中执行异步函数并不会开新的线程,所有任务默认都是在主线程执行.</li><li>不要在主队列中执行同步函数,这样会产生死锁的问题.因为主队列默认只有一条主线程,如果在主队列添加一个同步任务,会马上执行这个同步任务.而主队列当前要执行的任务并没有结束,不肯放手.两个的优先级都很高,最终导致死锁.<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主线程执行一个同步函数 - 会发生死锁</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(main_queue, ^&#123;</span><br><span class="line">    <span class="comment">// 这句代码永远不会执行</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这句代码永远不会执行</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"方法执行完毕"</span>);</span><br></pre></td></tr></table></figure></li><li>如果在主队列执行异步函数,那么异步函数要执行的任务会被排到队列的后面,只有当目前这个方法执行完毕后才会过来执行这个任务,如果有多个异步函数,那么任务会依次添加进队列并按顺序执行.<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主线程执行异步函数</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(main_queue, ^&#123;</span><br><span class="line">    <span class="comment">// 再执行这一句</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 先执行这一句</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"方法执行完毕"</span>);</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="非主队列"><a href="#非主队列" class="headerlink" title="非主队列"></a>非主队列</h3><ul><li>非主队列<ul><li>创建串行非主队列 (默认)<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"my_queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure></li><li>创建并行非主队列<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> concurrent_queue = dispatch_queue_create(<span class="string">"my_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure></li><li>陷阱1<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在非主队列串行执行一个异步函数</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务开始: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="comment">// 执行异步函数</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</span><br><span class="line">        <span class="comment">/* 这句永远不会执行 */</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务1: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行同步函数</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</span><br><span class="line">        <span class="comment">/* 这句永远不会执行 */</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务2: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/* 这句永远不会执行 */</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务执行完毕"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"方法执行完毕"</span>);</span><br></pre></td></tr></table></figure>结果: 最后的这个线程会发生死锁.<br><br>分析: 非主队列串行执行异步函数, 这个队列只会开启一条新线程执行任务.<br><br>任务1是一个异步任务,不会阻塞当前线程,执行打它时,它会被挂起,等当前队列所有的同步任务执行完毕后再过来执行它.<br><br>任务2是一个同步任务,同步任务优先级很高,需要马上执行.但是外层的函数并没有执行完毕,不肯放手,所以导致了死锁.</li><li>陷阱2<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在非主队列并行执行一个异步函数</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务开始: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="comment">// 执行异步函数</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务1: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行同步函数</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="comment">// 当前任务睡2秒</span></span><br><span class="line">        sleep(<span class="number">2.0</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务2: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行异步函数</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务3: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务执行完毕"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"方法执行完毕"</span>);</span><br></pre></td></tr></table></figure></li><li>最后的执行顺序是: <ul><li>任务2 -&gt; 任务1 -&gt; 任务3 -&gt; 打印”任务执行完毕”.</li><li>任务1 -&gt; 任务2 -&gt; 打印”任务执行完毕” -&gt; 任务3.<br></li></ul></li><li>分析: <ul><li>非主队列并发执行异步函数, 可能会开多条线程执行任务.</li><li>任务1和任务2的运行优先级是一样的,只是任务1会开启一个新的线程来执行,而任务2是同步函数只会在当前线程执行,并且会阻塞当前线程.</li><li>任务3是一个异步函数,它排在任务2之后,而任务2是一个同步函数阻塞了当前线程,所以必须要等任务2执行完毕后才能执行.</li></ul></li><li>思考: <ul><li>为什么在并发队列中执行同步函数不会死锁?</li><li>在并发队列中执行同步函数是不是就能起到跟栅栏函数一样的作用?</li><li>在并发队列中,当前线程起着两个作用,一个是执行任务,另一个是分配线程执行任务.</li></ul></li></ul></li></ul><h3 id="全局并发队列"><a href="#全局并发队列" class="headerlink" title="全局并发队列"></a>全局并发队列</h3><ul><li>全局并发队列<ul><li>默认全局来管理并发,类似于自己创建并发队列,可以设置线程调度的优先级,但是一般情况下不建议这么做.因为可能会引发<code>优先级反转</code>.</li></ul></li></ul><h2 id="GCD的一些常用函数"><a href="#GCD的一些常用函数" class="headerlink" title="GCD的一些常用函数"></a>GCD的一些常用函数</h2><ul><li>通过GCD, 开发者不用再直接跟线程打交道了, 只需要向队列中添加代码块即可, GCD 在后端管理着一个线程池. GCD不仅决定着你的代码块将在哪个线程被执行, 它还根据可用的系统资源对这些线程进行管理. 这样可以将开发者从线程管理的工作中解放出来, 通过集中的管理线程, 来缓解大量线程被创建的问题.</li><li>GCD 带来的另一个重要改变是, 作为开发者可以将工作考虑为一个队列, 而不是一堆线程, 这种并行的抽象模型更容易掌握和使用.</li></ul><h3 id="dispatch-after延迟函数"><a href="#dispatch-after延迟函数" class="headerlink" title="dispatch_after延迟函数"></a>dispatch_after延迟函数</h3><ul><li>利用<code>dispatch_after</code>函数延时执行任务 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主队列延迟2秒后提交任务(这里的时间单位是纳秒)</span></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"在主队列延迟2秒执行"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>利用<code>performSelector: withObject: afterDelay:</code>延时执行任务 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(run:) withObject:<span class="string">@"延时两秒运行中..."</span> afterDelay:<span class="number">2.0</span>];</span><br></pre></td></tr></table></figure></li><li>利用<code>NSTimer</code>延时执行任务 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) userInfo:<span class="string">@"延时两秒运行中..."</span> repeats:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure></li></ul><h3 id="dispatch-once一次性函数"><a href="#dispatch-once一次性函数" class="headerlink" title="dispatch_once一次性函数"></a>dispatch_once一次性函数</h3><ul><li>一次性代码 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dispatch_once 保证代码在程序中只执行一次</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我只会执行一次"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>使用GCD实现单例 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止外部文件引用变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> musicRadio;</span><br><span class="line"><span class="comment">// 单例模式的核心就是 重写alloc</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="comment">// GCD实现单例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        musicRadio = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> musicRadio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用懒加载和同步锁实现单例 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> musicRadio;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加同步锁防止资源抢夺</span></span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (musicRadio == <span class="literal">nil</span>) &#123;</span><br><span class="line">        musicRadio = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> musicRadio;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 工厂方法</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareMusicRadio</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 防止多次加锁</span></span><br><span class="line">    <span class="keyword">if</span> (musicRadio == <span class="literal">nil</span>) &#123; </span><br><span class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (musicRadio == <span class="literal">nil</span>) &#123; <span class="comment">// 防止多次init</span></span><br><span class="line">                musicRadio = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> musicRadio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>参考: <a href="http://xionv.com/2015/11/29/demonayu/blog/Singleton/" target="_blank" rel="noopener">单例模式宏</a></li></ul><h3 id="dispatch-barrier栅栏函数"><a href="#dispatch-barrier栅栏函数" class="headerlink" title="dispatch_barrier栅栏函数"></a>dispatch_barrier栅栏函数</h3><ul><li>栅栏函数作用: 在并发队列中实现阻塞.</li><li>要想执行完前面所有的任务再执行barrier必须满足两个条件: <ul><li>所有任务都是在同一个队列中.</li><li>队列不能是全局并行队列, 必须是自己创建的队列.</li></ul></li><li>在串行队列中执行同步栅栏函数会发生死锁 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(serial_queue, ^&#123;</span><br><span class="line">    dispatch_barrier_sync(serial_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"会死锁!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>下面示例代码中, 只有等任务3完成后任务4和任务5才能执行. <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个并发的队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrent_queue = dispatch_queue_create(<span class="string">"my_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">// 执行异步函数</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务开始: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务1: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务2: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行栅栏函数</span></span><br><span class="line">    dispatch_barrier_async(concurrent_queue, ^&#123;</span><br><span class="line">        sleep(<span class="number">2.0</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务3: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务4: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrent_queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务5: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务完毕"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="dispatch-apply迭代函数"><a href="#dispatch-apply迭代函数" class="headerlink" title="dispatch_apply迭代函数"></a>dispatch_apply迭代函数</h3><ul><li>因为GCD的快速迭代是多线程并发的, 所以速度要快于普通的循环结构. <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1: 迭代次数</span></span><br><span class="line"><span class="comment">// 参数2: 执行的队列</span></span><br><span class="line"><span class="comment">// 参数3: 当前迭代的索引</span></span><br><span class="line">dispatch_apply(<span class="number">20</span>, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^(size_t index) &#123;</span><br><span class="line">    <span class="comment">//...需要迭代的代码, 迭代顺序并不确定</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>注意: 应该避免在串行队列中嵌套使用<code>dispatch_apply</code>, 会引发死锁.下面示例代码打印会永远停留在<code>第一层循环 - 0</code> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"my_queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_apply(<span class="number">5</span>, serial_queue, ^(size_t i) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一层循环 - %ld"</span>, i);</span><br><span class="line">    dispatch_apply(<span class="number">5</span>, serial_queue, ^(size_t j) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二层循环 - %ld"</span>, j);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行完毕 - %ld"</span>, i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="dispatch-group队列组函数"><a href="#dispatch-group队列组函数" class="headerlink" title="dispatch_group队列组函数"></a>dispatch_group队列组函数</h3><ul><li>很多时候我们需要等待一系列任务执行完成后, 再做一些收尾的工作. 在串行队列中很容易办到, 如果在并行队列中使用组函数也可以达到这样的效果.</li><li>组函数简单使用 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个队列组函数</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="comment">// 获得当前全局队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 执行组函数</span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 当所有组函数执行完毕后执行dispatch_group_notify</span></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当任务1和任务2执行完毕后通知执行任务3: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="暂停和恢复队列"><a href="#暂停和恢复队列" class="headerlink" title="暂停和恢复队列"></a>暂停和恢复队列</h3><ul><li>暂停(挂起)队列 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_suspend(concurrent_queue);</span><br></pre></td></tr></table></figure></li><li>恢复队列 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_resume(concurrent_queue);</span><br></pre></td></tr></table></figure></li><li>注意: dispatch_suspend并不会立即暂停正在运行的block, 而是在当前block执行完成后, 暂停后续的block执行.</li></ul><p>参考:</p><ul><li><a href="http://objccn.io/issue-2-1/" target="_blank" rel="noopener">并发编程：API 及挑战</a></li><li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md" target="_blank" rel="noopener">GCD高级用法</a></li><li><a href="http://tutuge.me/2015/04/03/something-about-gcd/" target="_blank" rel="noopener">GCD使用经验与技巧浅谈</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;队列与任务&quot;&gt;&lt;a href=&quot;#队列与任务&quot; class=&quot;headerlink&quot; title=&quot;队列与任务&quot;&gt;&lt;/a&gt;队列与任务&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;同步: 同步任务,不开新线程,会阻塞当前线程.&lt;/li&gt;
&lt;li&gt;异步: 异步任务,开新线程,不会阻塞当
      
    
    </summary>
    
    
    
      <category term="iOS干货" scheme="https://xionw1991.github.io/tags/iOS%E5%B9%B2%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>NSURLConnection和NSURLSession</title>
    <link href="https://xionw1991.github.io/2015/07/19/blog/32.NSURLConnection%E5%92%8CNSURLSession%E6%80%9D%E8%80%83/"/>
    <id>https://xionw1991.github.io/2015/07/19/blog/32.NSURLConnection%E5%92%8CNSURLSession%E6%80%9D%E8%80%83/</id>
    <published>2015-07-19T14:09:57.000Z</published>
    <updated>2020-06-23T15:18:02.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>有两种请求方式:<ul><li>使用block回调:<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用类方法发送一个异步请求,然后用block回调</span></span><br><span class="line">[<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSError</span> * _Nullable connectionError) &#123;</span><br><span class="line">    <span class="comment">//... 处理返回结果</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li><li>使用代理方法监听:<ol><li>发送一个请求并指定代理<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用代理监听有两种发送请求的方式 */</span></span><br><span class="line"><span class="comment">// 1. 发送请求指定代理,并且立即发送请求</span></span><br><span class="line"><span class="keyword">self</span>.connection = [<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 当startImmediately为NO时,请求不会立即执行,而是要等待start方法</span></span><br><span class="line"><span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</span><br><span class="line"><span class="comment">// 开始发送请求</span></span><br><span class="line">[<span class="keyword">self</span>.connection start];</span><br></pre></td></tr></table></figure></li><li>使用代理方法来监听请求返回的结果<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"收到响应"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> - (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"收到数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> - (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"下载完成"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul><h3 id="trap1"><a href="#trap1" class="headerlink" title="trap1"></a>trap1</h3><ul><li>在主队列中执行请求<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>]</span><br></pre></td></tr></table></figure><ul><li>分析: 上面这段代码分别执行了几个步骤:<ol><li>在当前队列(主队列)建立一个请求任务;</li><li>将请求任务放入当前队列线程的runloop,并且指定运行模式为默认模式;</li><li>开始发送一个异步下载请求.</li></ol></li><li>测试: 在主队列中发送请求,如果此时拖拽界面的控件,下载任务会暂停,停止拖拽后下载任务会自动恢复. 如果<code>指定代理方法在主队列调用</code>或者<code>设定任务在runloop中的调度方式</code>那么会产生不一样的结果.<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定代理方法在主队列</span></span><br><span class="line">[<span class="keyword">self</span>.connection setDelegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</span><br><span class="line"><span class="comment">// 或者: 指定调度模式为 forMode:NSRunLoopCommonModes</span></span><br><span class="line">[<span class="keyword">self</span>.connection scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>此时如果拖拽界面并不会阻塞下载任务的执行.</li><li>猜测: 在主队列中发送connection请求是异步的,而且始终只有一条线程就是主线程在执行这个任务.</li><li>最后: 在本地使用NSURLConnection下载一个288M的视频文件大概耗时3s左右.如果在子线程进行下载大概耗时1s左右.</li></ul></li></ul><h3 id="trap2"><a href="#trap2" class="headerlink" title="trap2"></a>trap2</h3><ul><li>在非主队列中执行发送请求和下载操作 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在全局队列中发送一个异步请求</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 直接开始发送请求</span></span><br><span class="line">    <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:request delegate:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 在子线程中调用代理方法</span></span><br><span class="line">    [<span class="keyword">self</span>.connection setDelegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> 分析: 在上面的代码中, connection的代理方法不会被调用, 因为下载操作是一个持续性的操作, 需要保证执行任务的线程不会被释放,如果指定代理方法在子线程中调用,那么需要在该线程中开启一个runloop才能保证持续接收到返回的数据(原理与在主队列发送请求一样).</li><li>改进 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在全局队列中发送一个异步请求</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 发送一个请求并不马上执行</span></span><br><span class="line">    <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</span><br><span class="line">    <span class="comment">// 在子线程中调用代理方法</span></span><br><span class="line">    [<span class="keyword">self</span>.connection setDelegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">    <span class="comment">// 开始发送请求 - 注:如果是在子线程发送一个请求那么这个方法会默认在子线程开启一个runloop.</span></span><br><span class="line">    [<span class="keyword">self</span>.connection start];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> 分析: <code>start</code>方法会在子线程中开启一个runloop来持续接收事件源的输入.调用<code>start</code>方法时要保证至少有一个事件源来驱动runloop的运行.</li></ul><h3 id="大文件下载-断点续传"><a href="#大文件下载-断点续传" class="headerlink" title="大文件下载 + 断点续传"></a>大文件下载 + 断点续传</h3><ul><li>在使用NSURLConnection进行大文件下载时,如果不进行手动处理的话会消耗大量内存直至程序崩溃.</li><li>要进行内存优化必须要使用代理方法来监听下载进度.</li><li>核心思想:边下载边存沙盒,拿到当前文件的信息然后拼接.</li><li>核心步骤:<ol><li>初始化一个可变的请求对象并设置请求头信息<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://abc.com/videos/video_01"</span>];</span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line"><span class="comment">// 使用一个全局变量 currentLength 来记录已经下载的字节数</span></span><br><span class="line"><span class="comment">// 设置请求头, 根据数据进度拼接请求, 来判断断点下载的开始范围 ** 断点续传核心代码</span></span><br><span class="line"><span class="built_in">NSString</span> *range = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"bytes=%lld-"</span>, <span class="keyword">self</span>.currentLength];</span><br><span class="line">[request setValue:range forHTTPHeaderField:<span class="string">@"Range"</span>];</span><br></pre></td></tr></table></figure></li><li>在代理方法<code>didReceiveResponse:</code>新建沙盒文件<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 防止文件重复写入, 当已经有数据就不再创建新文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.currentLength) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 新建一个空的缓存文件</span></span><br><span class="line">    <span class="built_in">NSString</span> *cache = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">    <span class="built_in">NSString</span> *filePath = [cache stringByAppendingPathComponent:response.suggestedFilename];</span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] createFileAtPath:filePath contents:<span class="literal">nil</span> attributes:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// 定义一个句柄成员变量来记录已经下载文件的信息</span></span><br><span class="line">    <span class="keyword">self</span>.handle = [<span class="built_in">NSFileHandle</span> fileHandleForWritingAtPath:filePath];</span><br><span class="line">    <span class="comment">// 根据响应头获得文件总大小</span></span><br><span class="line">    <span class="keyword">self</span>.totalLength = response.expectedContentLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在代理方法<code>didReceiveData:</code>拼接文件<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将写入位置移到文件末尾</span></span><br><span class="line">    [<span class="keyword">self</span>.handle seekToEndOfFile];</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    [<span class="keyword">self</span>.handle writeData:data];</span><br><span class="line">    <span class="comment">// 记录已经下载文件大小</span></span><br><span class="line">    <span class="keyword">self</span>.currentLength += data.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>下载完成后需要处理的事情<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.currentLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">self</span>.totalLength = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 文件下载完毕后释放文件句柄</span></span><br><span class="line">    [<span class="keyword">self</span>.handle closeFile];</span><br><span class="line">    <span class="keyword">self</span>.handle = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意: 断点续传暂停时要清空当前的下载操作<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)suspend &#123;</span><br><span class="line">    [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">    <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h2><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>NSURLSession的几种任务模式<br><img src="http://techdoc.fd.zol-img.com.cn/g4/M01/02/07/Cg-4WlKjd1eIB4piAAF0o6rDWYsAAOIzwON0NgAAXS7235.png" alt=""> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类-不具备执行任务功能</span></span><br><span class="line"><span class="built_in">NSURLSessionTask</span></span><br><span class="line"><span class="comment">// 执行普通的GET/POST请求任务</span></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span></span><br><span class="line"><span class="comment">// 执行下载请求任务</span></span><br><span class="line"><span class="built_in">NSURLSessionDownloadTask</span></span><br><span class="line"><span class="comment">// 执行上传请求任务</span></span><br><span class="line"><span class="built_in">NSURLSessionUploadTask</span></span><br></pre></td></tr></table></figure></li><li>NSURLSession工作模式<ul><li>一般模式(default): 工作模式类似于原来的NSURLConnection,可以使用缓存的Cache,Cookie,鉴权.</li><li>及时模式(ephemeral): 不使用缓存的Cache,Cookie,鉴权.</li><li>后台模式(background): 在后台完成上传下载,创建Configuration对象的时候需要给一个NSString的ID用于追踪完成工作的Session是哪一个.</li></ul></li><li>两种请求方式<ul><li>使用block回调:<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始一个会话对象(session)</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"><span class="comment">// 2. 初始化一个data任务</span></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *dataTask = [session dataTaskWithURL:url completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//... 处理返回结果</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 3. 开始任务</span></span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure></li><li>使用代理方法监听: <ol><li>发送一个请求并指定代理<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化session的工作模式</span></span><br><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *cgr = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line"><span class="comment">// 2. 初始化session并指定代理, 指定调用代理方法的线程</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:cgr delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</span><br><span class="line"><span class="comment">// 3. 初始化一个data任务</span></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *datatask = [session dataTaskWithURL:url];</span><br><span class="line"><span class="comment">// 4. 开始任务</span></span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure></li><li>使用代理方法来监听请求返回的结果<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"收到响应"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> - (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"收到数据"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul><h3 id="大文件下载-断点续传-1"><a href="#大文件下载-断点续传-1" class="headerlink" title="大文件下载 + 断点续传"></a>大文件下载 + 断点续传</h3><ul><li>NSURLSession已经默认实现大文件下载和断点续传.其原理也是沙盒缓存原理.</li><li>也就是说执行下面的操作并不会暴涨内存,系统已经在内部优化好了. <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.session downloadTaskWithURL:url];</span><br></pre></td></tr></table></figure></li><li>在执行下载操作时系统默认会把下载的文件存放到沙盒的temp文件夹,如果不进行处理会马上将文件删掉.</li><li>核心步骤:<ol><li>暂停任务<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)suspend</span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// resumeData包含了继续下载的开始位置和下载的url等信息</span></span><br><span class="line">    [<span class="keyword">self</span>.task cancelByProducingResumeData:^(<span class="built_in">NSData</span> *resumeData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, resumeData.length);</span><br><span class="line">        weakself.resumeData = resumeData;</span><br><span class="line">        <span class="comment">// 将task清空释放内存</span></span><br><span class="line">        weakself.task = <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>恢复任务<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)resume</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 传入上次暂停下载返回的数据，恢复下载 从resumeData接着下载</span></span><br><span class="line">    <span class="keyword">self</span>.task = [<span class="keyword">self</span>.session downloadTaskWithResumeData:<span class="keyword">self</span>.resumeData];</span><br><span class="line">    [<span class="keyword">self</span>.task resume];</span><br><span class="line">    <span class="comment">// 将恢复信息释放</span></span><br><span class="line">    <span class="keyword">self</span>.resumeData = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在代理方法<code>didFinishDownloadingToURL:</code>转移文件<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标文件储存路径</span></span><br><span class="line"><span class="built_in">NSString</span> *caches = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line"><span class="built_in">NSString</span> *filePath = [caches stringByAppendingPathComponent:downloadTask.response.suggestedFilename];</span><br><span class="line"><span class="comment">// 将下载好的文件移到目标路径 - 下载完成后的文件默认在tmp文件夹（location.path），需要转移到其他位置才能查看</span></span><br><span class="line"><span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">[mgr moveItemAtPath:location.path toPath:filePath error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul><li><p>配置代理方法的执行队列</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化session并指定代理, 指定调用代理方法的队列为主队列</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:cgr delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</span><br></pre></td></tr></table></figure><ul><li>如果 delegateQueue 为 <code>nil</code> 则等同于 <code>[[NSOperationQueue alloc] init]</code> 则不会把获得的数据返回给主线程 (无线程通信)</li><li>如果 delegateQueue 为 <code>[NSOperationQueue mainQueue]</code> 则会把获得的数据传给主线程 (有线程通信)</li></ul></li><li><p>在代理方法<code>totalBytesExpectedToWrite:</code>监听下载进度,打印当前的线程为主线程,与NSURLConnection一致.<strong>如果此时拖拽屏幕上的控件却并不会阻塞下载操作</strong>.为什么打印都在主线程,但是一个下载受影响一个不受影响? </p><ul><li>猜测: <strong>session的下载任务是开辟子线程异步执行的, 然后再将结果返回给主线程.</strong>并不是只有一条线程在处理这个操作,这里与connection有很大不同.并且测试出默认情况下用session下载同一个文件要比connection快,同时下载的时间却与connection开子线程异步下载的时间差不多.故有此猜测(仅仅是猜测).</li></ul></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>还有很多不完善的地方以后慢慢添砖.<br><br>以上的结论有很多仅仅只是猜测,欢迎来打脸.</p><p>参考: <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/UsingNSURLSession.html#//apple_ref/doc/uid/TP40013509-SW1" target="_blank" rel="noopener">苹果官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NSURLConnection&quot;&gt;&lt;a href=&quot;#NSURLConnection&quot; class=&quot;headerlink&quot; title=&quot;NSURLConnection&quot;&gt;&lt;/a&gt;NSURLConnection&lt;/h2&gt;&lt;h3 id=&quot;基本使用&quot;&gt;&lt;a href
      
    
    </summary>
    
    
    
      <category term="iOS干货" scheme="https://xionw1991.github.io/tags/iOS%E5%B9%B2%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>NSCache的介绍</title>
    <link href="https://xionw1991.github.io/2015/07/14/blog/31.NSCache%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>https://xionw1991.github.io/2015/07/14/blog/31.NSCache%E7%9A%84%E4%BB%8B%E7%BB%8D/</id>
    <published>2015-07-14T03:29:57.000Z</published>
    <updated>2020-06-23T15:18:08.857Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章介绍了如何使用NSCache来替代NSDictionary进行数据缓存.</p></blockquote><p><a href="http://www.15yan.com/topic/yi-dong-kai-fa-na-dian-shi/45toOUzFGlr/" target="_blank" rel="noopener">NSCache介绍</a></p><p>借此说一下SDWebImage这个框架中<code>cleanDisk</code>与<code>clearDisk</code>的区别:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//clean:删除过期缓存(缓存周期为1周),计算当前缓存文件的总大小,比较设置的最大缓存,如果超出的话,那么就继续删除(按照缓存文件创建的顺序),直到小于最大缓存为止</span></span><br><span class="line">[[SDWebImageManager sharedManager].imageCache cleanDisk];</span><br><span class="line"><span class="comment">//clear:简单粗暴,直接删除然后重新创建</span></span><br><span class="line">[[SDWebImageManager sharedManager].imageCache clearDisk];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这篇文章介绍了如何使用NSCache来替代NSDictionary进行数据缓存.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.15yan.com/topic/yi-dong-kai-fa-na-dian-shi
      
    
    </summary>
    
    
    
      <category term="iOS开发笔记" scheme="https://xionw1991.github.io/tags/iOS%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
